var app = angular.module("CMCApp", ["ngRoute"]);
var locaNotifyFun = function(type, message) {
    $.extend($.gritter.options, { 
        position: 'bottom-right', 
    });

    $.gritter.add({
        title: type,
        text: message,
        sticky: true,
        fade: true,
        time: 6,
        class_name: 'my-sticky-class'
    });
}

app.service('request', function($http, $rootScope) {
    this.sync = function(sendType, urlToPost, dataToSend, fsuccess, ffailed, asyncIs = false) {
        return $.ajax({
            async: asyncIs,
            type: sendType,
            url: urlToPost,
            data: dataToSend,
            success: fsuccess,
            error: ffailed,
        });
    }
    this.backend = function(routeName, data = {}, successFunction = null, successMessage = "", isForm = false) {
        var urlToPost = 'backend/' + routeName;
        if (isForm) {
            $.ajax({
                url: urlToPost,
                type: "POST",
                data: data,
                async: true,
                success: function(msg) {
                    if (msg.success) {
                        if (successFunction) {
                            successFunction(msg.data ? msg.data : []);
                        }
                        if (successMessage.length >= 2) {
                            locaNotifyFun('Sukces',successMessage);
                        }
                    } else {
                        if (msg.error) {
                            locaNotifyFun('Bład',msg.error);
                        }
                        if(msg.error == 'Nie masz wystarczających uprawnień'){
                            Cookies.remove('tq');
                            document.location = "login";
                        }
                    }
                },
                error: function(jqXHR, textStatus) {
                    console.log("Blad podczas laczenia z serverem: " + textStatus);
                    locaNotifyFun('Bład','Niestety nie udało się połączyć z serverem');
                },
                cache: false,
                contentType: false,
                processData: false
            });
        } else {
            var dataToSend = Object.assign({ token: Cookies.get('tq') }, data);
            $.ajax({
                url: urlToPost,
                type: "POST",
                data: dataToSend,
                async: true,
                success: function(msg) {
                    if (msg.success) {
                        if (successFunction) {
                            successFunction(msg.data ? msg.data : []);
                        }
                        if (successMessage.length > 2) {
                            locaNotifyFun('Sukces',successMessage);
                        }
                    } else {
                        if (msg.error) {
                            locaNotifyFun('Bład',msg.error);
                        }
                        if(msg.error == 'Nie masz wystarczających uprawnień'){
                            Cookies.remove('tq');
                            document.location = "login";
                        }
                    }
                },
                error: function(jqXHR, textStatus) {
                    console.log("Blad podczas laczenia z serverem: " + textStatus);
                    locaNotifyFun('Bład','Niestety nie udało się połączyć z serverem');
                }
            });
        }
    }
});
app.service('auth', function($http, $rootScope, request) {

    this.logIn = function(login, password) {
        var dataToSend = { email: login, pass: password };
        var urlToPost = "backend/login";
        var toReturn;
        request.sync('POST', urlToPost, dataToSend, function(reqData) {
            console.log(reqData);
            if (reqData.success) {
                Cookies.remove('tq');
                Cookies.set('tq', reqData.token, { expires: 1 });
            }
            toReturn = reqData;
        }, function(jqXHR, textStatus) {
            console.log("Bład podczas komunikacji z serverem: " + textStatus);
            toReturn = false;
        });

        return toReturn;
    }

    this.logout = function() {
        Cookies.remove('tq');
        document.location = "login";
    }

    this.checkIsLogged = function() {
        var token = Cookies.get('tq');
        if (token != null && token.length > 5) {
            var dataToSend = { token: token };
            var urlToPost = "backend/checkIsLoged";
            request.sync('POST', urlToPost, dataToSend,
                function(reqData) {
                    if (reqData.success) toReturn = true;
                    else toReturn = false;
                },
                function(jqXHR, textStatus) {
                    console.log("Bład podczas komunikacji z serverem: " + textStatus);
                    toReturn = false;
                });
        } else toReturn = false;

        return toReturn;
    }

    this.getUserData = function() {
        var tq = Cookies.get('tq');
        var toReturn = false;
        if (tq != null && tq.length > 5) {
            var dataToSend = { token: tq };
            var urlToPost = "backend/getUserData";
            request.sync('POST', urlToPost, dataToSend,
                function(reqData) {
                    toReturn = reqData;
                    $rootScope.user.email = reqData.data.email;
                    $rootScope.user.token = Cookies.get('tq');
                    $rootScope.user.role = reqData.data.name;
                    $rootScope.user.id = reqData.data.user_id;
                    $rootScope.user.firstname = reqData.data.firstname;
                    $rootScope.user.lastname = reqData.data.lastname;
                    $rootScope.user.birthdate = reqData.data.birthdate;
                    $rootScope.user.imgPath = reqData.data.user_img_path;
                    $rootScope.user.addAccountDate = reqData.data.create_account_date;
                    $rootScope.user.addAccountDate = reqData.data.create_account_date;
                    $rootScope.user.height = reqData.data.height;
                    $rootScope.user.tel = reqData.data.tel;
                    $rootScope.user.parentTel = reqData.data.parent_tel;
                    $rootScope.user.weight = reqData.data.weight;
                    $rootScope.user.mainLeg = reqData.data.main_leg;
                    $rootScope.user.mainPosition = reqData.data.main_position;
                    $rootScope.user.bodyType = reqData.data.body_type;
                    $rootScope.user.address = reqData.data.address;
                    $rootScope.user.license_type = reqData.data.license_type;
                },
                function(jqXHR, textStatus) {
                    console.log("Bład podczas komunikacji z serverem: " + textStatus);
                    toReturn = false;
                });
        }
        return toReturn;
    }

    this.checkPerm = function(permission) {
        if ($rootScope.user != null && $rootScope.user.role != null) {
            for (var i = 0; i < permission.length; i++) {
                if (permission[i] === $rootScope.user.role) return true;
            }
        } else return false;
    }

});
app.service('notify', function($http, $rootScope, request) {
    this.Notification = function(_title, _to, _url = '', _toAll = false) {
        this.title = _title;
        this.to = _to;
        this.toAll = _toAll;
        this.url = _url
    }

    this.localNotify = locaNotifyFun;

    this.addNew = function(notifyObj) {
        var urlToPost = "backend/addNotify";
        var dataToSend = {
            token: $rootScope.user.token,
            usid: $rootScope.user.id,
            tmid: $rootScope.user.tmid,
            title: notifyObj.title,
            to: notifyObj.to,
            toAll: notifyObj.toAll,
            url: notifyObj.url
        };
        request.sync('POST', urlToPost, dataToSend, function(e) {}, function(jqXHR, textStatus) {
            console.log("Bład podczas komunikacji z serverem: " + textStatus);
        }, true);

    }

    this.getNew = function(firstIs = false) {
        var urlToPost = "backend/getNewNotify";
        var dataToSend = {
            token: $rootScope.user.token,
            usid: $rootScope.user.id,
            tmid: $rootScope.user.tmid,
        };
        local = this.localNotify;
        request.sync('POST', urlToPost, dataToSend,
            function(reqData) {
                if (reqData.success) {
                    $rootScope.$apply(function() {
                        if (reqData.data) {
                            if (reqData.data[0]) {
                                if (reqData.data[0].id === $rootScope.lastNotId) return;
                                $rootScope.lastNotId = reqData.data[0].id;
                                $rootScope.newNotify = reqData.data;
                                let count = 0;
                                let toShow = null;
                                for (var i = 0; i < $rootScope.newNotify.length; i++) {
                                    if (reqData.data[i].is_new === "1") {
                                        count++;
                                        toShow = reqData.data[i];
                                    }
                                }
                                if(toShow){
                                    if(!firstIs){
                                        local('Otrzymano powiadomienie', toShow.title);
                                        if (Notification) {
                                            if (Notification.permission === "granted") {
                                                var notification = new Notification(toShow.title);
                                            }
                                            else {
                                                Notification.requestPermission(function (permission) {
                                                    if (permission === "granted") {
                                                        var notification = new Notification(toShow.title);
                                                    }
                                                });
                                            }
                                        }
                                    }
                                }
                                $rootScope.notifyCount = count;
                            }else {
                                $rootScope.notifyCount = 0;
                            }
                        }
                    });
                }
            },
            function(jqXHR, textStatus) {
                console.log("Bład podczas komunikacji z serverem: " + textStatus);
            }, true);
    }

    this.getAll = function() {
        var urlToPost = "backend/getAllNotify";
        var dataToSend = {
            token: $rootScope.user.token,
            usid: $rootScope.user.id,
            tmid: $rootScope.user.tmid
        };
        request.sync('POST', urlToPost, dataToSend, function(reqData) {
            if (reqData.success) {
                $rootScope.$apply(function() {
                    $rootScope.allNotify = reqData.data;
                });
            }
        }, function(jqXHR, textStatus) {
            console.log("Bład podczas komunikacji z serverem: " + textStatus);
        }, true);
    }

    this.setNewOff = function() {
        if ($rootScope.notifyCount <= 0) return;
        var urlToPost = "backend/setNewNotifyOff";
        var notIds = [];
        for (var i = 0; i < $rootScope.newNotify.length; i++) {
            notIds.push($rootScope.newNotify[i].id);
        }

        var dataToSend = {
            token: $rootScope.user.token,
            usid: $rootScope.user.id,
            tmid: $rootScope.user.tmid,
            ntid: notIds
        };
        request.sync('POST', urlToPost, dataToSend, function(msg) {
            $rootScope.$apply(function() {
                $rootScope.notifyCount = 0;
            });
        }, function(jqXHR, textStatus) {
            console.log("Bład podczas komunikacji z serverem: " + textStatus);
        }, true);
    }

});
app.service('statistic', function($http, $rootScope, request) {

    this.getStats = function(userId, functionSuccess, async = true, last = false) {
        var urlToPost = "backend/getStats";
        var dataToSend = {
            token: $rootScope.user.token,
            usid: userId,
            tmid: $rootScope.user.tmid,
            last: last
        };
        var toReturn = [];
        request.sync('POST', urlToPost, dataToSend,
            function(reqData) {
                if (reqData.success) {
                    $rootScope.$apply(function() {
                        $rootScope.actualStats = reqData.data;
                        toReturn = reqData.data;
                        functionSuccess();
                    });
                } else {
                    console.log('blad');
                }
            },
            function(jqXHR, textStatus) {
                console.log("Bład podczas komunikacji z serverem: " + textStatus);
            }, async);
        return toReturn;
    }

    this.getTeamForm = function(usersId = [], isMatchTeamForm = false) {
        var maxScore = 0;
        var teamScore = 0;
        if (!usersId || usersId.length == 0) {
            return 0;
        }
        var returnedData = this.getStats(usersId, function() {}, false, true);
        return parseFloat(100 * (isMatchTeamForm ? (returnedData.teamForm / (returnedData.maxPlayer*100)) : (returnedData.teamForm / (usersId.length * 100)))).toFixed(2);
    }

    this.getTeamStats = function(usersId = [], functionAfter) {
        $rootScope.actualStats = this.getStats(usersId, function() {}, false);
        $rootScope.actualStats = $rootScope.actualStats.users;
        functionAfter();
    }

});
app.controller('accountController', function($scope, auth, $rootScope, request, notify) {
    $scope.logout = auth.logout;
    let interval = null;

    $scope.initAccount = function() {
        if (!auth.checkIsLogged()) {
            auth.logout();
            return;
        }
        if(interval) clearInterval(interval);
        interval = setInterval(function(){
            $(".prettydate").each(function(){
                $(this).prettydate();
            });
        },200);
    };

    $scope.$on('$viewContentLoaded', function() {
        if (!auth.checkPerm($rootScope.viewPerm)) {
            if (!auth.checkIsLogged()) {
                auth.logout();
                return;
            }
            document.location = "#!badPerm";
        }
    });

    $scope.setPerm = function(perm) {
        $rootScope.viewPerm = perm;
    };

    $scope.updateUserDate = function(isPass = false) {
        var id = isPass ? "#userUpdateDataFormPassImg" : "#userUpdateDataForm";

        request.backend('updateUserData', new FormData($(id)[0]), function(data) {
            $rootScope.$apply(function() {
                auth.getUserData();
            });
        }, 'Twoje dane zostały pomyślnie zaktualizowane. Niektóre zmiany mogą być widoczne dopiero po odświeżeniu strony.( ctrl+f5 )', true);
    };

    $(document).off("change", "#userImgFile");
    $(document).on("change", "#userImgFile", function(event) {
        if ((event.target.files[0].size / 1024 / 1024) > 1.5) {
            notify.localNotify('Walidacja', 'Zdjęcie jest zbyt dużę. Maksymalny dozwolony rozmiar to 1.5 MB ');
            $(this).val('');
            return;
        }
        var tmppath = URL.createObjectURL(event.target.files[0]);
        $("#imgPrev").fadeIn("fast").attr('src', tmppath);

        request.backend('updateUserData', new FormData($('#userUpdateDataFormPassImg')[0]), function(data) {
            $rootScope.$apply(function() {
                auth.getUserData();
                $rootScope.user.imgPath = tmppath;
            });
        }, 'Twoje zdjęcie zostało zmienione.', true);

    });

});
app.controller('feedbackController', function($scope, auth, $rootScope, notify, request) {
    $scope.showContent = false;
    $scope.raportsList = [];

    $scope.initFeedback = function() {
        $scope.showContent = true;
    }

    $scope.sendFeedback = function() {
        var content  = $('#contentFeed').val();
        var type = $rootScope.feedType;
        if(!content || content.length <= 5 ){
            notify.localNotify("Walidacja","Prosimy o wpisanie dłuższej wiadomości.");
            return;
        }
        request.backend('sendFeedback', {
            firstname: $rootScope.user.firstname,
            lastname: $rootScope.user.lastname,
            tmid: $rootScope.user.tmid,
            content: content,
            type: type
         }, function(data) {
            $('#contentFeed').val('');
         },"Dziękujemy za udział w poprawie standardów naszej platformy.");
    }
});

app.controller('notifyController', function($scope, auth, $rootScope, notify, request) {
    $scope.allNotify = [];
    
    request.backend('getAllNotify', { usid: $rootScope.user.id, tmid:$rootScope.user.tmid }, function(data) {
        $scope.$apply(function() {
            $scope.allNotify = data;
            setTimeout(function(){
                $(".prettydate").prettydate();
                $.fn.prettydate.setDefaults();
            },500);
        });
    });

});
app.controller('showPlayersController', function($scope, auth, $rootScope, notify, request) {
    $scope.players;
    $scope.actualSelectedUserData;
    $scope.actualSelectedUserStats;
    $scope.actualSelectedUserRaports;
    $scope.showPlayerNow = false;
    $scope.showPreLoad = false;
    $scope.personShow = false;
    $scope.personAddShow = false;

    $scope.openCard = function(name) {
        $('#' + name).toggle('blind', null, 'fast');
        $scope.personShow = !$scope.personShow;
    }

    $scope.openCardFt = function(name) {
        $('#' + name).toggle('blind', null, 'fast');
        $scope.personAddShow = !$scope.personAddShow;
    }

    $scope.addPersonFromApp = function() {
        var selected = $('#selectPersonFromApp').val();
        if (selected && selected != null && selected != "") {
            request.backend('addPlayerToTeam', { tmid: $rootScope.user.tmid, usid: $scope.teamPlayer[selected].usid }, function(data) {
                $scope.getAllPlayers();
                notify.addNew(new notify.Notification("Zostałeś przypisany do nowej sekcji: ", [$scope.teamPlayer[selected].usid]));
            }, "Zawodnik dodany pomyslnie do tej sekcji");
        } else {
            notify.localNotify("Walidacja", "Wybierz najpierw zawodnika z listy dostępnych");
        }
    }

    $scope.getAllPlayers = function() {
        $rootScope.showContent = false;
        request.backend('getAllPlayers', { tmid: $rootScope.user.tmid }, function(data) {
            $scope.$apply(function() {
                $scope.players = data;
                $scope.showContent = true;
            });
        });
        request.backend('getAllPlayersFromApp', { tmid: $rootScope.user.tmid }, function(data) {
            $scope.$apply(function() {
                $scope.teamPlayer = data;
                $('#selectPersonFromApp').html('');
                $('#selectPersonFromApp').append("<option value='' disabled> Wybierz użytkownika </option>");
                for (var i = 0; i < data.length; i++) {
                    $('#selectPersonFromApp').append("<option value='" + i + "'>" + data[i].firstname + " " + data[i].lastname + "</option>");
                }
                $('select').material_select();
            });
        });
    }

    $scope.showThisPlayer = function(usidN) {
        $scope.showPreLoad = true;
        request.backend('getAllUserData', { usid: usidN }, function(data) {
            $scope.$apply(function() {
                $scope.actualSelectedUserData = data;
                $scope.actualSelectedUserData.id = usidN;
            });
            getUserRaports(usidN);
        });
    }

    $scope.deleteUser = function(usidN) {

        $rootScope.showModalWindow("Usunięcie użytkownika z sekcji", function() {
            request.backend('deleteUser', { usid: usidN, tmid: $rootScope.user.tmid }, function() {
                $scope.getAllPlayers();
                notify.addNew(new notify.Notification("Zostałeś usunięty z sekcji: " + $rootScope.teamNameStr, [usidN], "#!/"));
            }, 'Osoba usunięta z sekcji');
        });

    }

    $scope.addPerson = function() {
        var firstname = $('#addedFirstname').val();
        var lastname = $('#addedLastname').val();
        var email = $('#addedEmail').val();
        var re = /^(([^<>()[\]\\.,;:\s@\"]+(\.[^<>()[\]\\.,;:\s@\"]+)*)|(\".+\"))@((\[[0-9]{1,3}\.[0-9]{1,3}\.[0-9]{1,3}\.[0-9]{1,3}\])|(([a-zA-Z\-0-9]+\.)+[a-zA-Z]{2,}))$/;
        if (!re.test(email)) {
            notify.localNotify('Bład', 'Popraw wpisany adres email');
            return;
        }
        if (firstname.length < 3 || lastname.length < 3) {
            notify.localNotify('Bład', 'Imię lub nazwisko jest zbyt krótkie');
            return;
        }
        request.backend('addPerson', { tmid: $rootScope.user.tmid, fname: firstname, lname: lastname, mail: email, isPersonel: false, isAdmin: 'false' }, function() {
            $('#addedFirstname').val('');
            $('#addedLastname').val('');
            $('#addedEmail').val('');
            $scope.getAllPlayers();
        }, 'Osoba została dodana. Na jej adres email zostało wysłane hasło. Wiadomość może trafić do folderu spam');
    }

    $scope.resendPassword = function(id) {
        request.backend('recreatePassword', { usid: id }, function() {}, 'Pomyślnie zmieniono hasło i wysłano maila z hasłem');
    }

    function getUserRaports($userId) {
        request.backend('getRaport', { usid: $userId, tmid: $rootScope.user.tmid }, function(data) {
            $scope.$apply(function() {
                $scope.actualSelectedUserRaports = data;
                $scope.showPlayerNow = true;
                $scope.showPreLoad = false;
            });
        });
    }

    $scope.addRaport = function() {
        $name = $("#raportName").val();
        if ($name.length <= 3) {
            notify.localNotify('Walidacja', 'Wpisz nazwę raportu');
            return;
        }
        request.backend('addRaport', new FormData($("#raportForm")[0]), function(data) {
            notify.addNew(new notify.Notification("Uzyskałeś raport: " + $name, [$scope.actualSelectedUserData.id], "#!/myRaports"));
            getUserRaports($scope.actualSelectedUserData.id);
        }, 'Twoj plik został przesłany pomyślnie.', true);
    };

    $scope.deleteRaport = function(rpid) {


        $rootScope.showModalWindow("Usunięcie raportu użytkownika", function() {
            request.backend('deleteRaport', { id: rpid }, function() {
                getUserRaports($scope.actualSelectedUserData.id);
            }, 'Plik zostal usuniety');
        });


    }
});
app.controller('myRaportsController', function($scope, auth, $rootScope, notify, request) {
    $scope.showContent = false;
    $scope.raportsList = [];

    $scope.initRaports = function() {
        getUserRaports($rootScope.user.id);
    }

    function getUserRaports($userId) {
        request.backend('getRaport', { usid: $userId, tmid: $rootScope.user.tmid }, function(data) {
            $scope.$apply(function() {
                $scope.raportsList = data;
                $scope.showContent = true;
            });
        });
    }
});
app.controller('settingsController', function($scope, auth, $rootScope, request, notify) {
    $scope.showContent = false;
    $scope.installedModules = [];
    $scope.notInstalledModules = [];
    $scope.toUpdateModule = [];
    $scope.actualTheme = "";
    $scope.allThemes = [];

    $scope.initSettings = function() {
        getInstalledModules();
        getAvilableModules();
    }

    $scope.initThemes = function() {
        getActualThemes();
    }

    $scope.initMainSettings = function() {
        getMainSettings();
    }

    $scope.installModule = function(moduleName) {
        request.backend('installModule', { name: moduleName }, function(data) {
            getInstalledModules();
            getAvilableModules();
        }, "Moduł zainstalowany. Odświerz stronę, aby zobaczyć zmiany");
    }

    $scope.uninstallModule = function(moduleName) {
        request.backend('uninstallModule', { name: moduleName }, function(data) {
            getInstalledModules();
            getAvilableModules();
        }, "Moduł odinstalowany. Odświerz stronę, aby zobaczyć zmiany");
    }

    $scope.addModule = function() {
        if ($('#moduleFile').get(0).files.length === 0) {
            notify.localNotify('Walidacja', "Dodaj najpierw plik modułu");
            return;
        }
        var data = new FormData($('#addModuleForm')[0]);
        request.backend('addModule', data, function() {
            getAvilableModules();
        }, "Moduł dodany pomyślnie", true);
    }

    $scope.checkAppUpdate = function() {
        notify.localNotify("Update", "Posiadasz aktualną wersję aplikacji");
    }

    $scope.checkUpdateModule = function() {
        request.backend('checkModuleUpdate', {}, function(data) {
            $scope.$apply(function() {
                $scope.toUpdateModule = data;
            });
        });
    }

    $scope.updateModule = function(moduleName) {
        request.backend('installUpdateToModule', { moduleName: moduleName }, function(data) {

        }, "Moduł zaktualizowany pomyślnie. Odświerz stronę, aby zobaczyć zmiany.");
    }

    function getActualThemes() {
        request.backend('getCurrentThemes', {}, function(data) {
            $scope.$apply(function() {
                $scope.actualTheme = data;
            });
            request.backend('getAvailableThemes', {}, function(data) {
                $scope.$apply(function() {
                    $scope.allThemes = data;
                    $scope.showContent = true;
                    $('#selectThemes').html('');
                    $('#selectThemes').append("<option value='' disabled >Szablony</option>");
                    for (var i = 0; i < $scope.allThemes.length; i++) {
                        if ($scope.allThemes[i] == $scope.actualTheme)
                            $('#selectThemes').append("<option value='" + $scope.allThemes[i] + "' selected>" + $scope.allThemes[i] + "</option>");
                        else
                            $('#selectThemes').append("<option value='" + $scope.allThemes[i] + "'>" + $scope.allThemes[i] + "</option>");
                    }
                    $('select').material_select();
                });
            });
        });
    }

    function getInstalledModules() {
        request.backend('getInstalledModules', {}, function(data) {
            $scope.$apply(function() {
                for (var i = 0; i < data.length; i++) {
                    var req = "";
                    for (var j = 0; j < data[i].require.length; j++) {
                        req += " " + data[i].require[j];
                    }
                    data[i].require = req;
                }
                $scope.installedModules = data;
            });
        });
    }

    function getAvilableModules() {
        request.backend('getAvailableModules', {}, function(data) {
            $scope.$apply(function() {
                for (var i = 0; i < data.length; i++) {
                    var req = "";
                    for (var j = 0; j < data[i].require.length; j++) {
                        req += " " + data[i].require[j];
                    }
                    data[i].require = req;
                }
                $scope.notInstalledModules = data;
                $scope.showContent = true;
            });
        });
    }

    function getMainSettings() {
        request.backend('getMainPageSettings', {}, function(data) {
            $rootScope.$apply(function() {
                $rootScope.mainSettings = data;
                $(document).ready(function() {
                    Materialize.updateTextFields();
                });
            });
            $scope.$apply(function() {
                $scope.showContent = true;
            });
        });
    }

    $(document).off("change", "#selectThemes");
    $(document).on("change", "#selectThemes", function() {
        request.backend('setCurrentTheme', { name: $(this).val() }, null, "Pomyślnie zmieniono szablon. Odśwież stronę, aby zobaczyć zmiany. (ctrl+f5)");
    });

    $(document).off("change", "#logoFile");
    $(document).on("change", "#logoFile", function() {
        if ($('#logoFile').get(0).files.length === 0) {
            notify.localNotify('Walidacja', "Dodaj poprawnie plik loga");
            return;
        }
        var data = new FormData($('#addLogoForm')[0]);
        request.backend('changePageLogo', data, function() {
            var reader = new FileReader();
            reader.onload = function(e) {
                $('#prevLogo').attr('src', e.target.result);
            }
            reader.readAsDataURL($('#logoFile').get(0).files[0]);
        }, "Logo zmienione pomyślnie", true);
    });

    $(document).off("change", "#moduleFile");
    $(document).on("change", "#moduleFile", function() {
        $scope.addModule();
    });

    $(document).off("change", "#backFile");
    $(document).on("change", "#backFile", function() {
        if ($('#backFile').get(0).files.length === 0) {
            notify.localNotify('Walidacja', "Dodaj poprawnie plik tła");
            return;
        }
        var data = new FormData($('#addBackgroundForm')[0]);
        request.backend('changePageBackground', data, function() {
            var reader = new FileReader();
            reader.onload = function(e) {
                $('#prevBack').attr('src', e.target.result);
            }
            reader.readAsDataURL($('#backFile').get(0).files[0]);
        }, "Tło strony logowania zmienione pomyślnie", true);
    });

    $(document).off("change", "#icoFile");
    $(document).on("change", "#icoFile", function() {
        if ($('#icoFile').get(0).files.length === 0) {
            notify.localNotify('Walidacja', "Dodaj poprawnie plik tła");
            return;
        }
        var data = new FormData($('#addIconForm')[0]);
        request.backend('changePageIcon', data, function() {
            var reader = new FileReader();
            reader.onload = function(e) {
                $('#prevIconPage').attr('src', e.target.result);
            }
            reader.readAsDataURL($('#icoFile').get(0).files[0]);
        }, "Ikona strony zmieniona pomyślnie", true);
    });

    $(document).off("change", "#appName");
    $(document).on("change", "#appName", function() {
        if ($('#appName').val().length < 3) {
            notify.localNotify('Walidacja', "Wpisz dłuższą nazwę aplikacji");
            return;
        }
        request.backend('changeAppMainSettings', { appName: $('#appName').val() }, function() {
            getMainSettings();
        }, "Pomyślnie zapisano");
    });
});
app.controller('staffController', function($scope, auth, $rootScope, notify, request) {
    $scope.lastId = 0;
    $scope.staffMembers = [];
    $scope.personelMembers = [];
    $scope.koordsInSite = [];

    $scope.getStaffMembers = function() {
        $rootScope.showContent = false;
        getAllPersonel();
        getKoords();
        request.backend('getTeamStaff', { tmid: $rootScope.user.tmid }, function(data) {
            $scope.$apply(function() {
                $scope.staffMembers = data
                $scope.showContent = true;
            });
        });
    }
    $scope.addPerson = function() {
        var firstname = $('#addedFirstname').val();
        var lastname = $('#addedLastname').val();
        var email = $('#addedEmail').val();
        var re = /^(([^<>()[\]\\.,;:\s@\"]+(\.[^<>()[\]\\.,;:\s@\"]+)*)|(\".+\"))@((\[[0-9]{1,3}\.[0-9]{1,3}\.[0-9]{1,3}\.[0-9]{1,3}\])|(([a-zA-Z\-0-9]+\.)+[a-zA-Z]{2,}))$/;
        if (!re.test(email)) {
            notify.localNotify('Bład', 'Popraw wpisany adres email');
            return;
        }
        if (firstname.length < 3 || lastname.length < 3) {
            notify.localNotify('Bład', 'Imię lub nazwisko jest zbyt krótkie');
            return;
        }
        request.backend('addPerson', { tmid: $rootScope.user.tmid, fname: firstname, lname: lastname, mail: email, isPersonel: true, isAdmin: 'false' }, function() {
            $('#addedFirstname').val('');
            $('#addedLastname').val('');
            $('#addedEmail').val('');
            $scope.getStaffMembers();
        }, 'Osoba została dodana. Na jej adres email zostało wysłane hasło. Wiadomość może trafić do folderu spam');
    }

    $scope.addStaff = function() {
        var addUserId = $('#addStaffMembersSelect').val();
        var addName = $('#typeStaff').val();
        request.backend('addStaff', { tmid: $rootScope.user.tmid, name: addName, usid: addUserId }, function(data) {
            $scope.getStaffMembers();
            notify.addNew(new notify.Notification("Dodano nowy personel: " + addName, null, "#!/staff", true));
        }, 'Personel dodany pomyślnie');
    }

    $scope.deleteStaff = function(staffId) {
        $rootScope.showModalWindow("Nieodwracalne usunięcie personelu", function() {
            request.backend('deleteStaff', { stid: staffId }, function(data) {
                $scope.getStaffMembers();
            }, 'Personel usunięty pomyślnie');
        });
    }

    function getAllPersonel() {
        request.backend('getFullPersonel', { tmid: $rootScope.user.tmid }, function(data) {
            $scope.personelMembers = data;
            $('#prBar').attr('aria-valuenow', 50);
            $('#prBar').css('width', '50%');
            $('#addStaffMembersSelect').html("");
            for (var i = 0; i < data.length; i++) {
                $('#addStaffMembersSelect').append("<option value='" + data[i].usid + "'>" + data[i].firstname + " " + data[i].lastname + " [ " + data[i].rlname + " ] </option>");
            }
            $('select').material_select();
        });
    }

    function getKoords() {
        request.backend('getKoords', {}, function(data) {
            $scope.$apply(function() {
                $scope.koordsInSite = data;
            });
        });
    }

});
app.controller('masterMenagerController', function($scope, auth, $rootScope, notify, request) {
    $scope.showContent = false;
    $scope.masters = [];

    $scope.getAllMasters = function() {
        getAllMaster();
    }

    function getAllMaster() {
        request.backend('getAllMaster', {}, function(data) {
            $scope.$apply(function() {
                $scope.masters = data;
                $scope.showContent = true;
            });
        });
    }

    $scope.deleteUser = function(usidN) {

        $rootScope.showModalWindow("Usunięcie użytkownika", function() {
            request.backend('deleteUser', { usid: usidN }, function() {
                $scope.$apply(function() {
                    $scope.getAllMasters();
                });
            }, 'Osoba usunięta wraz z powiązaniami');
        });


    }

    $scope.addPerson = function() {
        var firstname = $('#addedFirstname').val();
        var lastname = $('#addedLastname').val();
        var email = $('#addedEmail').val();
        var re = /^(([^<>()[\]\\.,;:\s@\"]+(\.[^<>()[\]\\.,;:\s@\"]+)*)|(\".+\"))@((\[[0-9]{1,3}\.[0-9]{1,3}\.[0-9]{1,3}\.[0-9]{1,3}\])|(([a-zA-Z\-0-9]+\.)+[a-zA-Z]{2,}))$/;
        if (!re.test(email)) {
            notify.localNotify('Bład', 'Popraw wpisany adres email');
            return;
        }
        if (firstname.length < 3 || lastname.length < 3) {
            notify.localNotify('Bład', 'Imię lub nazwisko jest zbyt krótkie');
            return;
        }
        request.backend('addPerson', { fname: firstname, lname: lastname, mail: email, isAdmin: true, tmid: -1, isPersonel: false }, function() {
            $('#addedFirstname').val('');
            $('#addedLastname').val('');
            $('#addedEmail').val('');
            $scope.$apply(function() {
                $scope.getAllMasters();
            });
        }, 'Osoba została dodana. Na jej adres email zostało wysłane hasło.');
    }

});
app.controller('sectionGetController', function($scope, auth, $rootScope, notify, request) {
    $scope.showContent = false;
    $scope.isGetEnabled = false;
    $scope.sectionData = [];
    $scope.sectionApplayer = [];
    $scope.availableSection = [];

    $scope.turnOnSectionGet = function() {
        var minY = parseInt($('#sectionYMin').val());
        var maxY = parseInt($('#sectionYMax').val());
        var description = $('#sectionDesc').val();
        if (minY >= maxY) {
            notify.localNotify("Walidacja", "Maksymalny wiek musi być większy od " + minY);
            return;
        }
        if (!description || description.length <= 10) {
            notify.localNotify("Walidacja", "Wpisz dłuższy opis sekcji ( min. 10 znaków )");
            return;
        }
        request.backend('turnOnSectionGet', { tmid: $rootScope.user.tmid, max: maxY, min: minY, desc: description }, function(data) {
            $scope.$apply(function() {
                $scope.isGetEnabled = true;
                getSectionApplayer();
            })
        });
    }

    $scope.addPersonToTeamApplicant = function(tmid) {
        request.backend('addPersonToTeamApplicant', { usid: $rootScope.user.id, tmid: tmid }, function(data) {}, "Twoja aplikacja została dodana, oczekuj na powiadomienia związane z decyzją");
    }

    $scope.getAvailableSection = function() {
        request.backend('getAvailableSection', { usid: $rootScope.user.id }, function(data) {
            $scope.$apply(function() {
                $scope.availableSection = data;
                $scope.showContent = true;
                setTimeout(function(){
                    $('.collapsible').collapsible();
                },100);
            });
        });
    }

    $scope.turnOffSectionGet = function() {
        request.backend('turnOffSectionGet', { tmid: $rootScope.user.tmid }, function(data) {
            $scope.$apply(function() {
                $scope.isGetEnabled = false;
            });
            var usArray = [];
            for (var index = 0; index < $scope.sectionApplayer.length; index++) {
                usArray.push($scope.sectionApplayer[index].usid);
            }
            notify.addNew(new notify.Notification("Nabór do sekcji " + $rootScope.teamNameStr + " został zakończony. Nie zostałeś przyjęty.", usArray, "#!/sectionGetForPlayer"));
        });
    }

    $scope.getSectionData = function() {
        request.backend('getSectionData', { tmid: $rootScope.user.tmid }, function(data) {
            $scope.$apply(function() {
                $scope.sectionData = data;
                $scope.isGetEnabled = $scope.sectionData.isGetEnabled == 1;
                if ($scope.isGetEnabled) {
                    getSectionApplayer();
                }
                $scope.showContent = true;
            });
        });
    }

    $scope.deletePlayerApplay = function(aplId, usid) {

        $rootScope.showModalWindow("Oddalenie prośby o dołączenie do sekcji", function() {
            request.backend('deletePlayerAplay', { tmid: $rootScope.user.tmid, aplId: aplId, usid: usid }, function(data) {
                $scope.$apply(function() {
                    $scope.sectionApplayer = data;
                });
                notify.addNew(new notify.Notification("Twoja prośba o dołączenie do sekcji: " + $rootScope.teamNameStr + " została odrzucona", [usid], "#!/sectionGetForPlayer"));
            }, "Pomyślnie usunięto prośbę. Zostanie ona odpowiednio powiadomiona.");
        });

    }

    $scope.addPlayerToTeam = function(aplId, usid) {
        request.backend('applayPlayerToTeam', { tmid: $rootScope.user.tmid, aplId: aplId, usid: usid }, function(data) {
            $scope.$apply(function() {
                $scope.sectionApplayer = data;
            });
            notify.addNew(new notify.Notification("Prośba o dołączenie do sekcji: " + $rootScope.teamNameStr + " rozpatrzona pomyślnie. Zostałeś przypisany", [usid], "#!/sectionGetForPlayer"));
        }, "Pomyślnie dodano osobę do teamu. Zostanie ona odpowiednio powiadomiona.");
    }

    function getSectionApplayer() {
        request.backend('getSectionApplayer', { tmid: $rootScope.user.tmid }, function(data) {
            $scope.$apply(function() {
                $scope.sectionApplayer = data;
            })
        });
    }

});
app.controller('teamsMenagerController', function($scope, auth, $rootScope, notify, request) {
    $scope.showContent = false;
    $scope.teams = [];
    $scope.teamMasters = [];
    $scope.masters = [];

    $scope.showPlayerNow = false;
    $scope.showPreLoad = false;
    $scope.personShow = false;

    $scope.actualSelectedTeamId = -1;

    $scope.openCard = function(name) {
        $('#' + name).toggle('blind', null, 'fast');
        $scope.personShow = !$scope.personShow;
    }

    $scope.initTeams = function() {
        getAllTeams();
        getAllMaster();
    }

    function getAllMaster() {
        request.backend('getAllMaster', {}, function(data) {
            $scope.$apply(function() {
                $scope.showContent = true;
                $scope.masters = data;
                for (var i = 0; i < data.length; i++) {
                    $('#mastersSelect').append("<option value='" + data[i].usid + "'>" + data[i].firstname + " " + data[i].lastname + "</option>");
                }
                $('select').material_select();
            });
        });
    }

    function getAllTeams() {
        request.backend('getAllTeams', {}, function(data) {
            $scope.$apply(function() {
                $scope.teams = data;
            });
        });
    }

    function getAllMastersFromTeam(id, functionSuccess) {
        $scope.actualSelectedTeamId = id;
        request.backend('getAllMastersFromTeam', { tmid: id }, function(data) {
            $scope.teamMasters = [];
            $scope.$apply(function() {
                $scope.teamMasters = data;
            });
            functionSuccess();
        });
    }

    $scope.showThisTeam = function(id) {
        $scope.showPreLoad = true;
        $scope.showPlayerNow = false;
        getAllMastersFromTeam(id, function() {
            $scope.$apply(function() {
                $scope.showPreLoad = false;
                $scope.showPlayerNow = true;
            });
        });
    }

    $scope.deleteTeam = function(id) {

        $rootScope.showModalWindow("Usunięcie drużyny", function() {
            request.backend('deleteTeam', { id: id }, function() {
                getAllTeams();
                $scope.$apply(function() {
                    $scope.showPlayerNow = false;
                });
            }, 'Udało się usunąc drużynę wraz z zawartością');
        });

    }

    $scope.addTeam = function() {
        var name = $('#teamName').val();
        if (name.length < 3) {
            notify.localNotify('Walidacja', "Wpisz dłuższą nazwę");
            return;
        }
        var weight = Number.isInteger(parseInt($('#teamWeight').val())) ? parseInt($('#teamWeight').val()) : 999;
        request.backend('addTeam', { name: name, weight: weight }, function(data) {
            getAllTeams();
            request.backend('getTeams', {}, function(data) {
                if (data.length == 0) {
                    notify.localNotify('Uwaga', "Twoje konto będzie ograniczone dopóki nie zostaniesz przypisany do drużyny");
                } else {
                    $('#teamSelect').html('');
                    $('#teamSelect').append("<option value='' disabled> Wybierz drużynę </option>");
                    for (var i = 0; i < data.length; i++) {
                        $('#teamSelect').append("<option value='" + data[i].tmid + "'" + (i == 0 ? 'selected' : '') + ">" + data[i].name + "</option>");
                    }
                    if (data[0] != null && data[0].tmid != null) $rootScope.user.tmid = data[0].tmid;
                    setInterval(function() {
                        notify.getNew();
                    }, 2000);
                }
                $('select').material_select();
            });
        }, "Dodano nową drużynę, możesz przydzielić teraz trenerów");
    }

    $scope.deleteMaster = function(id) {

        $rootScope.showModalWindow("Usunięcie trenera z drużyny", function() {
            request.backend('deleteMasterFromTeam', { mid: id, tmid: $scope.actualSelectedTeamId }, function(data) {
                $scope.showThisTeam($scope.actualSelectedTeamId);
                var actualTeamName = '';
                for (var index = 0; index < $scope.teams.length; index++) {
                    if ($scope.teams[index].id == $scope.actualSelectedTeamId) {
                        actualTeamName = $scope.teams[index].name
                    }
                }
                notify.addNew(new notify.Notification("Zostałeś usunięty z drużyny: " + actualTeamName, [id], ""));
            }, 'Udało się usunąc trenera z danej drużyny');
        });

    }

    $scope.addTeamMaster = function() {
        var mid = $('#mastersSelect').val();
        if (!mid || mid < 0) {
            notify.localNotify('Bład', 'Wybierz trenera do dodania');
            return;
        }

        request.backend('addMasterToTeam', { mid: mid, tmid: $scope.actualSelectedTeamId }, function(data) {
            $scope.showThisTeam($scope.actualSelectedTeamId);
            var actualTeamName = '';
            for (var index = 0; index < $scope.teams.length; index++) {
                if ($scope.teams[index].id == $scope.actualSelectedTeamId) {
                    actualTeamName = $scope.teams[index].name
                }
            }
            notify.addNew(new notify.Notification("Przypisano Cię do nowej drużyny: " + actualTeamName, [mid], ""));
        }, 'Dodano trenera do drużyny');

    }

    $(document).off("change", ".changeWeight");
    $(document).on("change", ".changeWeight", function() {
        var idTeam = $(this).attr('id').split("-")[1];
        var weight = parseInt($(this).val());
        if (Number.isInteger(weight) && weight <= 999 && weight >= 0) {
            request.backend('changeWeightTeam', { tmid: idTeam, weight: weight }, function(data) {
                getAllTeams();
            }, "Zmieniono pozycję pomyślnie");
        } else {
            notify.localNotify('Walidacja', "Wpisz liczbę całkowitą z przedzialu 0 - 999");
        }
    });

});
app.controller('calendarController', function($scope, auth, $rootScope, request, notify) {
    $scope.actualEdit = '';
    $scope.allEvents = '';
    $scope.selectedColor = '#0099ff';

    $scope.initAllEv = function() {
        $rootScope.showContent = false;
        $scope.getAllEvents();
    }

    $scope.getAllEvents = function() {
        request.backend('getNews', { tmid: $rootScope.user.tmid }, function(data) {
            $scope.$apply(function() {
                $scope.allEvents = data;
                $scope.showContent = true;
                setTimeout(function() {
                    initCalendar();
                }, 500);
            });
        });
    };

    $scope.addEvent = function(valid) {
        var title1 = $("#addTitleNews").val();
        var start1 = $("#addStartNews").val();
        var end1 = $("#addEndNews").val();
        if (title1.length > 1 && start1.length > 1 && end1.length > 1) {
            request.backend('addNews', { tmid: $rootScope.user.tmid, title: title1, start: start1, end: end1, color: $scope.selectedColor }, function(data) {
                $scope.getAllEvents();
                $('.editEvent').hide();
                $("#addTitleNews").val('');
                $("#addStartNews").val('');
                $("#addEndNews").val('');
                notify.addNew(new notify.Notification("Dodano wydarzenie: '" + title1 + "'", null, "#!/calendar", true));
            }, 'Dodano wydarzenie pomyślnie');
        }
    };

    $scope.editEvent = function() {
        if ($scope.actualEdit != '' && $("#editTitle").val().length > 2) {
            request.backend('editNews', { id: $scope.actualEdit.id, title: $("#editTitle").val() }, function(data) {
                $scope.getAllEvents();
            }, 'Wydarzenie edytowane pomyślnie');
        }
        $('.editEvent').hide();
        $scope.actualEdit = '';
    };

    $scope.deleteEvent = function() {
        if ($scope.actualEdit != '') {
            request.backend('deleteNews', { tmid: $scope.actualEdit.id_team, id: $scope.actualEdit.id }, function(data) {
                $scope.getAllEvents();
            }, 'Wydarzenie usunięte pomyślnie');
        }
        $('.editEvent').hide();
        $scope.actualEdit = '';
    };

    $scope.selectColor = function(color) {
        $('.borderSelectedColor').css("border-color", color);
        $scope.selectedColor = color;
    }

    function initCalendar() {
        /* initialize the calendar----------------------------*/
        var date = new Date();
        var d = date.getDate();
        var m = date.getMonth();
        var y = date.getFullYear();

        $('#calendar').html('');
        $('#calendar').fullCalendar({
            header: {
                left: 'prev,next today',
                center: 'title',
                right: 'month,basicWeek,basicDay'
            },
            editable: ($rootScope.user.role == 'TRENER' || $rootScope.user.role == 'KOORD'),
            droppable: true,
            displayEventTime: true,
            drop: function(date, allDay) {
                var originalEventObject = $(this).data('eventObject');
                var copiedEventObject = $.extend({}, originalEventObject);
                copiedEventObject.start = date;
                copiedEventObject.allDay = allDay;

                $('#calendar').fullCalendar('renderEvent', copiedEventObject, true);
                $(this).remove();
            },
            eventClick: function(calEvent, jsEvent, view) {
                $scope.$apply(function() {
                    $scope.actualEdit = calEvent;
                });
                $('.editEvent').show();
                $(this).css('border-color', 'red');

            },
            eventDrop: function(event) {
                request.backend('editNews', { id: event.id, start: moment(event.start).format('YYYY-MM-DD HH:mm:ss'), end: moment(event.end).format('YYYY-MM-DD HH:mm:ss') }, function(data) {
                    $scope.getAllEvents();
                }, 'Wydarzenie edytowane pomyślnie');
            },
            eventResize: function(event, delta, revertFunc) {
                request.backend('editNews', { id: event.id, start: moment(event.start).format('YYYY-MM-DD HH:mm:ss'), end: moment(event.end).format('YYYY-MM-DD HH:mm:ss') }, function(data) {
                    $scope.getAllEvents();
                }, 'Wydarzenie edytowane pomyślnie');
            },
            events: $scope.allEvents,
            timeFormat: 'H(:mm)'
        });
    };

});
app.controller('teamFreqController', function($scope, auth, $rootScope, request, notify) {
    $scope.showContent = false;
    $scope.isSelectedCorrectDate = true;
    $scope.inDaysFreq = [];
    $scope.loadedData = false;
    var currentTime = new Date();

    $scope.initFreq = function() {
        $scope.showContent = true;
        $("#yearDate").val(currentTime.getFullYear());
        $("#yearDate").attr("max", currentTime.getFullYear());
        $("#monthDate").val(currentTime.getMonth() + 1);
        $("#dayDate").val(currentTime.getDate());
        loadFrequencyData($("#yearDate").val(), $("#monthDate").val(), $("#dayDate").val());
        resetDayInMonthMax();
        Materialize.updateTextFields();
    }

    function loadFrequencyData(year, month, day) {
        $scope.loadedData = false;
        $scope.inDaysFreq = [];
        request.backend('getFrequency', { tmid: $rootScope.user.tmid, year: year, month: month, day: day }, function(data) {
            $scope.$apply(function() {
                $scope.inDaysFreq = data;
                $scope.loadedData = true;
            });
        });
    }

    $(document).off("change", "#yearDate");
    $(document).on("change", "#yearDate", function() {
        var count = parseInt($("#yearDate").val());
        if (count < 2017 || count > currentTime.getFullYear()) {
            notify.localNotify('Walidacja', "Rok musi być w przedzial 2017-aktualny");
            $scope.isSelectedCorrectDate = false;
            return;
        }
        $scope.isSelectedCorrectDate = true;
        resetDayInMonthMax();
        $("#dayDate").val("1");
        loadFrequencyData($("#yearDate").val(), $("#monthDate").val(), $("#dayDate").val());
    });

    $(document).off("change", "#monthDate");
    $(document).on("change", "#monthDate", function() {
        var count = parseInt($("#monthDate").val());
        if (count < 1 || count > 12) {
            notify.localNotify('Walidacja', "Wpisany nieistniejący miesiąc");
            $scope.isSelectedCorrectDate = false;
            return;
        }
        $scope.isSelectedCorrectDate = true;
        resetDayInMonthMax();
        $("#dayDate").val("1");
        loadFrequencyData($("#yearDate").val(), $("#monthDate").val(), $("#dayDate").val());
    });

    $(document).off("change", "#dayDate");
    $(document).on("change", "#dayDate", function() {
        var count = parseInt($("#dayDate").val());
        if (count < 1 || count > $("#dayDate").attr("max")) {
            notify.localNotify('Walidacja', "Podany dzień nie istnieje w danym miesiącu");
            $scope.isSelectedCorrectDate = false;
            return;
        }
        $scope.isSelectedCorrectDate = true;
        loadFrequencyData($("#yearDate").val(), $("#monthDate").val(), $("#dayDate").val());
    });

    $(document).off("change", ".onTrainingChecbox");
    $(document).on("change", ".onTrainingChecbox", function() {
        var usid = $(this).attr('id').split("-")[1];
        var year = $("#yearDate").val();
        var month = $("#monthDate").val();
        var day = $("#dayDate").val();
        var isChecked = $(this).is(':checked');
        if ($rootScope.user.role != 'ZAWODNIK') {
            if (isChecked) {
                request.backend('setOnTraining', { tmid: $rootScope.user.tmid, year: year, month: month, day: day, usid: usid });
                $(this).prop('checked', true);
            } else {
                request.backend('setOffTraining', { tmid: $rootScope.user.tmid, year: year, month: month, day: day, usid: usid });
                $(this).prop('checked', false);
            }
        }
    });

    function resetDayInMonthMax() {
        var dayCount = new Date($("#yearDate").val(), $("#monthDate").val(), 0).getDate();
        $("#dayDate").attr("max", dayCount);

    }
});
app.controller('mainDashboardController', function($scope, auth, $rootScope, request, notify) {
    $scope.nowEvents = [];
    $scope.nextEvents = [];
    $scope.lastPost = [];
    $scope.showContent = true;
    $scope.isLoadedPost = false;
    $scope.todayInt = (new Date()).getDay();
    $scope.licenseDate = [];


    $scope.getAllEvents = function() {
        if ($rootScope.user.tmid && $rootScope.user.tmid != "") {
            $scope.getNextEvents();
            $scope.getNowStartEvents();
            $scope.getLastPost();
        }
    }

    $scope.getNextEvents = function() {
        if($rootScope.user.tmid && $rootScope.user.tmid != '')
        request.backend('getNextEvents', { tmid: $rootScope.user.tmid }, function(data) {
            $scope.$apply(function() {
                $scope.nextEvents = data;
            });
        });
    }

    $scope.getLicenseDate = function() {
        if($rootScope.user.tmid && $rootScope.user.tmid != '')
        request.backend('getCountOfLicenseData', { tmid: $rootScope.user.tmid }, function(data) {
            $scope.$apply(function() {
                $scope.licenseDate = data;
            });
        });
    }

    $scope.getNowStartEvents = function() {
        if($rootScope.user.tmid && $rootScope.user.tmid != '')
        request.backend('getNowEvents', { tmid: $rootScope.user.tmid }, function(data) {
            $scope.$apply(function() {
                $scope.nowEvents = data;
            });
        });
    }

    $scope.getLastPost = function() {
        if($rootScope.user.tmid && $rootScope.user.tmid != '')
        request.backend('getLastPost', { tmid: $rootScope.user.tmid }, function(data) {
            $scope.$apply(function() {
                $scope.lastPost = data;
                if (data.length > 0)
                    $scope.isLoadedPost = true;
            });
        });
    }

    function colorpickerTest() {
        var colorInput;
        colorInput = $('<input type="color" value="!" />')[0];
        return colorInput.type === 'color' && colorInput.value !== '!';
    };

    var day = new Date().getDate();
    var month = new Date().getMonth() + 1;
    var monthName;

    switch (month) {
        case 1:
            monthName = 'Stycznia';
            break;
        case 2:
            monthName = 'Lutego';
            break;
        case 3:
            monthName = 'Marca';
            break;
        case 4:
            monthName = 'Kwietnia';
            break;
        case 5:
            monthName = 'Maja';
            break;
        case 6:
            monthName = 'Czerwca';
            break;
        case 7:
            monthName = 'Lipca';
            break;
        case 8:
            monthName = 'Sierpnia';
            break;
        case 9:
            monthName = 'Wrzesnia';
            break;
        case 10:
            monthName = 'Października';
            break;
        case 11:
            monthName = 'Listopada';
            break;
        case 12:
            monthName = 'Grudnia';
            break;
        default:
            "Błędny miesiąc";
    }
    $(".today-date").html(day + " " + monthName);
});
app.controller('compositionController', function($scope, auth, $rootScope, request, notify, statistic) {
    $scope.users = [];
    $scope.notOnField = [];
    $scope.showContent = false;
    $scope.selectedOnFieldId = -1;
    var mainChart = null;


    $scope.getTeam = function() {
        request.backend('getUserFromTeam', { tmid: $rootScope.user.tmid }, function(data) {
            $scope.$apply(function() {
                for (var index = 0; index < data.length; index++) {
                    data[index].isSelected = false;
                    if (data[index].pos_x < 0 || data[index].pos_y < 0) {
                        $scope.notOnField.push(data[index]);
                    } else {
                        $scope.users.push(data[index]);
                    }
                }
            });
            initCanvas();
            setTimeout(function() {
                teamFormChartInit();
            }, 1000);
        });

    }

    $(document).off("change", ".changeNumber");
    $(document).on("change", ".changeNumber", function() {
        var teamMembersId = ($(this).attr('id').split("-"))[1];
        var positionId = ($(this).attr('id').split("-"))[2];
        var changedNumber = $(this).val();
        for (var i = 0; i < $scope.notOnField.length; i++) {
            if ($scope.notOnField[i].tmmid == teamMembersId) {
                var usid = $scope.notOnField[i].usid;
                $scope.$apply(function() {
                    $scope.notOnField[i].nr_on_tshirt = changedNumber;
                    saveComposition('nr_on_tshirt', teamMembersId, changedNumber, usid);
                });
                break;
            }
        }
    })

    function saveComposition(typeOfChange, tmid, value, usid) {
        request.backend('changeCollection', { tmid: tmid, val: value, type: typeOfChange }, function(data) {
            notify.addNew(new notify.Notification("Twój numer na boisku został zmieniony na: " + value, [usid], "#!/teamComposition"));
        });
    }

    function savePositionOnField(usid, pos_x, pos_y, sendAlert = true) {
        request.backend('savePositionOnField', { usid: usid, pos_x: parseInt(pos_x), pos_y: parseInt(pos_y) }, function(data) {
            if (sendAlert) {
                notify.addNew(new notify.Notification("Twoja pozycja na boisku została zmieniona", [usid], "#!/teamComposition"));
            }
        });
    }

    $(document).off('dragstart', '.dragedUser');
    $(document).on('dragstart', '.dragedUser', function(evt) {
        if ($rootScope.user.role == 'ZAWODNIK') {
            return;
        }
        var usid = $(this).attr('id').split('-')[1];

        $rootScope.movedData = usid;
    });

    $(document).off('dragover', '#canvas');
    $(document).on('dragover', '#canvas', function(evt) {
        evt.preventDefault()
    });

    $(document).off('drop', '#canvas');
    $(document).on('drop', '#canvas', function(evt) {
        evt.preventDefault();

        if ($rootScope.user.role == 'ZAWODNIK' || !$rootScope.movedData) {
            return;
        }
        var mousePosOnCanvas = getMousePos(evt);
        var actualWidth = $('#canvas_container').width();
        var percentPosition = {
            x: (mousePosOnCanvas.x / actualWidth) * 100,
            y: (mousePosOnCanvas.y / actualWidth) * 100,
        };
        var usid = $rootScope.movedData;

        for (var i = 0; i < $scope.notOnField.length; i++) {
            if ($scope.notOnField[i].usid == usid) {
                $scope.notOnField[i].pos_x = percentPosition.x;
                $scope.notOnField[i].pos_y = percentPosition.y;
                savePositionOnField($scope.notOnField[i].tmmid, percentPosition.x, percentPosition.y);
                $scope.$apply(function() {
                    $scope.users.push($scope.notOnField[i]);
                    $scope.notOnField.splice(i, 1);
                });
                teamFormChartInit();
                break;
            }
        }
    });

    function checkDistance(Px, Py, Qx, Qy) {
        return Math.sqrt(Math.pow(Px - Qx, 2) + Math.pow(Py - Qy, 2));
    }

    var actualKey = -1;

    $(document).off('mousedown touchstart', '#canvas');
    $(document).on('mousedown touchstart', '#canvas', function(evt) {
        evt.preventDefault();
        if ($rootScope.user.role == 'ZAWODNIK') {
            return;
        }
        var actualWidth = $('#canvas_container').width();
        var actualCircleSize = parseInt(actualWidth * 0.06);
        var mousePos = getMousePos(evt);


        for (var i = $scope.users.length - 1; i >= 0; i--) {
            if (checkDistance(($scope.users[i].pos_x / 100) * actualWidth, ($scope.users[i].pos_y / 100) * actualWidth, mousePos.x, mousePos.y) <= actualCircleSize) {
                $scope.users[i].isSelected = true;
                updateTime = 50;
                actualKey = i;
                break;
            }
        }
    });

    $(document).off('mouseup touchend', '#canvas');
    $(document).on('mouseup touchend', '#canvas', function(evt) {
        evt.preventDefault();
        if ($rootScope.user.role == 'ZAWODNIK') {
            resetSelect();
            return;
        }

        if (actualKey != -1) {
            var mousePosOnCanvas = getMousePos(evt);
            var actualWidth = $('#canvas_container').width();
            var percentPosition = {
                x: (mousePosOnCanvas.x / actualWidth) * 100,
                y: (mousePosOnCanvas.y / actualWidth) * 100,
            };
            $scope.users[actualKey].pos_x = percentPosition.x;
            $scope.users[actualKey].pos_y = percentPosition.y;
            savePositionOnField($scope.users[actualKey].tmmid, $scope.users[actualKey].pos_x, $scope.users[actualKey].pos_y, false);
        }

        resetSelect();
    });

    $(document).off('mouseup touchend', '#notOnFieldCard');
    $(document).on('mouseup touchend', '#notOnFieldCard', function(evt) {
        evt.preventDefault();
        if ($rootScope.user.role == 'ZAWODNIK') {
            resetSelect();
            return;
        }

        if (actualKey != -1) {
            $scope.users[actualKey].pos_x = -1;
            $scope.users[actualKey].pos_y = -1;
            $scope.users[actualKey].isSelected = false;
            savePositionOnField($scope.users[actualKey].tmmid, $scope.users[actualKey].pos_x, $scope.users[actualKey].pos_y, false);
            $scope.notOnField.push($scope.users[actualKey]);
            $scope.users.splice(actualKey, 1);
            teamFormChartInit();
        }

        resetSelect();
    });

    $(document).off('mouseup touchend', 'window');
    $(document).on('mouseup touchend', 'window', function(evt) {
        evt.preventDefault();
        resetSelect();
    });

    $(document).off('mousemove touchmove', 'window');
    $(document).on('mousemove touchmove', 'window', function(event) {
        event.preventDefault();
    });


    function resetSelect() {
        for (var i = $scope.users.length - 1; i >= 0; i--) {
            $scope.users[i].isSelected = false;
        }
        actualKey = -1;
    }

    var updateTime = 50;
    var actualPosMouse = { x: 0, y: 0 };
    var canvas = document.getElementById("canvas");
    var ctx = document.getElementById('canvas').getContext('2d', { alpha: true });

    var backgorund = new Image();
    backgorund.src = './files/img/canvas/background.png';

    var tshirt = new Image();
    tshirt.src = './files/img/canvas/tshirt.png';

    function update() {
        var actualWidth = $('#canvas_container').width();
        canvas.width = actualWidth;
        canvas.height = actualWidth * 0.78;
        var actualCircleSize = parseInt(actualWidth * 0.04);
        var actualFontSize = parseInt(actualWidth * 0.025);

        ctx.drawImage(backgorund, 0, 0, backgorund.width, backgorund.height, 10, 10, actualWidth - 20, (actualWidth * 0.78) - 10);

        for (var i = 0; i < $scope.users.length; i++) {
            var pos;
            if ($scope.users[i].isSelected) {
                pos = actualPosMouse;
            } else {
                pos = {
                    x: ($scope.users[i].pos_x / 100) * actualWidth,
                    y: ($scope.users[i].pos_y / 100) * actualWidth
                }
            }

            var tshirtWidth = actualWidth / 11.0;
            var tshirtHeight = tshirtWidth * 1.2;

            ctx.drawImage(tshirt, 0, 0, tshirt.width, tshirt.height, pos.x - tshirtWidth / 2, pos.y - tshirtHeight * 0.2, tshirtWidth, tshirtHeight);

            ctx.fillStyle = '#fff';
            ctx.textAlign = "center";
            ctx.font = actualFontSize + "px Arial";
            ctx.fillText($scope.users[i].nr_on_tshirt, pos.x, parseInt(pos.y) + actualFontSize * 1.5);
            ctx.fillStyle = '#fff';
            ctx.font = actualFontSize + "px Arial";
            ctx.fillText($scope.users[i].firstname[0] + '. ' + $scope.users[i].lastname, pos.x, (parseInt(pos.y) + actualCircleSize + actualFontSize * 3));
        }
    }

    function checkHelpfulnessInTeam(teamForm) {
        if ($scope.notOnField && $scope.notOnField.length > 0) {

            var userNotOnF = []
            var userOnF = []

            for (var i = 0; i < $scope.users.length; i++) {
                userOnF.push($scope.users[i].usid);
            }
            for (var i = 0; i < $scope.notOnField.length; i++) {
                userNotOnF.push($scope.notOnField[i].usid);
            }

            request.backend('getUsersHelpfulness', {
                    tmid: $rootScope.user.tmid,
                    teamForm: teamForm,
                    matchTeam: userOnF,
                    otherTeam: userNotOnF
                },
                function(data) {
                    $scope.$apply(function() {
                        for (var i = 0; i < $scope.notOnField.length; i++) {
                            $scope.notOnField[i].help = data[i].help;
                        }
                    });
                    prettyFieldHelp();
                });
        }
    }

    function prettyFieldHelp() {
        $('.helpTd').each(function() {
            var actualHelp = $(this).html();
            $(this).css('color', "#ec1800");
            if (actualHelp == 'osiągnięto limit zawodników') return;
            var word = actualHelp.split(' ')[0];
            $(this).css('font-weight', "800");
            $(this).css('font-size', "12px");
            if (word == '+') {
                $(this).css('color', "#34cd33");
            }
        });
    }

    function teamFormChartInit() {

        var matchPersonsId = [];
        for (var i = 0; i < $scope.users.length; i++) {
            matchPersonsId.push($scope.users[i].usid);
        }
        var fullTeamScore = statistic.getTeamForm(matchPersonsId, true);
        if (!mainChart || mainChart == null) {
            mainChart = new Chart($('#teamStat'), {
                type: 'doughnut',
                data: {
                    datasets: [{
                        data: [fullTeamScore, 100 - fullTeamScore],
                        backgroundColor: [
                            '#ec1800',
                            '#4e4e4e'
                        ]
                    }],
                    labels: [
                        'Poziom zawodników na boisku',
                        'Braki do maksimum'
                    ]
                }
            });
        } else {
            mainChart.data.datasets = [{
                data: [fullTeamScore, 100 - fullTeamScore],
                backgroundColor: [
                    '#ec1800',
                    '#4e4e4e'
                ]
            }]
            mainChart.update();
        }

        checkHelpfulnessInTeam(fullTeamScore);
    }

    function initCanvas() {
        if ($scope.lastCanvasInterval) {
            window.clearInterval($scope.lastCanvasInterval);
        }
        $scope.lastCanvasInterval = setInterval(update, updateTime);
        $scope.showContent = true;
    }

    function getMousePos(evt) {
        var rect = canvas.getBoundingClientRect();
        return {
            x: evt.clientX - rect.left,
            y: evt.clientY - rect.top
        };
    }

    $(document).off('mousemove', '#canvas');
    $(document).on('mousemove', '#canvas', function(evt) {
        actualPosMouse = getMousePos(evt);
    });

});
app.controller('paymentController', function($scope, auth, $rootScope, notify, request) {
    $scope.showContent = false;
    $scope.loadHistory = false;
    $scope.selectedUserHistory = [];
    $scope.selectedPayment = [];
    $scope.selectedUser = null;
    $scope.showPay = false;
    $scope.ip = 0;
    $scope.signature = 0;
    $scope.isPayuEnabled = false;
    $scope.merchantPosId = '';
    $scope.merchantKey = '';
    $scope.paymentSummary = [];
    $scope.allCyclPayments = [];
    $scope.paymentDate = '';
    $scope.payDay = '';
    $scope.payWeek = '';
    $scope.payMonth = '';
    $scope.userIsSelected = false;

    $scope.initPaymentSettings = function() {
        getSettings();
    };

    $scope.initPayment = function() {
        getUserFromTeam();
        getSettings();
        $('.datetimepicker').datetimepicker({
            format: 'Y:m:d',
            lang: 'pl',
            timepicker: false,
        });
    };

    $scope.initPaymentHistory = function(){
        getUserFromTeam();
        $scope.getUsersHistory(-1);
    };

    $scope.sendReminder = function(payId){
        request.backend('sendPaymentReminder', { payId: payId }, function(data) {},'Ponaglenie wysłane');
    };

    $scope.initPaymentCyclic = function() {
        request.backend('getAllCyclePayment', { tmid: $rootScope.user.tmid }, function(data) {
            $scope.$apply(function() {
                $scope.allCyclPayments = data;
                $scope.showContent = true;
            });
        });
    };

    $scope.deleteCyclePay = function(id) {
        $rootScope.showModalWindow("Usunięcie płatności", function() {
            request.backend('deleteCyclePayment', { id: id, tmid: $rootScope.user.tmid }, function(data) {
                $scope.initPaymentCyclic();
            }, "Płatność została usunięta");
        });
    };

    $scope.addCyclePay = function() {
        var title = $("#cyclikPayTitle").val();
        var startDate = $("#dataInput").val();
        var amount = parseFloat($("#payValue").val().replace(",", "."));

        if (!startDate || startDate.length <= 0) {
            notify.localNotify("Walidacja", "Wproawdź ilość dni wyprzedzenia");
            return;
        }

        if (title.length <= 3) {
            notify.localNotify("Walidacja", "Wpisz dłuższy tytuł płatności");
            return;
        }

        if (amount.length == 0 || amount == 0 || amount <= 0.00) {
            notify.localNotify("Walidacja", "Wprowadź poprawnie kwotę płatności");
            return;
        }

        if ($scope.payDay != null && $scope.payDay != '' && $scope.payDay >= 0 && $scope.payDay <= 23 ) {
            var interval = $scope.payDay;
            var intervalName = "dzień";
        } else if ($scope.payWeek != null && $scope.payWeek != '' && $scope.payWeek >= 0 && $scope.payWeek <= 6) {
            var interval = $scope.payWeek;
            var intervalName = "tydzień";
        } else if ($scope.payMonth != null && $scope.payMonth != '' && $scope.payMonth >= 1 && $scope.payMonth <= 31) {
            var interval = $scope.payMonth;
            var intervalName = "miesiąc";
        } else {
            notify.localNotify("Walidacja", "Podaj poprawny odstęp czasowy");
            return;
        }

        request.backend('addCyclePayment', { tmid: $rootScope.user.tmid, title: title, howLongBefore: startDate, interval: interval, intervalName: intervalName, amount: amount }, function(data) {
            $scope.initPaymentCyclic();
        }, "Płatność została dodana");
    }

    $scope.getPaymentSummary = function() {
        if ($rootScope.user.tmid == '' || $rootScope.user.role == 'ZAWODNIK') return;

        request.backend('getPaymentSummary', { tmid: $rootScope.user.tmid }, function(data) {
            $scope.$apply(function() {
                $scope.paymentSummary = data;
            });
        });
    }

    $scope.initPaymentClient = function() {
        request.backend('getClientIp', { tmid: $rootScope.user.tmid, usids: [$rootScope.user.id] }, function(data) {
            $scope.$apply(function() {
                $scope.ip = data;
            });
        });
        $scope.host = window.location.protocol + "//" + window.location.hostname;

        $scope.getUsersHistory($rootScope.user.id);
        getSettings();
    };

    function getSettings() {
        request.backend('getPaymentOptions', {}, function(data) {
            $scope.$apply(function() {
                $scope.merchantPosId = data.merchantPosId;
                $scope.merchantKey = data.merchantKey;
                $scope.isPayuEnabled = data.availablePaymentPayu == "false" ? false : true;
                if ($scope.isPayuEnabled) $('#turnOffOnPayu').prop('checked', true);
                else $('#turnOffOnPayu').prop('checked', false);
                $scope.showContent = true;
                setTimeout(function() {
                    Materialize.updateTextFields();
                    $('select').material_select();
                    $('ul.tabs').tabs();
                    $('.collapsible').collapsible();
                }, 500);
            });
        });
    }

    $(document).off('change', '#turnOffOnPayu');
    $(document).on("change", "#turnOffOnPayu", function() {
        request.backend('turnOffOnPayuPay', { payStatus: $("#turnOffOnPayu").is(':checked') }, function(data) {
            $scope.$apply(function() {
                $scope.isPayuEnabled = $("#turnOffOnPayu").is(':checked');
            });
        }, "Płatności Payu ustawione pomyślnie");
    })

    $scope.showPayment = function(index) {
        $scope.selectedPayment = $scope.selectedUserHistory[index];
        if ($scope.selectedPayment) {
            $scope.showPay = true;
            $scope.getSignatureVerify();
        }
    };

    $scope.payWithPayu = function() {
        request.backend('payWithPayu', { pmid: $scope.selectedPayment.id }, function(data) {
            request.backend('getUserPaymentHistory', { tmid: $rootScope.user.tmid, usids: $rootScope.user.id }, function(data) {
                $scope.$apply(function() {
                    $scope.selectedUserHistory = data[0] ? data[0] : [];
                    $scope.showContent = true;
                });
            });
        });
    };

    $scope.getSignatureVerify = function() {
        var sigData = new Object();
        sigData["customerIp"] = $scope.ip;
        sigData["merchantPosId"] = $scope.merchantPosId;
        sigData["extOrderId"] = $scope.selectedPayment.id;
        sigData["description"] = $scope.selectedPayment.name;
        sigData["totalAmount"] = $scope.selectedPayment.amount * 100;
        sigData["currencyCode"] = "PLN";
        sigData["products.name"] = $scope.selectedPayment.name;
        sigData["products.unitPrice"] = $scope.selectedPayment.amount * 100;
        sigData["products.quantity"] = "1";
        sigData["products.virtual"] = "true";
        sigData["buyer.email"] = $rootScope.user.email;
        sigData["buyer.firstName"] = $rootScope.user.firstname;
        sigData["buyer.lastName"] = $rootScope.user.lastname;
        sigData["buyer.language"] = "pl";
        sigData["notifyUrl"] = $scope.host + '/backend/paymentNotification';
        sigData["continueUrl"] = $scope.host;
        request.backend('getPaySignature', { sigData: sigData, posId: $scope.merchantPosId, merchantKey: $scope.merchantKey }, function(data) {
            $scope.$apply(function() {
                $scope.signature = data;
            });
        });
    };

    $scope.sendPayment = function() {
        var paymentName = $("#payName").val();
        if (paymentName.length < 3) {
            notify.localNotify("Walidacja", "Zbyt krótki tytuł płatności");
            return;
        }
        var paymentAmount = parseFloat($("#payAmount").val().replace(",", ".")).toFixed(2);
        if (!$.isNumeric(paymentAmount) || paymentAmount <= 0) {
            notify.localNotify("Walidacja", "Błędna kwota");
            return;
        }
        var selectedUserAmount = $('.userSelectInput:checked').length;
        if (selectedUserAmount <= 0) {
            notify.localNotify("Walidacja", "Zaznacz przynajmniej jedną osobę");
            return;
        }

        if ( !$scope.paymentDate || $scope.paymentDate.length < 5) {
            notify.localNotify("Walidacja", "Wprowadź datę płatnośći");
            return;
        }
        var selectedUserId = [];
        $('.userSelectInput:checked').each(function() {
            selectedUserId.push($(this).attr("id").split("-")[1]);
        });
        request.backend('addPaymentToUser', { date_to_pay:$scope.paymentDate, tmid: $rootScope.user.tmid, userIds: selectedUserId, amount: paymentAmount, name: paymentName }, function(data) {
            notify.addNew(new notify.Notification("Nowe płatność. Tytuł: " + paymentName + " Kwota: " + paymentAmount + " zł", selectedUserId, "#!/clientPayment"));
        }, "Pomyślnie dodano płatnośc do kont użytkowników oraz wysłano powiadomienie");
    };

    $scope.getUsersHistory = function(usid) {
        request.backend('getUserPaymentHistory', { tmid: $rootScope.user.tmid, usids: usid }, function(data) {
            $scope.$apply(function() {
                $scope.showContent = true;
                $scope.selectedUserHistory = data.data ? data.data : [];
                let mainChart = new Chart($('#userPaymentStat'), {
                    type: 'doughnut',
                    data: {
                        datasets: [{
                            data: [data.payed, data.notPayed, data.delayed],
                            backgroundColor: [
                                '#89c33e',
                                '#4e4e4e',
                                '#ec5536',
                            ]
                        }],
                        labels: [
                            'Rozliczone',
                            'Nierozliczone',
                            'Opóźnione'
                        ]
                    }
                });
                setTimeout(function(){
                    $(".paymentDateToPay").each(function(){
                        let toPayDate = $(this).text();
                        if($scope.checkIsBefore(toPayDate)) $(this).css('color','#d01d1d');
                    });

                    $(".paymentStatus").each(function(){
                        let status = $(this).text();
                        if(status == "Zakończono") $(this).css('color','#82ce2a');
                        else if(status == "Do zapłaty") $(this).css('color','#d2a10f');
                        else $(this).css('color','#40403e');
                    });

                    $('.tooltipped').tooltip({delay: 50});
                },50);
            });
        });
    };

    $scope.checkIsBefore = function(date){
        return moment(date).isBefore(moment());
    };

    $scope.deletePayment = function(id) {
        $rootScope.showModalWindow("Usunięcie płatności", function() {
            request.backend('deletePayment', { pmid: id }, function(data) {
                $scope.getUsersHistory($('#selectUserToGetHistory').val());
            }, "Pomyślnie usunięto płatność");
        });
    };

    $scope.endPayment = function(id) {
        request.backend('endPayment', { pmid: id }, function(data) {
            $scope.getUsersHistory($('#selectUserToGetHistory').val());
        }, "Zakończono płatność");
    };

    function getUserFromTeam() {
        request.backend('getUserFromTeam', { tmid: $rootScope.user.tmid }, function(data) {
            $scope.$apply(function() {
                $scope.allUsers = data;
                setTimeout(function() {
                    $scope.showContent = true;
                    Materialize.updateTextFields();
                    $('select').material_select();
                    $('ul.tabs').tabs();
                    $('.collapsible').collapsible();
                }, 200);
            });
        });
    }

    $(document).off('change', '#selectUserToGetHistory');
    $(document).on("change", "#selectUserToGetHistory", function() {
        let value = parseInt($('#selectUserToGetHistory').val());
        $scope.getUsersHistory(value);
        $scope.$apply(function(){
            $scope.userIsSelected = value >= 0 ;
        });
    });

    $(document).off('change', '.payOption');
    $(document).on("change", ".payOption", function() {
        request.backend('editOptions', { posId: $("#posId").val(), merKey: $("#merKey").val() }, function(data) {
            getSettings();
        }, "Pomyslnie zmieniono dane payu");
    });

});
app.controller('mySkillTreeController', function($scope, auth, $rootScope, notify, request) {
    $scope.showContent = false;
    $scope.mySkills = [];

    var resizeTimeout = null;

    $rootScope.treeConfig = {
        chart: {
            container: "#skillTree",
            levelSeparation: 45,
            rootOrientation: "WEST",
            nodeAlign: "CENTER",
            connectors: {
                type: "curve",
                style: {
                    "stroke-width": 3,
                    "stroke": "#adadad"
                }
            }
        },
        nodeStructure: {
            HTMLclass: "skillTreeRootElement",
            children: [],
            connectors: {
                type: "step",
                style: {
                    "stroke": "#ffffff",
                    "stroke-opacity": 0
                }
            }
        }
    };

    $(document).off('click',".sidebar-toggle-box");
    $(document).on('click',".sidebar-toggle-box",function(){
        $('#skillTree').html('');
        new Treant($rootScope.treeConfig, function() {
            replaceImgBySvg();
            $('.tooltipped').tooltip({
                delay: 20
            });
        });
        $('.modal').modal();
    });

    $scope.loadSkill = function() {
        request.backend('getMySkillsInTree', {}, function(data) {
            $scope.$apply(function() {
                $scope.mySkills = data;
                for (let i = 0; i < data.struct.length; i++) {
                    $rootScope.treeConfig.nodeStructure.children.push(createElementRoot(data.struct[i]));
                }
                $scope.showContent = true;
                setTimeout(() => {
                    new Treant($rootScope.treeConfig, function() {
                        replaceImgBySvg();
                        $('.tooltipped').tooltip({
                            delay: 20
                        });
                    });
                    $('.modal').modal();
                }, 500);
            });
        });
    }

    $(window).resize(function(){
        $('#skillTree').html('');
        clearTimeout(resizeTimeout);
        $scope.$apply(function(){
            $scope.showContent = false;
        });
        resizeTimeout = setTimeout(() => {
            $scope.$apply(function(){
                $scope.showContent = true;
            });
            setTimeout(() => {
                new Treant($rootScope.treeConfig, function() {
                    replaceImgBySvg();
                    $('.tooltipped').tooltip({
                        delay: 20
                    });
                });
                $('.modal').modal();
            }, 500);
        }, 1000);
    });

    function createElementRoot(data) {
        var rootElement = {
            text: { name: data.name },
            HTMLclass: "skillRootElement",
            children: [],
            connectors: {
                style: {
                    "stroke": data.color
                }
            }
        };
        if (data.skills)
            createSkillElements(rootElement.children, data.skills, data.color);
        return rootElement;
    }

    function createSkillElements(pushElement, skills, parentColor) {
        for (let i = 0; i < skills.length; i++) {
            var skill = {
                innerHTML: getIconHtml(skills[i]),
                HTMLclass: "skillParent",
                children: [],
                connectors: {
                    style: {
                        "stroke": skills[i].isComplete ? parentColor : "#b3b3b3"
                    }
                }
            };
            if (skills[i].skills)
                createSkillElements(skill.children, skills[i].skills, parentColor);
            pushElement.push(skill);
        }
    }

    $(document).off('click',".skillIn");
    $(document).on('click',".skillIn",function(){
        var skill = getSkillById($(this).data('skill-id'));
        if( !skill ){return;}
        loadSkillToModal(skill);
    });

    $(document).off('click',".popReqListElement");
    $(document).on('click',".popReqListElement",function(){
        var skill = getSkillById($(this).data('skill-id'));
        if( !skill ){return;}
        loadSkillToModal(skill);
    });


    function loadSkillToModal(skill){
        var mo = $('#skillModal');
        clearPop();
        mo.modal('open');
        var level = parseInt(skill.level) > 0 ? " - poziom: "+skill.level : "" ;
        mo.find('.popMainSkill').first().prepend(getIconHtml(skill));
        mo.find('.popMainSkill .popSkillMainStatus').first().html(getStatusHtml(skill));
        mo.find('.popMainSkill .popSkillMainCat').first().text(skill.category.name);
        mo.find('.popMainSkill .popSkillMainName').first().text(skill.name+level);
        mo.find('.popMainSkill .popSkillMainDesc').first().text(skill.description);

        if(skill.reqs.length == 0){
            mo.find('.popReqList').first().append("<li class='noReg'>Brak wymagań</li>");
        }

        for (let i = 0; i < skill.reqs.length; i++) {
            var level = parseInt(skill.reqs[i].level) > 0 ? " - poziom: "+skill.reqs[i].level : "" ;
            mo.find('.popReqList').first().append(`
            <li class='popReqListElement' data-skill-id='`+skill.reqs[i].id+`'>
                <div class='popReqListElementLeft'>
                `+getIconHtml(skill.reqs[i])+`
                </div>
                <div class='popReqListElementRight'>
                    <h4 class='popSkillMainCat'>`+skill.reqs[i].category.name+`</h4>
                    <h6 class='popSkillMainName'>`+skill.reqs[i].name+level+`</h6>
                    <small class='popSkillMainStatus'>`+getStatusHtml(skill.reqs[i])+`</small>
                </div>
            </li>
            `);
        }
        replaceImgBySvg();
    }

    function clearPop(){
        var mo = $('#skillModal');
        mo.find('.popMainSkill').first().html(`
            <div class='popMainSkill'>
                <small class='popSkillMainStatus'></small>
                <h4 class='popSkillMainCat'></h4>
                <h6 class='popSkillMainName'></h6>
                <p class='popSkillMainDesc'></p>
            </div>
        `);

        mo.find('.popReqSkill').first().html(`
            <h4 class='popReq'>Wymagania:</h4>
            <ul class='popReqList'></ul>
        `);
    }

    function getIconHtml(skill){
        var level = parseInt(skill.level);
        var parentColor = skill.category.color;
        var classIn = skill.isComplete ? "completedSkill" : skill.isEnabled ? "enabledSkill" : "notEnabledSkill";
        var fillColor = skill.isComplete ? "white" : skill.isEnabled ? 'black' : "#adadad";
        var borderColor = skill.isComplete ? parentColor : skill.isEnabled ? parentColor : "#adadad";
        var background = skill.isComplete ? parentColor : skill.isEnabled ? "white" : "#e7e7e7";
        var levelColor = skill.isEnabled ? parentColor  : "#adadad";
        var spanWithLevel = `<span class='levelSpan' style='background-color:`+levelColor+`'>`+level+`</span>`;
        var classType = skill.isComplete ? "completePathSvg" : skill.isEnabled ? "enabledPathSvg" : "notEnabledPathSvg";

        return `<div data-skill-id='`+skill.id+`' class='skillIn tooltipped ` + classIn + `' style='background-color:`+background+`;border-color:`+borderColor+`' data-position='bottom data-delay='20' data-tooltip='` + skill.name + `'>
            <img class='svg `+classType+`' style='fill:`+fillColor+` !important; stroke:`+fillColor+` !important' src='` + skill.icon_path + `' alt='` + skill.name + `'/>
            `+(level > 0 ? spanWithLevel : '')+`</div>`;
    }

    function getStatusHtml(skill){
        var status = '';
        if(skill.isComplete) status = '<span style="color:#8AC163" >Zaliczone</span>';
        else if(skill.isEnabled) status = '<span style="color:#D5B75D" >Do zaliczenia</span>';
        else status = '<span style="color:#D1D1D1" >Niedostępne</span>';
        return status;
    }


    function getSkillById($id,$load=true){
        for (let i = 0; i <  $scope.mySkills.all.length; i++) {
            if($scope.mySkills.all[i].id == $id){
                var element = $.extend(true, {}, $scope.mySkills.all[i]);
                if($load){
                    var req = loadSkillFromReq($scope.mySkills.all[i]);
                    element.reqs = req;
                }
                return element;
            }
        }
        return null;
    }

    function loadSkillFromReq(skill){
        var allReq = [];
        if(skill.req)
        for (let i = 0; i < skill.req.length; i++) {
            var all = getSkillById(skill.req[i],false);
            allReq.push( all );
        }
        return allReq;
    }

    function replaceImgBySvg() {
        $('img.svg').each(function() {
            var $img = $(this);
            var imgID = $img.attr('id');
            var imgClass = $img.attr('class');
            var imgURL = $img.attr('src');
            var imgStyle = $img.attr('style');

            $.get(imgURL, function(data) {
                // Get the SVG tag, ignore the rest
                var $svg = $(data).find('svg');
                // Add replaced image's ID to the new SVG
                if (typeof imgID !== 'undefined') {
                    $svg = $svg.attr('id', imgID);
                }
                // Add replaced image's classes to the new SVG
                if (typeof imgClass !== 'undefined') {
                    $svg = $svg.attr('class', imgClass + ' replaced-svg');
                }

                if (typeof imgStyle !== 'undefined') {
                    $svg = $svg.attr('style', imgStyle );
                }
                // Remove any invalid XML tags as per http://validator.w3.org
                $svg = $svg.removeAttr('xmlns:a');
                // Check if the viewport is set, if the viewport is not set the SVG wont't scale.
                if (!$svg.attr('viewBox') && $svg.attr('height') && $svg.attr('width')) {
                    $svg.attr('viewBox', '0 0 ' + $svg.attr('height') + ' ' + $svg.attr('width'))
                }
                // Replace image with new SVG
                $img.replaceWith($svg);
            }, 'xml');
        });
    }



});
app.controller('skillTreeListController', function($scope, auth, $rootScope, notify, request) {
    $scope.showContent = false;
    $scope.skillTreeCategories = [];
    $scope.skillTreeSkills = [];

    var updatedId = 0;
    $scope.isUpdate = false;

    $scope.loadSkillTreeData = function(){
        request.backend('getSkillTreeData', {}, function(data) {
            $scope.$apply(function() {
                $scope.skillTreeCategories = data.categories;
                $scope.skillTreeSkills = data.skills;
                $scope.showContent = true;
            });
        });
    }
    
    $scope.openAddCategoryModal = function(){
       $("#addCategoryModal").modal('open');
       setTimeout(function(){
            $('#categoryColorForm').parent().parent().colorpicker({
                component: '.btn'
            });
        },200);
    }

    $scope.addCategory = function(){
        $("#addCategoryModal").modal('close');
        var name = $("#categoryNameForm").val();
        var color = $("#categoryColorForm").val();
        $("#categoryNameForm").val('');
        $("#categoryColorForm").val('');
        request.backend('addCategorySkillTree', {name: name, color: color}, function(data) {
            $scope.$apply(function() {
                $scope.skillTreeCategories.push({
                    id: data,
                    name: name,
                    color: color
                });
            });
            notify.localNotify("Sukces","Pomyślnie dodano kategorię");
        });
    }

    $scope.editCategoryModal = function(category){
        $("#addCategoryModal").modal('open');
        updatedId = category.id;
        $scope.isUpdate = true;
        $("#categoryNameForm").val(category.name);
        $("#categoryColorForm").val(category.color);

        setTimeout(function(){
            $('#categoryColorForm').parent().parent().colorpicker({
                component: '.btn',
                format: 'hex',
                color: category.color
            });
            $('#categoryColorForm').parent().parent().colorpicker('setValue',category.color);
        },200);
    }


    $scope.deleteCategory = function(){
        $("#addCategoryModal").modal('close');
        $("#categoryNameForm").val('');
        $("#categoryColorForm").val('');
        $scope.isUpdate = false;

        $rootScope.showModalWindow("Usunięcie kategorii w skilltree",function(){
            request.backend('deleteCategorySkillTree', {id: updatedId}, function(data) {
                $scope.$apply(function() {
                    for(let i=0;i<$scope.skillTreeCategories.length;i++){
                        if($scope.skillTreeCategories[i].id == updatedId){
                            $scope.skillTreeCategories.splice(i,1);
                            break;
                        }
                    }
                    updatedId = 0;
                });
                notify.localNotify("Sukces","Pomyślnie usunięto kategorię");
            });
        });
    }

    $scope.closeModals = function(){
        $("#addCategoryModal").modal('close');
        $("#addSkillModal").modal('close');
        $("#skillNameForm").val('');
        $("#skillAboutForm").val('');
        $("#skillLevelForm").val('0');
        $("#skillFile").val('');
        $("#skillTreeSkillRootSelect").val('');
        $("#skillTreeReqSelect").val('');
        $("#skillTreeCatSelect").val('');
        updatedId = 0;
        $scope.isUpdate = false;
    }

    $scope.saveCategory = function(){
        $("#addCategoryModal").modal('close');
        var name = $("#categoryNameForm").val();
        var color = $("#categoryColorForm").val();
        $("#categoryNameForm").val('');
        $("#categoryColorForm").val('');
        request.backend('saveCategorySkillTree', {id:updatedId, name: name, color: color}, function(data) {
            $scope.$apply(function() {
                for(let i=0;i<$scope.skillTreeCategories.length;i++){
                    if($scope.skillTreeCategories[i].id == updatedId){
                        $scope.skillTreeCategories[i].name = name;
                        $scope.skillTreeCategories[i].color = color;
                        break;
                    }
                }
                updatedId = 0;
            });
            notify.localNotify("Sukces","Pomyślnie zapisano zmiany");
        });
        $scope.isUpdate = false;
    }

    
    $(document).off('change',"#skillTreeCatSelect");
    $(document).on('change',"#skillTreeCatSelect",function(){
        var id = $(this).val();
        $("#skillTreeSkillRootSelect").html('');
        $("#skillTreeSkillRootSelect").append('<option value="" disabled selected>Wybierz umiejętność</option>');
        for(let i=0;i<$scope.skillTreeSkills.length;i++){
            if($scope.skillTreeSkills[i].category_id == id){
                var level = parseInt($scope.skillTreeSkills[i].level);
                var name = level > 0 ?$scope.skillTreeSkills[i].name + " - poziom: "+$scope.skillTreeSkills[i].level : $scope.skillTreeSkills[i].name;
                $("#skillTreeSkillRootSelect").append('<option value="'+$scope.skillTreeSkills[i].id+'"  >'+name+'</option>');
              }
        }
        $('#skillTreeSkillRootSelect').material_select();
    });

    $scope.openAddSkillModal = function(){
        $("#addSkillModal").modal('open');
        $("#skillTreeCatSelect").html('');
        $("#skillTreeCatSelect").append('<option value="" disabled selected>Wybierz kategorię umiejętności</option>');
        for(let i=0;i<$scope.skillTreeCategories.length;i++){
           
            $("#skillTreeCatSelect").append('<option value="'+$scope.skillTreeCategories[i].id+'"  >'+$scope.skillTreeCategories[i].name+'</option>');
        }

        $("#skillTreeReqSelect").html('');
        $("#skillTreeReqSelect").append('<option value="" disabled selected>Wybierz dodatkowe zależności</option>');
        $("#skillTreeSkillRootSelect").html('');
        $("#skillTreeSkillRootSelect").append('<option value="" disabled selected>Wybierz najpierw kategorie</option>');
        for(let i=0;i<$scope.skillTreeSkills.length;i++){
            var level = parseInt($scope.skillTreeSkills[i].level);
            var name = level > 0 ?$scope.skillTreeSkills[i].name + " - poziom: "+$scope.skillTreeSkills[i].level : $scope.skillTreeSkills[i].name;
            $("#skillTreeReqSelect").append('<option value="'+$scope.skillTreeSkills[i].id+'"  >'+name+'</option>');
        }
        
        $('select').material_select();
    }

    $scope.editSkill = function(){
        $("#addSkillModal").modal('close');
        $("#SkillUpdateIdForm").val(updatedId);
        if(validateSkillForm()){
            let dataToSend = new FormData($("#SkillTreeSkillForm")[0]);
            request.backend('saveSkillInTree', dataToSend, function(data) {
                $scope.$apply(function() {
                    $scope.skillTreeSkills = data;
                });
            },"Umiejętność zapisana",true);
        }
        $("#skillNameForm").val('');
        $("#skillAboutForm").val('');
        $("#skillLevelForm").val('0');
        $("#skillFile").val('');
        $("#skillTreeSkillRootSelect").val('');
        $("#skillTreeReqSelect").val('');
        $("#skillTreeCatSelect").val('');
        $scope.isUpdate = false;
    }

    $scope.editSkillModal = function(element){
        
        $("#addSkillModal").modal('open');
        $("#skillFile").val('');
        $scope.isUpdate = true;
        updatedId = element.id;

        request.backend('getSkillToEdit', {id: updatedId}, function(skillThis) {
            $("#skillTreeCatSelect").html('');
            $("#skillTreeCatSelect").append('<option value="" disabled >Wybierz kategorię umiejętności</option>');
            for(let i=0;i<$scope.skillTreeCategories.length;i++){
                var isThis = $scope.skillTreeCategories[i].id == skillThis.category_id;
                $("#skillTreeCatSelect").append('<option '+(isThis?"selected":"")+' value="'+$scope.skillTreeCategories[i].id+'"  >'+$scope.skillTreeCategories[i].name+'</option>');
            }
            $("#skillTreeReqSelect").html('');
            $("#skillTreeReqSelect").append('<option value="" disabled >Wybierz dodatkowe zależności</option>');
            $("#skillTreeSkillRootSelect").html('');
            $("#skillTreeSkillRootSelect").append('<option value="" disabled >Wybierz umiejętność</option>');
            for(let i=0;i<$scope.skillTreeSkills.length;i++){
                var isInSkillArray = checkSkillReqIs($scope.skillTreeSkills[i].id,skillThis.req);
                var level = parseInt($scope.skillTreeSkills[i].level);
                var name = level > 0 ?$scope.skillTreeSkills[i].name + " - poziom: "+$scope.skillTreeSkills[i].level : $scope.skillTreeSkills[i].name;
                $("#skillTreeReqSelect").append('<option '+(isInSkillArray?"selected":"")+' value="'+$scope.skillTreeSkills[i].id+'"  >'+name+'</option>');
                if($scope.skillTreeSkills[i].category_id == skillThis.category_id){
                    var isThisRoot = $scope.skillTreeSkills[i].id == skillThis.root_skill_id;
                    $("#skillTreeSkillRootSelect").append('<option '+(isThisRoot?"selected":"")+' value="'+$scope.skillTreeSkills[i].id+'"  >'+name+'</option>');
                }
            }
            $scope.rootSkill = parseInt(skillThis.root_skill_id) <= 0;
            $('select').material_select();
        });


        $("#skillNameForm").val(element.name);
        $("#skillAboutForm").val(element.description);
        $("#skillLevelForm").val(element.level);
    }

    function checkSkillReqIs(id,array){
        if(!array) return false;
        if(array.length <= 0 ) return false;
        for(let i=0;i<array.length;i++){
            if(array[i] == id){
                return true;
            }
        }
        return false;
    }

    $scope.deleteSkill = function(){
        $("#skillNameForm").val('');
        $("#skillAboutForm").val('');
        $("#skillLevelForm").val('0');
        $("#skillFile").val('');
        $("#skillTreeSkillRootSelect").val('');
        $("#skillTreeReqSelect").val('');
        $("#skillTreeCatSelect").val('');
        $scope.isUpdate = false;

        $rootScope.showModalWindow("Usunięcie umiejętności w skilltree",function(){
            request.backend('deleteSkillInTree', {id: updatedId}, function(data) {
                $scope.$apply(function() {
                    for(let i=0;i<$scope.skillTreeSkills.length;i++){
                        if($scope.skillTreeSkills[i].id == updatedId){
                            $scope.skillTreeSkills.splice(i,1);
                            break;
                        }
                    }
                    updatedId = 0;
                });
                notify.localNotify("Sukces","Pomyślnie usunięto umiejętność");
            });
        });
    }

    $scope.addSkill = function(){
        $("#addSkillModal").modal('close');
        if(validateSkillForm()){
            let dataToSend = new FormData($("#SkillTreeSkillForm")[0]);
            request.backend('addSkillTreeSkill', dataToSend, function(data) {
                $scope.$apply(function() {
                    $scope.skillTreeSkills = data;
                });
            },"Umiejętność dodana",true);
        }
        $("#skillNameForm").val('');
        $("#skillAboutForm").val('');
        $("#skillLevelForm").val('0');
        $("#skillFile").val('');
        $("#skillTreeSkillRootSelect").val('');
        $("#skillTreeReqSelect").val('');
        $("#skillTreeCatSelect").val('');
    }

    function validateSkillForm(){
        var name = $("#skillNameForm").val();
        var about = $("#skillAboutForm").val();
        var level = $("#skillLevelForm").val();
        var isRootElement = $("#isRootSkill").val() == "on" ? true : false;
        var skillRoot = $("#skillTreeSkillRootSelect").val();
        var req = $("#skillTreeReqSelect").val();
        var category = $("#skillTreeCatSelect").val();
        var file = $("#skillFile").val();

        var error = false;
        error = validateMustBe(name);
        if(!error) error = validateMustBe(about);
        if(!error) error = validateMustBe(level);
        if(!error) error = validateMustBe(category);
        if(!$scope.isUpdate){if(!error) error = validateMustBe(file);}
        if(!isRootElement){
            if(!error) error = validateMustBe(skillRoot);
        }
        if(error) return false;
        return true;
    }

    function validateMustBe(element){
        if(!element || element == null ){
            notify.localNotify("Walidacja","Nie wszystkie pola zostały odpowiednio wypełnione")
            return true;
        }
        return false;
    }
});
app.controller('userSkillTreeController', function($scope, auth, $rootScope, notify, request) {
    $scope.showContent = false;
    $scope.availableSkill = [];
    $scope.userSelected = false;
    $scope.skillLoaded = false;
    $scope.userIdNow = 0;

    $scope.loadUserFromTeam = function() {
        request.backend('getUserFromTeam', { tmid: $rootScope.user.tmid }, function(data) {
            $('#userSelect').html('');
            $('#userSelect').append("<option value='' disabled selected>Wybierz zawodnika</option>");
            for (var j = 0; j < data.length; j++) {
                $('#userSelect').append("<option value='" + data[j].usid + "'>" + data[j].firstname + ' ' + data[j].lastname + "</option>");
            }
            $('select').material_select();
            $scope.showContent = true;
        });
    }

    $(document).off("change", "#userSelect");
    $(document).on("change", "#userSelect", function() {
        let userId = $(this).val();
        $scope.userIdNow = userId;
        $scope.userSelected = true;
        $scope.skillLoaded = false;
        request.backend('getUserAvailableSkill', { usid: userId }, function(data) {
            $scope.$apply(function() {
                $scope.availableSkill = data;
                $scope.skillLoaded = true;
            });
        });
    });

    $(document).off("change", ".selectSkillStatus");
    $(document).on("change", ".selectSkillStatus", function() {
        let skillStatus = $(this).val();
        let skillId = $(this).attr('id').split("-")[1];
        if ($("#" + $(this).attr('id')).first().is(':checked')) {
            $scope.userSelected = true;
            $scope.skillLoaded = false;
            request.backend('completeUserSkillTreeSkill', { usid: $scope.userIdNow, sid: skillId }, function(data) {
                $scope.$apply(function() {
                    $scope.availableSkill = data;
                    $scope.skillLoaded = true;
                });
            }, "Status umiejętności zmieniony na: zdana");
        } else {
            $scope.userSelected = true;
            $scope.skillLoaded = false;
            request.backend('uncompleteUserSkillTreeSkill', { usid: $scope.userIdNow, sid: skillId }, function(data) {
                $scope.$apply(function() {
                    $scope.availableSkill = data;
                    $scope.skillLoaded = true;
                });
            }, "Status umiejętności zmieniony");
        }
    });

});
app.controller('myStatsController', function($scope, auth, $rootScope, notify, statistic, request) {
    $rootScope.showContent = false;
    $scope.showPreLoad = true;
    $rootScope.actualStats = [];
    $scope.acutalSelectedGroup = 0;
    $scope.acutalSelectedGroupTest = []
    $scope.dataViewAsTable = true;
    $(document).ready(function() {
        var wSize = $(window).width();
        if (wSize <= 768) {
            $(".adw").each(function() {
                $(this).removeClass("adwWith");
                $(this).addClass("adwWithout");
            });
        } else {
            $(".adw").each(function() {
                $(this).removeClass("adwWithout");
                $(this).addClass("adwWith");
            });
        }
    });
    $scope.initMyStats = function() {
        request.backend('getStats', { usid: $rootScope.user.id, tmid: $rootScope.user.tmid }, function(data) {
            $scope.$apply(function() {
                $scope.showContent = true;
                $rootScope.actualStats = data.potential;
                $scope.userForm = data.form
            });
            $('#selectPotential').html('');
            $('#selectPotential').append("<option value='' disabled selected>Grupy testowe</option>");
            if ($rootScope.actualStats) {
                for (var i = 0; i < $rootScope.actualStats.length; i++) {
                    $('#selectPotential').append("<option value='" + i + "'>" + $rootScope.actualStats[i].name + "</option>");
                }
            }
            $('select').material_select();
            $scope.showTestAndType = true;
            $rootScope.showContent = true;
            initMainSummary();
            initMainSummaryRadar();
            checkTableScoreProgress();
        });
    }

    function initMainSummary() {
        if ($scope.acutalSelectedGroupTest) {
            var chart = new Chart($('#main-summary-chart'), {
                type: 'doughnut',
                data: {
                    datasets: [{
                        data: [$scope.userForm, 100 - $scope.userForm],
                        backgroundColor: [
                            '#ec1800',
                            '#4e4e4e'
                        ]
                    }],
                    labels: [
                        'Aktualna forma',
                        'Braki do maksimum'
                    ]
                },
                options: {
                    tooltips: {
                        callbacks: {
                            afterLabel: (item)=>{ return `%`},
                        }
                    },
                }
            });
        }
    }

    function initMainSummaryRadar() {
        var label = [];
        var dataSe = [];
        for (var i = 0; i < $rootScope.actualStats.length; i++) {
            label.push($rootScope.actualStats[i].name);
            dataSe.push($rootScope.actualStats[i].summary);
        }
        var chart = new Chart($('#main-summary-chart-radar'), {
            type: 'radar',
            data: {
                datasets: [{
                    label: "Wyniki w poszczególnych kategoriach",
                    data: dataSe,
                    backgroundColor: 'rgba(236, 24, 0, 0.2)',
                    borderColor: '#ec1800',
                }],
                labels: label,
            },
            options: {
                legend: {
                    position: 'top',
                },
                scale: {
                    ticks: {
                        beginAtZero: true
                    }
                },
                tooltips: {
                    callbacks: {
                        afterLabel: (item)=>{ return `%`},
                    }
                },
            }
        });
    }

    function checkTableScoreProgress() {
        $('.statTable tbody').each(function() {
            var allTr = $(this).find('tr');
            for (var i = 0; i < allTr.length - 1; i++) {
                var actual = parseFloat($(this).find('tr').eq(i).find('td').eq(0).html());
                var before = parseFloat($(this).find('tr').eq(i + 1).find('td').eq(0).html());
                var progress = actual - before;
                if (progress == 0) continue;
                var word = progress > 0 ? "+" : "-";
                progress = Math.abs(progress);
                progress = progress.toFixed(2);
                $(this).find('tr').eq(i).find('td').eq(0).append("<span class='" + (word == '+' ? "tableProgressElementPositive" : "tableProgressElementNegative") + "'> " + word + " " + progress + "</span>");
            }
        });
    }

    $(document).off('click', '.optionsToShow');
    $(document).on('click', '.optionsToShow', function() {
        $scope.initChart();
    });

    $(document).off('change', '#selectPotential');
    $(document).on('change', '#selectPotential', function() {
        $scope.showPreLoad = false;
        $scope.$apply(function() {
            $scope.acutalSelectedGroup = $("#selectPotential").val();
            $scope.acutalSelectedGroupTest = $rootScope.actualStats[$scope.acutalSelectedGroup].tests;
        })
        $('.collapsible').collapsible();
        $scope.initChart();
        setTimeout(function() {
            initPercentChart();
            initMainSummary();
            checkTableScoreProgress();
        }, 50);

    });

    $(document).off('change', '#selectDataType');
    $(document).on('change', "#selectDataType", function() {
        $scope.dataViewAsTable = ($('#selectDataType').val() == 'tabele');
        $scope.initChart();
    });

    function initPercentChart() {
        if ($scope.acutalSelectedGroupTest)
            for (var i = 0; i < $scope.acutalSelectedGroupTest.length; i++) {
                if ($scope.acutalSelectedGroupTest[i].id != undefined) {
                    var chart = new Chart($('#chart-percent-' + $scope.acutalSelectedGroupTest[i].id), {
                        type: 'doughnut',
                        data: {
                            datasets: [{
                                data: [$scope.acutalSelectedGroupTest[i].summary, 100 - $scope.acutalSelectedGroupTest[i].summary],
                                backgroundColor: [
                                    '#ec1800',
                                    '#4e4e4e'
                                ]
                            }],
                            labels: [
                                'Aktualna średnia',
                                'Braki do maksimum'
                            ]
                        },
                        options: {
                            tooltips: {
                                callbacks: {
                                    afterLabel: (item)=>{ return `%`},
                                }
                            },
                        }
                    });
                }
            }
    }

    $scope.initChart = function() {
        moment.locale('pl');
        if (!$scope.dataViewAsTable && $scope.acutalSelectedGroupTest) {
            for (var i = 0; i < $scope.acutalSelectedGroupTest.length; i++) {
                var data = [];
                var labels = [];
                if ($scope.acutalSelectedGroupTest[i].scores != null) {
                    for (var j = 0; j < $scope.acutalSelectedGroupTest[i].scores.length; j++) {
                        var thisDate = moment($scope.acutalSelectedGroupTest[i].scores[j].data);
                        labels.push(thisDate.format('LL'));
                        data.push({
                            t: thisDate,
                            y: $scope.acutalSelectedGroupTest[i].scores[j].wynik
                        });
                    }
                    var chart = new Chart($('#chart-' + $scope.acutalSelectedGroupTest[i].id), {
                        type: 'line',
                        data: {
                            labels: labels,
                            datasets: [{
                                label: "Wyniki testów",
                                data: data,
                                borderColor: '#ec1800'
                            }],
                            options: {
                                scales: {
                                    xAxes: [{
                                        type: 'time',
                                        distribution: 'series',
                                        ticks: {
                                            source: 'labels'
                                        }
                                    }]
                                }
                            }
                        }
                    });
                }
            }
        }
    }
});
app.controller('newScoreController', function($scope, auth, $rootScope, notify, request) {
    $rootScope.showContent = false;
    $scope.categories = [];
    $scope.isSelectedCategory = false;
    $scope.users = [];
    var selectedCategoryId = -1;
    var selectedTestId = -1;
    var selectedUserId = -1;
    var selectedCategoryKey = -1;
    var selectedTestKey = -1;
    $scope.isSelectedTest = false;
    $scope.isSelectedUser = false;
    $scope.scores = [];

    $scope.initScores = function() {
        getAllCategoryWitchTest();
        getAllPlayers();
    }
    $(document).ready(function() {
        var wSize = $(window).width();
        if (wSize <= 768) {
            $(".adw").each(function() {
                $(this).removeClass("adwWith");
                $(this).addClass("adwWithout");
            });
        } else {
            $(".adw").each(function() {
                $(this).removeClass("adwWithout");
                $(this).addClass("adwWith");
            });
        }
    });

    function getAllCategoryWitchTest() {
        request.backend('getCategoryWitchTest', { tmid: $rootScope.user.tmid }, function(data) {
            $scope.$apply(function() {
                $scope.categories = data;
                for (key in $scope.categories) {
                    $('#catSelect').append('<option value="' + key + '">' + $scope.categories[key].name + '</option>');
                }
                Materialize.updateTextFields();
                $('select').material_select();
            });
        });
    }

    function checkChange() {
        if ($scope.isSelectedUser && $scope.isSelectedTest && $scope.isSelectedCategory) {
            getUserScore();
        }
    }

    function getUserScore() {
        $scope.scores = [];
        request.backend('getScoreFromTestId', { tmid: $rootScope.user.tmid, tsid: selectedTestId, usid: selectedUserId }, function(data) {
            $scope.$apply(function() {
                $scope.scores = data
            });
        });
    }

    function getAllPlayers() {
        request.backend('getAllPlayers', { tmid: $rootScope.user.tmid }, function(data) {
            $scope.$apply(function() {
                $scope.users = data;
                for (key in data) {
                    if (data[key].roleName == 'ZAWODNIK') {
                        $('#userSelect').append('<option value="' + key + '">' + data[key].firstname + ' ' + data[key].lastname + '</option>');
                    }
                }
                Materialize.updateTextFields();
                $('select').material_select();
                $scope.showContent = true;
            });
        });
    }

    function getTest() {
        $('#testSelect').html('');
        $('#testSelect').append('<option value="" disabled selected>Test</option>');
        $scope.isSelectedTest = false;
        selectedTestId = -1
        if ($scope.categories[selectedCategoryKey].tests) {
            for (key in $scope.categories[selectedCategoryKey].tests) {
                $('#testSelect').append('<option value="' + key + '">' + $scope.categories[selectedCategoryKey].tests[key].name + '</option>');
            }
        }
        Materialize.updateTextFields();
        $('select').material_select();
    }

    $scope.addScore = function() {
        if ($.isNumeric($('#scoreInput').val().replace(',', '.'))) {
            var score = parseFloat($('#scoreInput').val().replace(',', '.'));
            request.backend('addScore', { tmid: $rootScope.user.tmid, usid: selectedUserId, tsid: selectedTestId, score: score }, function(data) {
                getUserScore();
                $('#scoreInput').val('');
                notify.addNew(new notify.Notification("Otrzymałeś nowy wynik z kategorii : " + $scope.categories[selectedCategoryKey].name + " -- " + $scope.categories[selectedCategoryKey].tests[selectedTestKey].name, [selectedUserId], "#!/myStats"));
            }, 'Pomyślnie dodano nowy wynik testu');
        } else {
            notify.localNotify('Walidacja', 'Wpisz najpierw wynik. Musi być on liczbą.');
        }
    }

    $scope.deleteScore = function(id) {

        $rootScope.showModalWindow("Nieodwracalne usunięcie wyniku testu", function() {
            request.backend('deleteScore', { tmid: $rootScope.user.tmid, tsid: id }, function(data) {
                $scope.$apply(function() {
                    for (key in $scope.scores) {
                        if ($scope.scores[key].id == id) {
                            $scope.scores.splice(key, 1);
                            return;
                        }
                    }
                });
            }, 'Pomyślnie usunięto wynik testu');
        });


    }

    $(document).off('change', '#catSelect');
    $(document).on('change', '#catSelect', function() {
        if ($scope.categories.length != 0) {
            $scope.isSelectedCategory = true;
            selectedCategoryKey = $(this).val();
            selectedCategoryId = $scope.categories[selectedCategoryKey].id;
            getTest();
        }
    });

    $(document).off('change', '#testSelect');
    $(document).on('change', '#testSelect', function() {
        $scope.isSelectedTest = true;
        selectedTestId = $scope.categories[selectedCategoryKey].tests[$(this).val()].id;
        selectedTestKey = $(this).val();
        checkChange();
    });

    $(document).off('change', '#userSelect');
    $(document).on('change', '#userSelect', function() {
        $scope.isSelectedUser = true;
        selectedUserId = $scope.users[$(this).val()].usid;
        checkChange();
    });

    $scope.deleteUserScore = function(id) {

        $rootScope.showModalWindow("Nieodwracalne usunięcie kategorii", function() {
            $scope.showTest = false;
            $scope.selectedCategoryId = -1;
            request.backend('deleteCategoryTest', { id: id }, function(data) {
                getAllCategoryWitchTest();
            }, 'Pomyślnie usunięto kategorie');
        });


    }

    $scope.addUserScore = function() {
        var categoryName = $('#categoryName').val();
        if (categoryName.length < 2) {
            $.gritter.add({
                title: 'Walidacja',
                text: 'Wpisz dłuższą nazwę kategorii',
                image: '',
                sticky: true,
                time: 3,
                class_name: 'my-sticky-class'
            });
            return;
        }

        request.backend('addCategoryTest', { name: categoryName }, function(data) {
            getAllCategoryWitchTest();
        }, "Pomyślnie dodano nową kategorie");
    }

    $scope.selectCategory = function(id) {
        $scope.selectedCategoryId = id;
        $scope.showTest = true;
        getActualTest();
    }

});
app.controller('teammateCompareController', function($scope, auth, $rootScope, notify, statistic, request) {
    $scope.showContent = false;
    $scope.selected1 = false;
    $scope.selected2 = false;
    $scope.selected3 = false;
    $scope.loadStat = true;
    $rootScope.actualStats = [];
    $scope.dataViewAsTable = true;
    $scope.acutalSelectedGroup = 0;
    $scope.notSelectedPerson = true;
    $scope.actualStatGroup = null;
    $scope.actualPotentialGroup = null;

    var allUsers = [];
    var firstUsid = 0;
    var secondUsid = 0;
    var thirdUsid = 0;
    var usidList = [];
    var noPrcIs = true;


    $scope.initTeammate = function() {
        request.backend('getUserFromTeam', { tmid: $rootScope.user.tmid }, function(data) {
            $scope.showContent = true;
            allUsers = data;
            $('#firstUserSelect').html('');
            $('#firstUserSelect').append("<option value='' disabled selected>Zawodnik 1</option>");

            for (var i = 0; i < allUsers.length; i++) {
                var userName = allUsers[i].firstname + ' ' + allUsers[i].lastname;
                $('#firstUserSelect').append("<option value='" + allUsers[i].usid + "'>" + userName + "</option>");
            }

            Materialize.updateTextFields();
            $('select').material_select();
            $('ul.tabs').tabs();
        });
    }

    $scope.showStat = function() {
        $scope.notSelectedPerson = false;
        $("#mainChartContainer").html('');
        usidList = [
            firstUsid, secondUsid
        ];
        if ($scope.selected3) usidList.push(thirdUsid);

        request.backend('getStats', { usid: usidList, tmid: $rootScope.user.tmid, prc: "none", last: true }, function(data) {
            $rootScope.actualStats = data;
            addMainChartToPage();
            initMainSummary();
            initMainSummaryRadar();

            $scope.$apply(function() {
                $scope.loadStat = false;
                $('#selectPotential').html('');
                $('#selectPotential').append("<option value='' disabled selected>Kategoria</option>");

                for (let i = 0; i < $rootScope.actualStats.users[0].data.potential.length; i++) {
                    const element = $rootScope.actualStats.users[0].data.potential[i].name;
                    $('#selectPotential').append("<option value='" + i + "'>" + element + "</option>");
                }

                $scope.actualPotentialGroup = [];
                for (let i = 0; i < $rootScope.actualStats.users[0].data.potential.length; i++) {
                    const elName = $rootScope.actualStats.users[0].data.potential[i].name;
                    $scope.actualPotentialGroup.push({
                        name: elName,
                        users: []
                    });
                    for (let x = 0; x < $rootScope.actualStats.users.length; x++) {
                        $scope.actualPotentialGroup[i].users.push($rootScope.actualStats.users[x].data.potential[i].summary);
                    }
                }
            });

            checkStatBest();
            Materialize.updateTextFields();
            $('select').material_select();
            $('ul.tabs').tabs();
        });
    }

    function checkStatBest() {
        $('table tbody tr').each(function() {
            let scoreInElements = $(this).find('.scoreIn');
            let best = parseFloat($(this).find('.scBest').eq(0).text());
            let worst = parseFloat($(this).find('.scWorst').eq(0).text());
            if (scoreInElements.length > 0){
                let maxScore = getMaxScore(scoreInElements,noPrcIs ? best : 100);
                if( maxScore != null ){
                    scoreInElements.each(function() {
                        $(this).find('span').each(function(){
                            $(this).remove();
                        });
                        if( best < worst ){
                            if (parseFloat($(this).text()) > maxScore) {
                                $(this).append("<span style='color: red;font-size: 10px;font-weight:600'>" + "+" + ((parseFloat($(this).text())) - maxScore).toFixed(2)  + "</span>");
                            } else if (parseFloat($(this).text()) == maxScore) {
                                $(this).css("color", "rgb(22, 193, 22)");
                                $(this).css("font-weight", "600");
                            }
                        }else{
                            if (parseFloat($(this).text()) < maxScore) {
                                $(this).append("<span style='color: red;font-size: 10px;font-weight:600'>" + "-" + (maxScore - parseFloat($(this).text())).toFixed(2) + "</span>");
                            } else if (parseFloat($(this).text()) == maxScore) {
                                $(this).css("color", "rgb(22, 193, 22)");
                                $(this).css("font-weight", "600");
                            }
                        }
                    });
                }
            }

            scoreInElements = $(this).find('.scoreInP');
            if (scoreInElements.legend <= 0) return;
            maxScore = getMaxScore(scoreInElements,100);
            scoreInElements.each(function() {
                if (parseFloat($(this).text()) < maxScore) {
                    $(this).find('span').first().remove();
                    $(this).append("<span style='color: red;font-size: 10px;font-weight:600'>" + "-" + (maxScore - parseFloat($(this).text())).toFixed(2) + "</span>");
                } else if (parseFloat($(this).text()) == maxScore) {
                    $(this).css("color", "rgb(22, 193, 22)");
                    $(this).css("font-weight", "600");
                }
            });
        });
    }

    function getMaxScore(elements,best) {
        if(!elements.eq(0)) return;
        best = parseFloat(best).toFixed(2);
        let max =  Math.abs(best - parseFloat(elements.eq(0).text()));
        if( isNaN(max) ) return null;
        let toReturn = parseFloat(elements.eq(0).text());
        elements.each(function() {
            if ( Math.abs(best - parseFloat($(this).text())) < max) {
                max = Math.abs(best - parseFloat($(this).text()));
                toReturn = parseFloat($(this).text());
            }
        });
        return toReturn.toFixed(2);
    }

    $scope.hideStat = function() {
        $scope.notSelectedPerson = true;
        $scope.loadStat = true;
        $scope.actualStatGroup = [];
        $scope.actualPotentialGroup = [];
    }

    $(document).off('change', '#selectPotential');
    $(document).on('change', '#selectPotential', function() {
        changePotential();
        checkStatBest();
    });

    $(document).off('change', '#selectPrcType');
    $(document).on('change', '#selectPrcType', function() {
        var value = $(this).val();
        if (value == "prc") {
            noPrcIs = false;
        } else {
            noPrcIs = true;
        }
        changePotential();
        checkStatBest();
    });



    function changePotential() {
        $scope.showPreLoad = false;
        $scope.$apply(function() {
            $scope.acutalSelectedGroup = $("#selectPotential").val();
            $scope.actualStatGroup = [];
            if ($rootScope.actualStats.users[0].data.potential[$scope.acutalSelectedGroup].tests)
                for (let i = 0; i < $rootScope.actualStats.users[0].data.potential[$scope.acutalSelectedGroup].tests.length; i++) {
                    const elName = $rootScope.actualStats.users[0].data.potential[$scope.acutalSelectedGroup].tests[i].name;
                    $scope.actualStatGroup.push({
                        name: elName,
                        users: [],
                        best: $rootScope.actualStats.users[0].data.potential[$scope.acutalSelectedGroup].tests[i].best,
                        worst: $rootScope.actualStats.users[0].data.potential[$scope.acutalSelectedGroup].tests[i].worst
                    });
                    for (let x = 0; x < $rootScope.actualStats.users.length; x++) {
                        if (noPrcIs) $scope.actualStatGroup[i].users.push($rootScope.actualStats.users[x].data.potential[$scope.acutalSelectedGroup].tests[i].noPrc + "" + ($rootScope.actualStats.users[x].data.potential[$scope.acutalSelectedGroup].tests[i].unit).substring(0, 1) + ".");
                        else $scope.actualStatGroup[i].users.push($rootScope.actualStats.users[x].data.potential[$scope.acutalSelectedGroup].tests[i].summary + "%");
                    }
                }
        });
    }

    $(document).off('change', '#selectDataType');
    $(document).on('change', '#selectDataType', function() {
        $scope.dataViewAsTable = ($('#selectDataType').val() == 'tabele');
    });

    function addMainChartToPage() {
        var elementClass = "col s12 m6";
        if ($scope.selected3) elementClass = "col s12 m4";
        $("#mainChartContainer").html('');
        $("#mainChartContainer").css('max-width', "600px");
        if ($scope.selected3) $("#mainChartContainer").css('max-width', "1000px");
        for (let i = 0; i < ($scope.selected3 ? 3 : 2); i++) {
            var element = '<div class="' + elementClass + '">';
            element += '<canvas class="col s12" style="padding:0 !important" id="main-summary-chart-' + i + '"></canvas>';
            element += '<canvas class="col s12" style="padding:0 !important" id="main-summary-chart-radar-' + i + '"></canvas>';
            element += '</div>';
            $("#mainChartContainer").append(element);
        }
    }

    function initMainSummary() {
        for (let i = 0; i < ($scope.selected3 ? 3 : 2); i++) {
            var userForm = $rootScope.actualStats.users[i].data.form;
            $('#main-summary-chart-' + i).parent().prepend("<h5>" + $rootScope.actualStats.users[i].userName + "</h5>");
            var chart = new Chart($('#main-summary-chart-' + i), {
                type: 'doughnut',
                data: {
                    datasets: [{
                        data: [userForm, 100 - userForm],
                        backgroundColor: [
                            '#ec1800',
                            '#4e4e4e'
                        ]
                    }],
                    labels: [
                        'Forma',
                        'Braki'
                    ]
                },
                options: {
                    tooltips: {
                        callbacks: {
                            afterLabel: (item) => { return `%` },
                        }
                    },
                }
            });
        }
    }

    function initMainSummaryRadar() {
        for (let i = 0; i < ($scope.selected3 ? 3 : 2); i++) {
            var label = [];
            var dataSe = [];
            for (var j = 0; j < $rootScope.actualStats.users[i].data.potential.length; j++) {
                label.push($rootScope.actualStats.users[i].data.potential[j].name);
                dataSe.push($rootScope.actualStats.users[i].data.potential[j].summary);
            }
            var chart = new Chart($('#main-summary-chart-radar-' + i), {
                type: 'radar',
                data: {
                    datasets: [{
                        label: "Kierunek rozwoju",
                        data: dataSe,
                        backgroundColor: 'rgba(236, 24, 0, 0.2)',
                        borderColor: '#ec1800',
                    }],
                    labels: label,
                },
                options: {
                    legend: {
                        position: 'top',
                    },
                    scale: {
                        ticks: {
                            beginAtZero: true
                        }
                    },
                    tooltips: {
                        callbacks: {
                            afterLabel: (item) => { return `%` },
                        }
                    },
                }
            });
        }
    }

    $(document).off("change", "#firstUserSelect");
    $(document).on("change", "#firstUserSelect", function() {
        firstUsid = $(this).val();
        $('#secondUserSelect').html('');
        $('#secondUserSelect').append("<option value='' disabled selected>Zawodnik 2</option>");

        for (var i = 0; i < allUsers.length; i++) {
            if (allUsers[i].usid == firstUsid) continue;
            var userName = allUsers[i].firstname + ' ' + allUsers[i].lastname;
            $('#secondUserSelect').append("<option value='" + allUsers[i].usid + "'>" + userName + "</option>");
        }

        Materialize.updateTextFields();
        $('select').material_select();
        $('ul.tabs').tabs();
        $scope.$apply(function() {
            $scope.selected1 = true;
            $scope.selected2 = false;
            $scope.selected3 = false;
        });
    });

    $(document).off("change", "#secondUserSelect");
    $(document).on("change", "#secondUserSelect", function() {
        secondUsid = $(this).val();
        $('#thirdUserSelect').html('');
        $('#thirdUserSelect').append("<option value='' disabled selected>Zawodnik 3</option>");

        for (var i = 0; i < allUsers.length; i++) {
            if (allUsers[i].usid == firstUsid || allUsers[i].usid == secondUsid) continue;
            var userName = allUsers[i].firstname + ' ' + allUsers[i].lastname;
            $('#thirdUserSelect').append("<option value='" + allUsers[i].usid + "'>" + userName + "</option>");
        }

        Materialize.updateTextFields();
        $('select').material_select();
        $('ul.tabs').tabs();
        $scope.$apply(function() {
            $scope.selected2 = true;
            $scope.selected3 = false;
        });
    });

    $(document).off("change", "#thirdUserSelect");
    $(document).on("change", "#thirdUserSelect", function() {
        $scope.$apply(function() {
            $scope.selected3 = true;
        });
        thirdUsid = $(this).val();
    });


    $(document).ready(function() {
        var wSize = $(window).width();
        if (wSize <= 768) {
            $(".adw").each(function() {
                $(this).removeClass("adwWith");
                $(this).addClass("adwWithout");
            });
        } else {
            $(".adw").each(function() {
                $(this).removeClass("adwWithout");
                $(this).addClass("adwWith");
            });
        }
    });


});
app.controller('teamStatisticController', function($scope, auth, $rootScope, notify, statistic, request) {
    $rootScope.showContent = false;
    $rootScope.actualStats = [];
    $rootScope.teamCategorySummary = [];
    $rootScope.teamMatchCategorySummary = [];
    $scope.showTestSelect = false;
    var fullTeamScore = 0;
    var matchTeamScore = 0;
    var mainChartToCheck = null;
    var colorIndex = 0;
    var selectedTestCategory = -1;
    dataToChartTestInCategory = [];
    var testChart = null;
    $(document).ready(function() {
        var wSize = $(window).width();
        if (wSize <= 768) {
            $(".adw").each(function() {
                $(this).removeClass("adwWith");
                $(this).addClass("adwWithout");
            });
        } else {
            $(".adw").each(function() {
                $(this).removeClass("adwWithout");
                $(this).addClass("adwWith");
            });
        }
    });
    $scope.initTeamStats = function() {
        request.backend('getUserFromTeam', { tmid: $rootScope.user.tmid }, function(data) {
            var allPersonsId = [];
            var matchPersonsId = [];
            var fullPersonId = [];
            for (var i = 0; i < data.length; i++) {
                allPersonsId.push({ usid: data[i].usid, userName: data[i].firstname + ' ' + data[i].lastname });
                fullPersonId.push(data[i].usid);
                if (data[i].pos_x >= 0 && data[i].pos_y >= 0) {
                    matchPersonsId.push(data[i].usid);
                }
            }
            fullTeamScore = statistic.getTeamForm(fullPersonId);
            matchTeamScore = statistic.getTeamForm(matchPersonsId, true);

            statistic.getTeamStats(matchPersonsId, function() {
                $rootScope.teamMatchCategorySummary = [];
                if ($rootScope.actualStats) {
                    for (var j = 0; j < $rootScope.actualStats[0].data.potential.length; j++) {
                        var testLabel = $rootScope.actualStats[0].data.potential[j].name;
                        var score = 0;
                        for (var i = 0; i < $rootScope.actualStats.length; i++) {
                            score += $rootScope.actualStats[i].data.potential[j].summary;
                        }
                        score /= $rootScope.actualStats.length;
                        score = Math.round(score);
                        $rootScope.teamMatchCategorySummary.push({
                            name: testLabel,
                            summary: score
                        });
                    }
                }
                statistic.getTeamStats(fullPersonId, function() {
                    $rootScope.$apply(function() {
                        $rootScope.showContent = true;
                        $rootScope.teamCategorySummary = [];
                        if ($rootScope.actualStats) {
                            $('#categoryTestSelect').html('');
                            $('#categoryTestSelect').append("<option value='' disabled selected>Wybierz kategorię testów</option>");
                            for (var j = 0; j < $rootScope.actualStats[0].data.potential.length; j++) {
                                var testLabel = $rootScope.actualStats[0].data.potential[j].name;
                                var score = 0;
                                if ($rootScope.actualStats[0].data.potential[j].tests && $rootScope.actualStats[0].data.potential[j].tests.length > 0)
                                    $('#categoryTestSelect').append("<option value='" + j + "'>" + testLabel + "</option>");
                                for (var i = 0; i < $rootScope.actualStats.length; i++) {
                                    score += $rootScope.actualStats[i].data.potential[j].summary;
                                }
                                score /= $rootScope.actualStats.length;
                                score = Math.round(score);
                                $rootScope.teamCategorySummary.push({
                                    name: testLabel,
                                    summary: score
                                });
                            }
                        }
                    });
                    initChartMin();
                    $scope.initChart();
                });
            });
        });
    }


    $(document).off("change", "#categoryTestSelect");
    $(document).on("change", "#categoryTestSelect", function() {
        const categoryId = $(this).val();
        selectedTestCategory = categoryId;
        $scope.showTestSelect = true;
        $('#testSelect').html('');
        $('#testSelect').append("<option value='' disabled selected>Wybierz test</option>");

        for (var j = 0; j < $rootScope.actualStats[0].data.potential[categoryId].tests.length; j++) {
            var testLabel = $rootScope.actualStats[0].data.potential[categoryId].tests[j].name;
            $('#testSelect').append("<option value='" + j + "'>" + testLabel + "</option>");
        }

        setTimeout(function() {
            Materialize.updateTextFields();
            $('select').material_select();
        }, 500);
    });

    $(document).off("change", "#testSelect");
    $(document).on("change", "#testSelect", function() {
        const testId = $(this).val();
        var data = [{
            label: $rootScope.actualStats[0].data.potential[selectedTestCategory].tests[testId].name,
            backgroundColor: getRandomColor(),
            data: []
        }];
        var label = [];

        for (var j = 0; j < $rootScope.actualStats.length; j++) {
            label.push($rootScope.actualStats[j].userName);
            var score = $rootScope.actualStats[j].data.potential[selectedTestCategory].tests[testId].summary;
            data[0].data.push(score);
        }

        if (!testChart || testChart == null) {
            testChart = new Chart($('#testChart'), {
                type: 'horizontalBar',
                data: {
                    datasets: data,
                    labels: label
                },
                options: {
                    responsive: true,
                    maintainAspectRatio: false,
                }
            });
        } else {
            testChart.data.labels = label;
            testChart.data.datasets = data;
            testChart.update();
        }

    });

    function getRandomColor() {
        var list = [
            '#DAF7A6',
            '#FFC300',
            '#FF5733',
            "#C70039",
            "#581845"
        ];
        colorIndex++;
        if (colorIndex >= list.length) colorIndex = 0;
        return list[colorIndex];
    }

    function initChartMin() {
        var chart = new Chart($('#fullTeamForm'), {
            type: 'doughnut',
            data: {
                datasets: [{
                    data: [fullTeamScore, 100 - fullTeamScore],
                    backgroundColor: [
                        '#ec1800',
                        '#4e4e4e'
                    ]
                }],
                labels: [
                    'Poziom całej drużyny',
                    'Braki do maksimum'
                ]
            },
            options: {
                tooltips: {
                    callbacks: {
                        afterLabel: (item)=>{ return `%`},
                    }
                },
            }
        });

        var chart = new Chart($('#actualTeamForm'), {
            type: 'doughnut',
            data: {
                datasets: [{
                    data: [matchTeamScore, 100 - matchTeamScore],
                    backgroundColor: [
                        '#ec1800',
                        '#4e4e4e'
                    ]
                }],
                labels: [
                    'Poziom składu meczowego',
                    'Braki do maksimum'
                ]
            },
            options: {
                tooltips: {
                    callbacks: {
                        afterLabel: (item)=>{ return `%`},
                    }
                },
            }
        });

        if ($rootScope.teamCategorySummary.length > 0) {
            var label = [];
            var dataSe = [];
            for (var i = 0; i < $rootScope.teamCategorySummary.length; i++) {
                label.push($rootScope.teamCategorySummary[i].name);
                dataSe.push($rootScope.teamCategorySummary[i].summary);
            }
            var chart = new Chart($('#teamChartRadar'), {
                type: 'radar',
                data: {
                    datasets: [{
                        label: "Predyspozycje drużyny",
                        data: dataSe,
                        backgroundColor: 'rgba(236, 24, 0, 0.2)',
                        borderColor: '#ec1800',
                    }],
                    labels: label,
                },
                options: {
                    legend: {
                        position: 'top',
                    },
                    scale: {
                        ticks: {
                            beginAtZero: true
                        }
                    },
                    tooltips: {
                        callbacks: {
                            afterLabel: (item)=>{ return `%`},
                        }
                    },
                }
            });
        }

        if ($rootScope.teamMatchCategorySummary.length > 0) {
            var label = [];
            var dataSe = [];
            for (var i = 0; i < $rootScope.teamMatchCategorySummary.length; i++) {
                label.push($rootScope.teamMatchCategorySummary[i].name);
                dataSe.push($rootScope.teamMatchCategorySummary[i].summary);
            }
            var chart = new Chart($('#teamMatchChartRadar'), {
                type: 'radar',
                data: {
                    datasets: [{
                        label: "Predyspozycje składu meczowego",
                        data: dataSe,
                        backgroundColor: 'rgba(236, 24, 0, 0.2)',
                        borderColor: '#ec1800',
                    }],
                    labels: label,
                },
                options: {
                    legend: {
                        position: 'top',
                    },
                    scale: {
                        ticks: {
                            beginAtZero: true
                        }
                    },
                    tooltips: {
                        callbacks: {
                            afterLabel: (item)=>{ return `%`},
                        }
                    },
                }
            });
        }
    }

    $scope.initChart = function() {
        var data = [];
        var label = [];
        if ($rootScope.actualStats) {
            for (var j = 0; j < $rootScope.actualStats.length; j++) {
                label.push($rootScope.actualStats[j].userName);
            }

            for (var j = 0; j < $rootScope.actualStats[0].data.potential.length; j++) {
                var testLabel = $rootScope.actualStats[0].data.potential[j].name;
                var allScore = [];
                for (var i = 0; i < $rootScope.actualStats.length; i++) {
                    allScore.push($rootScope.actualStats[i].data.potential[j].summary);
                }
                data.push({
                    label: testLabel,
                    data: allScore,
                    backgroundColor: getRandomColor()
                });
            }
            if (!mainChartToCheck || mainChartToCheck == null) {
                mainChartToCheck = new Chart($('#chart-main'), {
                    type: 'horizontalBar',
                    data: {
                        datasets: data,
                        labels: label
                    },
                    options: {
                        responsive: true,
                        maintainAspectRatio: false,
                        tooltips: {
                            callbacks: {
                                afterLabel: (item)=>{ return `%`},
                            }
                        },
                    }
                });
            } else {
                mainChartToCheck.data.labels = label;
                mainChartToCheck.data.datasets = data;
                mainChartToCheck.update();
            }

        }
    }

});
app.controller('testMenagerController', function($scope, auth, $rootScope, notify, request) {
    $rootScope.showContent = false;
    $scope.categories = [];
    $scope.tests = [];
    $scope.showTest = false;
    $scope.selectedCategoryId = -1;
    $(document).ready(function() {
        var wSize = $(window).width();
        if (wSize <= 768) {
            $(".adw").each(function() {
                $(this).removeClass("adwWith");
                $(this).addClass("adwWithout");
            });
        } else {
            $(".adw").each(function() {
                $(this).removeClass("adwWithout");
                $(this).addClass("adwWith");
            });
        }
    });
    $scope.initTestMenager = function() {
        getAllCategoryWitchTest();
    }

    function getAllCategoryWitchTest() {
        request.backend('getCategoryWitchTest', { tmid: $rootScope.user.tmid }, function(data) {
            $scope.$apply(function() {
                $scope.showContent = true;
                $scope.categories = data;
                for (var i = 0; i < $scope.categories.length; i++) {
                    $scope.categories[i].testCount = $scope.categories[i].tests ? $scope.categories[i].tests.length : 0;
                }
                if ($scope.selectedCategoryId && $scope.selectedCategoryId != -1) {
                    getActualTest();
                }
            });
        });
    }

    $scope.deleteCategory = function(id) {

        $rootScope.showModalWindow("Nieodwracalne usunięcie kategorii", function() {
            $scope.showTest = false;
            $scope.selectedCategoryId = -1;
            request.backend('deleteCategoryTest', { id: id }, function(data) {
                $scope.$apply(function() {
                    getAllCategoryWitchTest();
                });
            }, 'Pomyślnie usunięto kategorie');
        });


    }

    $scope.deleteTest = function(id) {

        $rootScope.showModalWindow("Nieodwracalne usunięcie testu", function() {
            request.backend('deleteTestFromCat', { id: id }, function(data) {
                $scope.$apply(function() {
                    getAllCategoryWitchTest();
                });
            }, 'Pomyślnie usunięto test');
        });

    }

    $scope.addCategory = function() {
        var categoryName = $('#categoryName').val();
        if (categoryName.length < 2) {
            $.gritter.add({
                title: 'Walidacja',
                text: 'Wpisz dłuższą nazwę kategorii',
                image: '',
                sticky: true,
                time: 3,
                class_name: 'my-sticky-class'
            });
            return;
        }

        request.backend('addCategoryTest', { name: categoryName }, function(data) {
            $scope.$apply(function() {
                getAllCategoryWitchTest();
            });
        }, 'Pomyślnie dodano nową kategorie');
    }

    $scope.addTest = function() {
        var best = $('#maxScore').val();
        var worst = $('#minScore').val();
        var name = $('#testName').val();
        var unit = $('#unitType').val();
        if (!best || !worst || !$.isNumeric(best) || !$.isNumeric(worst)) {
            $.gritter.add({
                title: 'Walidacja',
                text: 'Pola najlepszego i najgorszego wyniku muszą być liczbą',
                image: '',
                sticky: true,
                time: 3,
                class_name: 'my-sticky-class'
            });
            return;
        }
        if (!name || name.length < 3) {
            $.gritter.add({
                title: 'Walidacja',
                text: 'Wpisz poprawnie nazwe testu. Minimum 3 znaki',
                image: '',
                sticky: true,
                time: 3,
                class_name: 'my-sticky-class'
            });
            return;
        }
        if (!$scope.selectedCategoryId || $scope.selectedCategoryId == -1) {
            $.gritter.add({
                title: 'Walidacja',
                text: 'Coś poszło nie tak. Wybierz ponownie kategorie z tabeli',
                image: '',
                sticky: true,
                time: 3,
                class_name: 'my-sticky-class'
            });
            $scope.selectedCategoryId = -1;
            $scope.showTest = false;
            return;
        }
        if (!unit || unit.length > 10) {
            $.gritter.add({
                title: 'Walidacja',
                text: 'Jednostka może mieć maks 10 znaków',
                image: '',
                sticky: true,
                time: 3,
                class_name: 'my-sticky-class'
            });
            return;
        }

        request.backend('addTestToCategory', { unit: unit, best: best, worst: worst, caid: $scope.selectedCategoryId, name: name, tmid: $rootScope.user.tmid }, function(data) {
            $scope.$apply(function() {
                getAllCategoryWitchTest();
                $('#minScore').val('');
                $('#testName').val('');
                $('#unitType').val('');
                $('#maxScore').val('');
            });
        }, 'Pomyślnie dodano nowy test do kategorii');

    }

    $scope.selectCategory = function(id) {
        $scope.selectedCategoryId = id;
        $scope.showTest = true;
        getActualTest();
    }

    function getActualTest() {
        $('.category-item').each(function() {
            $(this).css('background', '');
        });
        $('#category-' + $scope.selectedCategoryId).css('background', 'rgba(255, 255, 255, 0.1)');
        for (var i = 0; i < $scope.categories.length; i++) {
            if ($scope.categories[i].id == $scope.selectedCategoryId) {
                $scope.tests = $scope.categories[i].tests;
                break;
            }
        }
    }

    $(document).off('change', '.changeBest');
    $(document).on('change', '.changeBest', function() {
        var newBest = $(this).val();
        if (!$.isNumeric(newBest)) {
            notify.localNotify('Walidacja', 'Najwiekszy możliwy wynik musi być liczbą');
            return;
        }
        var id = ($(this).attr('id').split("-"))[1];
        changeTest(id, newBest, 'best');
    });

    $(document).off('change', '.changeWorst');
    $(document).on('change', '.changeWorst', function() {
        var newWorst = $(this).val();
        if (!$.isNumeric(newWorst)) {
            notify.localNotify('Walidacja', 'Najgorszy możliwy wynik musi być liczbą');
            return;
        }
        var id = ($(this).attr('id').split("-"))[1];
        changeTest(id, newWorst, 'worst');
    });

    $(document).off('change', '.changeUnit');
    $(document).on('change', '.changeUnit', function() {
        var newUnit = $(this).val();
        if (newUnit.length > 10) {
            notify.localNotify('Walidacja', 'Wpisz maks 10 znaków');
            return;
        }
        var id = ($(this).attr('id').split("-"))[1];
        changeTest(id, newUnit, 'unit');
    });

    function changeTest(id, value, changeType) {

        request.backend('changeTest', { id: id, value: value, changeType: changeType }, function(data) {
            $scope.$apply(function() {
                getAllCategoryWitchTest();
            });
        }, 'Pomyślnie edytowano test');

    }

});
app.controller('trainingBaseController', function($scope, auth, $rootScope, notify, statistic, request) {
    $rootScope.showContent = true;
    $(document).ready(function() {
        setTimeout(function(){
            $('.collapsible').collapsible();
        },1000);
        var wSize = $(window).width();
        if (wSize <= 768) {
            $(".adw").each(function() {
                $(this).removeClass("adwWith");
                $(this).addClass("adwWithout");
            });
        } else {
            $(".adw").each(function() {
                $(this).removeClass("adwWithout");
                $(this).addClass("adwWith");
            });
        }
    });
    $scope.trainingBase = [ //tablica obiektow, jeden obiekt to jeden trening

        { // rozpoczecie pierwszego obiektu, w srodku jego pola
            name: "Beep Test",
            ageCategory: "od 13 roku życia wzwyż",
            equipment: "2 linie (lub inne znaczniki), urządzenie audio do sygnalizowania (np. laptop)",
            execution: [ // wartosc tego pola jest tablica czyli []
                "1. Linie oddalone są od siebie na odległość 20m.",
                "2. Zawodnik staje na jednej z nich.",
                "3. Zadaniem zawodnika jest biec od linii do linii w wyznaczonych przedziałach czasu.",
                "4. Każdy start z linii musi być zsynchronizowany z sygnałem dźwiękowym („Beep”).",
                "5. Zawodnik biega tak długo, dopóki nie zrezygnuje (nie da rady więcej biec) lub w chwili gdy po raz drugi nie dotrze do linii na czas.",
                "6. Zapisywany jest ostatni etap oraz odcinek, w którym zawodnik dotarł do linii.",
                "7. Zaczynamy od tempa 8.5km/h. Prędkość się zwiększa.",
                "8. Jeśli zawodnik dotrze do linii za szybko, powinien poczekać na sygnał."
            ],
            scoring: [
                "Im więcej zaliczonych etapów i odcinków 20-metrowych – tym lepiej.",
                "Do e-platformy Club Management Center wynik wprowadzamy w następujący sposób:",
                "liczba przed kropką oznacza etap, a po kropce – odcinek.",
                "Takim sposobem, gdy zawodnik ukończył test na 10 etapie i 2 odcinku, zapisujemy wynik jako 10.02.",
                "Analogicznie jeśli ukończył test na 9 etapie i 10 odcinku, zapisujemy wynik jako 9.1.",
                "W razie niepewności prosimy o kontakt z działem technicznym."
            ]
        },

        {
            name: "Bieg bez piłki",
            ageCategory: "od 8 do 13 roku życia",
            equipment: "8 tyczek (lub innych znaczników)",
            execution: [
                "1. Zawodnik staje na linii startu.",
                "2. Ma przebiec po wyznaczonej trasie (obiegając każdą z tyczek) w jak najszybszym czasie.",
                "3. Rozpoczęcie biegu następuje po komendzie trenera – wtedy również zaczynamy liczenie czasu.",
                "4. Zatrzymujemy czas w momencie przebiegnięcia zawodnika przez linię mety."
            ],
            scoring: [
                "Im krótszy czas wykonania – tym lepiej.",
                "Niepoprawne wykonanie testu oznacza dyskwalifikację.",
                "Należy wtedy powtórzyć cały test od nowa."
            ]
        },

        {
            name: "FMS - Mobilność barków",
            ageCategory: "wszyscy",
            equipment: "taśma centymetrowa (lub inny przyrząd do pomiaru odległości)",
            execution: [
                "1. Należy zmierzyć zawodnikowi odległość między podstawą dłoni a końcem środkowego palca.",
                "2. Zawodnik zaciska pięści w obu dłoniach.",
                "3. Teraz sięga jedną ręką od góry, drugą od dołu – tak, aby ułożyć je jak najbliżej siebie za plecami.",
                "4. Zawodnik ma wykonać to jednym, płynnym ruchem i utrzymać ręce za plecami.",
                "5. Należy zmierzyć odległość między pięściami, a następnie wykonać całość odwrotnym ustawieniem rąk."
            ],
            scoring: [
                "3pkt: Odległość między pięściami nie przekracza odległości pomiędzy podstawą dłoni i końcem środkowego palca zawodnika.",
                "2pkt: Odległość między pięściami nie przekracza półtorej długości dłoni zawodnika.",
                "1pkt: Odległość między pięściami przekracza półtorej długości dłoni zawodnika."
            ]
        },

        {
            name: "FMS - Pompka",
            ageCategory: "wszyscy",
            equipment: "brak",
            execution: [
                "1. Zawodnik przyjmuje pozycję do pompki z rękoma rozstawionymi na szerokość barków.",
                "2. Mężczyźni: kciuki mają znajdować się na wysokości czubka głowy.",
                "Kobiety: kciuki mają znajdować się na wysokości policzków.",
                "3. Zawodnik wykonuje pompkę.",
                "4. Należy zwrócić uwagę, aby zawodnik uniósł całe ciało bez wyginania kręgosłupa."
            ],
            scoring: [
                "3pkt: Mężczyźni: Poprawnie wykonana pompka.",
                "Kobiety: Poprawnie wykonana pompka.",
                "2pkt: Mężczyźni: Poprawnie wykonana pompka, ale z kciukami na wysokości policzków.",
                "Kobiety: Poprawnie wykonana pompka, ale z kciukami na wysokości obojczyków.",
                "1pkt: Brak poprawnie wykonanej pompki."
            ]
        },

        {
            name: "FMS - Przejście pod płotkiem",
            ageCategory: "wszyscy",
            equipment: "drążek (może być tyczka lub kij), płotek (lub sznurek)",
            execution: [
                "1. Zawodnik stoi przed płotkiem (palce stóp pod płotkiem).",
                "2. Zawodnik trzyma oburącz drążek, opiera go na barkach.",
                "3. Rozpoczyna się zadanie – zawodnik ma przenieść nogę nad płotkiem, bez dotykania go.",
                "4. Należy postawić nogę po drugiej stronie płotka i dotknąć piętą podłoża.",
                "5. Zawodnik wraca do pozycji wyjściowej, a następnie powtarza całość wykonując drugą nogą."
            ],
            scoring: [
                "3pkt: Biodro, kolano i stopa nogi znajdującej się po drugiej stronie płotka są w jednej osi. Odcinek lędźwiowy kręgosłupa ma być nieruchomy, a drążek z listwą ustawione do siebie równolegle.",
                "2pkt: Brak osi wzdłuż nogi znajdującej się po drugiej stronie płotka. Odcinek lędźwiowy kręgosłupa nie jest nieruchomy, a drążek z listwą nie są ustawione równolegle.",
                "1pkt: Zawodnik dotknął płotka i tracił równowagę."
            ]
        },

        {
            name: "FMS - Przysiad głęboki",
            ageCategory: "wszyscy",
            equipment: "drążek (może być tyczka lub kij)",
            execution: [
                "1. Zawodnik stoi w rozkroku na szerokość bioder.",
                "2. Zawodnik trzyma nad głową drążek – ręce wyprostowane w łokciach.",
                "3. Rozpoczyna się zadanie – zawodnik ma wykonać maksymalny przysiad.",
                "4. Należy zwrócić uwagę na to, aby ciało zawodnika było skierowane na wprost, a jego pięty mają przylegać do ziemi."
            ],
            scoring: [
                "3pkt: Zawodnik zszedł na tyle nisko, że jego biodra znalazły się poniżej linii kolan, kolana znajdują się osi nóg, uda ułożone są równolegle do tułowia, a drążek jest na wysokości stóp.",
                "2pkt: Zawodnik wykonał przysiad, ale z pomocą – z podstawką położoną pod piętami, kolana nie znajdują się w osi nóg.",
                "1pkt: Zawodnik nie wykonuje poprawnie przysiadu nawet z pomocą, dodatkowo zgięcie w części lędźwiowej kręgosłupa."
            ]
        },

        {
            name: "FMS - Przysiad w wykroku",
            ageCategory: "wszyscy",
            equipment: "drążek (może być tyczka lub kij), podstawa (lub listwa), taśma centymetrowa (lub inny przyrząd do pomiaru odległości)",
            execution: [
                "1. Należy zacząć od zmierzenia długości podudzia zawodnika.",
                "2. Zawodnik stoi na początku podstawy, od tego miejsca (od czubka stopy) należy odmierzyć na podstawie odległość równą długości podudzia i zaznaczyć ją na podstawie.",
                "3. Zawodnik otrzymuje drążek, ma go trzymać oburącz i przyłożyć go do pleców.",
                "4. Teraz zawodnik stawia piętę jednej z nóg w wyznaczonym punkcie i wykonuje przysiad.",
                "5. Należy dotknąć kolanem podstawy (za piętą postawioną w wyznaczonym punkcie).",
                "6. Zawodnik wraca do pozycji wyjściowej i wykonuje to samo drugą nogą."
            ],
            scoring: [
                "3pkt: Stopy i kolana podczas wykonywania ćwiczenia utrzymane były w jednej linii, dotknięto kolanem podstawy, ruch tułowia był minimalny.",
                "2pkt: Nie utrzymano jednej linii stóp i kolan, nie dotknięto kolanem podstawy, pochylono się do przodu podczas wykonywania ćwiczenia.",
                "1pkt: Zawodnik całkowicie utracił równowagę."
            ]
        },

        {
            name: "FMS - Stabilność rotacyjna tułowia",
            ageCategory: "wszyscy",
            equipment: "brak",
            execution: [
                "1. Zawodnik ustawia się w następujący sposób: klęczy w podporze na ziemi tak, aby biodra i barki były ustawione do tułowia pod kątem 90 stopni. Stopy mają być wyprostowane.",
                "2. Zawodnik ma jednocześnie unieść lewą rękę i lewą nogę, a następnie wyprostować obie kończyny w powietrzu.",
                "3. Teraz zawodnik musi ugiąć kończyny i dotknąć łokciem kolana.",
                "4. Następnie należy znowu wyprostować kończyny.",
                "5. Na koniec powrót do pozycji wyjściowej i powtórzenie testu drugą parą kończyn."
            ],
            scoring: [
                "3pkt: Poprawne wykonanie, zawodnik utrzymał tułów równolegle do podłoża, a kolano i łokieć były w jednej linii.",
                "2pkt: Poprawne wykonanie skośnej wersji testu (przeciwległe kończyny, czyli kiedy podnosimy lewą rękę, musimy podnieść prawą nogę), zawodnik utrzymał tułów równolegle do podłoża.",
                "1pkt: Brak poprawnego wykonania skośnej wersji testu."
            ]
        },

        {
            name: "FMS - Uniesienie wyprostowanej nogi",
            ageCategory: "wszyscy",
            equipment: "deska, drążek (lub tyczka)",
            execution: [
                "1. Zawodnik kładzie się na plecach.",
                "2. Pod kolanami umieszczamy deskę.",
                "3. Należy znaleźć kolec biodrowy przedni górny oraz szparę stawu kolanowego zawodnika.",
                "4. Zawodnik unosi wyprostowaną nogę. Stopa zgięta w taki sposób, aby tworzyła z nogą kąt 90 stopni (jakbyśmy chcieli pokazać palcami stopy na siebie).",
                "5. Teraz należy przyłożyć do kostki zawodnika drążek, tak aby był prostopadle do ziemi.",
                "6. Zauważamy miejsce padania drążka i powtarzamy test drugą nogą."

            ],
            scoring: [
                "3pkt: Miejsce padania drążka znajduje się między kolcem biodrowym przednim górnym zawodnika, a środkiem uda.",
                "2pkt: Miejsce padania drążka znajduje się między środkiem uda, a linią stawu kolanowego.",
                "1pkt: Miejsce padania drążka znajduje się za szparą stawu kolanowego."
            ]
        },

        {
            name: "Ławeczki",
            ageCategory: "od 13 do 16 roku życia",
            equipment: "2 tyczki (lub inne znaczniki), ławeczka, piłka",
            execution: [
                "1. Zawodnik przez 90 sekund ma za zadanie uderzać piłką o ławeczkę.",
                "2. Uderzenie ma być wykonane wewnętrzną częścią stopy, na przemian lewą i prawą nogą.",
                "3. Odległość od miejsca wykonania uderzenia do ławeczki wynosi 3m.",
                "4. Po uderzeniu zawodnik ma dowolnie przyjąć piłkę, przeprowadzić ją przez „bramkę” z tyczek i wykonać kolejne powtórzenie.",
                "5. Liczymy ilość poprawnych uderzeń."
            ],
            scoring: [
                "5pkt: powyżej 21 uderzeń",
                "4pkt: 21-20 uderzeń",
                "3pkt: 20-19 uderzeń",
                "2pkt: 18-17 uderzeń",
                "1pkt: 16-15 uderzeń",
                "0pkt: poniżej 15 uderzeń"
            ]
        },

        {
            name: "Prowadzenie piłki",
            ageCategory: "od 8 do 13 roku życia",
            equipment: "8 tyczek (lub innych znaczników), piłka",
            execution: [
                "1. Zawodnik staje z piłką na linii startowej.",
                "2. Ma przebiec po wyznaczonej trasie (obiegając każdą z tyczek) w jak najszybszym czasie – jednocześnie prowadząc piłkę.",
                "3. Rozpoczęcie biegu następuje po komendzie trenera – wtedy również zaczynamy liczenie czasu.",
                "4. Zatrzymujemy czas w momencie przebiegnięcia zawodnika przez linię mety."
            ],
            scoring: [
                "Im krótszy czas wykonania – tym lepiej.",
                "Niepoprawne wykonanie testu oznacza dyskwalifikację.",
                "Należy wtedy powtórzyć cały test od nowa."
            ]
        },

        {
            name: "RAST",
            ageCategory: "od 16 roku życia wzwyż",
            equipment: "4 tyczki (lub inne znaczniki), fotokomórki",
            execution: [
                "1. Odległość między liniami startu i mety wynosi 30m.",
                "2. Test polega na jak najszybszym wykonaniu siedmiu sprintów na tym dystansie.",
                "3. Pomiędzy powtórzeniami występuje przerwa (trucht) o długości 25s.",
                "4. Zawodnik ustawia się na jednej z linii.",
                "5. Zawodnik ma wykonać jak najszybszy sprint, a po nim wrócić na linię startową truchtem.",
                "6. Mierzymy czas średni wszystkich biegów oraz procentowy spadek czasu.",
                "7. Procentowy spadek czasu jest różnicą między najszybszym, a najwolniejszym sprintem."
            ],
            scoring: [
                "Im krótszy czas średni i im mniejszy spadek procentowy czasu – tym lepiej."
            ]
        },

        {
            name: "Skok w dal z miejsca",
            ageCategory: "od 8 do 13 roku życia",
            equipment: "jedna linia, taśma centymetrowa",
            execution: [
                "1. Zawodnik staje dwoma nogami przed linią.",
                "2. Wzdłuż przestrzeni przeznaczonej do skoku rozkładamy taśmę centymetrową.",
                "3. Wyskok jak i lądowanie powinno być wykonane obunóż.",
                "4. Zadaniem zawodnika jest wykonanie jak najdalszego skoku w dal z miejsca.",
                "5. Wynik jest odległością od linii skoku do pięty zawodnika."
            ],
            scoring: [
                "Im dalsza odległość od linii wyskoku – tym lepiej.",
                "Niepoprawne wykonanie testu oznacza dyskwalifikację.",
                "Zawodnik musi wyskoczyć i wylądować obunóż, przy lądowaniu nie może pomagać sobie opierając się rękoma.",
                "Należy wtedy powtórzyć cały test od nowa."
            ]
        },

        {
            name: "Szybkość (30m)",
            ageCategory: "od 13 roku życia wzwyż",
            equipment: "2 linie, fotokomórki",
            execution: [
                "1. Zawodnik staje na linii startu w pozycji wykroczno-zakrocznej (ok. 5cm od linii).",
                "2. Linię startu wyznacza światło fotokomórek.",
                "3. Czas mierzymy fotokomórkami (dokładność min. do 0.01s).",
                "4. Czas mierzymy na dystansie 30m.",
                "5. Opcjonalnie, jeśli mamy wystarczającą ilość fotokomórek, możemy zmierzyć zmierzyć czas na dystansach 5m i 20m."
            ],
            scoring: [
                "Im krótszy czas wykonania – tym lepiej.",
                "Niepoprawne wykonanie testu oznacza dyskwalifikację.",
                "Należy wtedy powtórzyć cały test od nowa."
            ]
        },

        {
            name: "Wyskok dosiężny",
            ageCategory: "od 13 roku życia wzwyż",
            equipment: "tablica, kreda, taśma centymetrowa",
            execution: [
                "1. Zawodnik staje przy tablicy.",
                "2. Wyciąga ramię i dotyka palcami tablicy.",
                "3. Teraz, stojąc bokiem do ściany, robi przysiad.",
                "4. Wyskakuje w górę z przedmachem ramion w tył.",
                "5. Stara się dotknąć tablicy w jak najwyższym punkcie.",
                "6. Teraz mierzymy odległość od punktu zaznaczonego podczas stania w miejscu do punktu zaznaczonego podczas wyskoku."
            ],
            scoring: [
                "5pkt: powyżej 54cm",
                "4pkt: 54-50cm",
                "3pkt: 49-45cm",
                "2pkt: 44-40cm",
                "1pkt: 39-35cm",
                "0pkt: poniżej 35cm"
            ]
        },

        {
            name: "Zwroty z piłką",
            ageCategory: "od 8 do 13 roku życia",
            equipment: "dwie linie (lub pachołki), piłka",
            execution: [
                "1. Zawodnik staje z piłką na jednej z linii.",
                "2. Linie oddalone są od siebie o 5m.",
                "3. Zawodnik jak najszybciej biegnie, prowadząc piłkę w kierunku drugiej linii.",
                "4. Za drugą linią zawodnik ma wykonać zwrot z piłką.",
                "5. Następnie bez przerwy biegnie do poprzedniej linii i znowu wykonuje zwrot.",
                "6. Należy jak najszybciej wykonać 6 zwrotów.",
                "7. Czas liczony jest od momentu wystartowania zawodnika, a zatrzymany w momencie przebiegnięcia zawodnika za linię podczas ostatniego powtórzenia.",
                "8. Piłka za każdym razem musi znajdować się za linią całym swoim obwodem."
            ],
            scoring: [
                "Im krótszy czas wykonania – tym lepiej.",
                "Niepoprawne wykonanie testu oznacza dyskwalifikację.",
                "Należy wtedy powtórzyć cały test od nowa."
            ]
        },

        {
            name: "Żonglerka piłką",
            ageCategory: "od 8 do 13 roku życia",
            equipment: "cztery pachołki (lub inne znaczniki), piłka",
            execution: [
                "1. Zawodnik staje z piłką wewnątrz wyznaczonego pola – kwadrat 5m x 5m.",
                "2. Test polega na podbijaniu piłki dowolną częścią ciała (poza rękoma). Liczymy ilość podbić.",
                "3. Test trwa 30 sekund. Jeśli piłka wyleci poza pole, zawodnik biegnie po nią i kontynuuje test, ale czas nie jest wstrzymywany.",
                "4. Zawodnicy z kategorii wiekowej Orlik i Młodzik rozpoczynają żonglowanie od podniesienia piłki z ziemi nogą oraz żonglują tylko w powietrzu (piłka nie może dotknąć podłoża).",
                "5. Zawodnicy z kategorii wiekowej Żak i Skrzat rozpoczynają żonglowanie od opuszczenia piłki z rąk, a piłka może dotknąć ziemi."
            ],
            scoring: [
                "Im większa ilość podbić piłki – tym lepiej."
            ]
        }
    ]
});
app.controller('usersStatisticController', function($scope, auth, $rootScope, notify, statistic, request) {
    $rootScope.showContent = false;
    $scope.showPreLoad = true;
    $rootScope.actualStats = [];
    $scope.acutalSelectedGroup = 0;
    $scope.acutalSelectedGroupTest = []
    $scope.dataViewAsTable = true;
    $scope.acutalSelectedUserId = '';
    $scope.showTestAndType = false;
    $scope.userForm = 0;

    $(document).ready(function() {
        var wSize = $(window).width();
        if (wSize <= 768) {
            $(".adw").each(function() {
                $(this).removeClass("adwWith");
                $(this).addClass("adwWithout");
            });
        } else {
            $(".adw").each(function() {
                $(this).removeClass("adwWithout");
                $(this).addClass("adwWith");
            });
        }
    });

    $scope.initUsersStats = function() {
        getAllPlayers();
    }

    $(document).off('change', '#selectUserToStat');
    $(document).on('change', '#selectUserToStat', function() {
        $scope.showTestAndType = false;
        $scope.acutalSelectedUserId = $(this).val();

        request.backend('getStats', { usid: $scope.acutalSelectedUserId, tmid: $rootScope.user.tmid }, function(data) {
            $scope.$apply(function() {
                $scope.showContent = true;
                $rootScope.actualStats = data.potential;
                $scope.userForm = data.form
                $scope.showTestAndType = true;
            });
            $('#selectPotential').html('');
            $('#selectPotential').append("<option value='' disabled>Grupy testowe</option>");
            if ($rootScope.actualStats) {
                for (var i = 0; i < $rootScope.actualStats.length; i++) {
                    if (i == 0) {
                        $('#selectPotential').append("<option value='" + i + "'selected>" + $rootScope.actualStats[i].name + "</option>");
                    } else {
                        $('#selectPotential').append("<option value='" + i + "'>" + $rootScope.actualStats[i].name + "</option>");
                    }
                }
            }
            $('select').material_select();
            setTimeout(function() {
                changePotential();
                initMainSummary();
                initMainSummaryRadar();
            }, 50);
        });

    });

    $(document).off('change', '#selectPotential');
    $(document).on('change', '#selectPotential', function() {
        changePotential();
    });

    function changePotential() {
        $scope.showPreLoad = false;
        $scope.$apply(function() {
            $scope.acutalSelectedGroup = $("#selectPotential").val();
            $scope.acutalSelectedGroupTest = $rootScope.actualStats[$scope.acutalSelectedGroup].tests;
        });
        $('.collapsible').collapsible();
        $scope.initChart();
        initPercentChart();
        checkTableScoreProgress();
    }

    $(document).off('change', '#selectDataType');
    $(document).on('change', '#selectDataType', function() {
        $scope.dataViewAsTable = ($('#selectDataType').val() == 'tabele');
        $scope.initChart();
    });

    $(document).off('click', '.optionsToShow');
    $(document).on('click', '.optionsToShow', function() {
        $scope.initChart();
    });

    function initPercentChart() {
        if ($scope.acutalSelectedGroupTest)
            for (var i = 0; i < $scope.acutalSelectedGroupTest.length; i++) {
                if ($scope.acutalSelectedGroupTest[i].id != undefined) {
                    var chart = new Chart($('#chart-percent-' + $scope.acutalSelectedGroupTest[i].id), {
                        type: 'doughnut',
                        data: {
                            datasets: [{
                                data: [$scope.acutalSelectedGroupTest[i].summary, 100 - $scope.acutalSelectedGroupTest[i].summary],
                                backgroundColor: [
                                    '#ec1800',
                                    '#4e4e4e'
                                ]
                            }],
                            labels: [
                                'Aktualna średnia',
                                'Braki do maksimum'
                            ]
                        },
                        options: {
                            tooltips: {
                                callbacks: {
                                    afterLabel: (item)=>{ return `%`},
                                }
                            },
                        }
                    });
                }
            }
    }

    function initMainSummary() {
        if ($scope.acutalSelectedGroupTest) {
            var chart = new Chart($('#main-summary-chart'), {
                type: 'doughnut',
                data: {
                    datasets: [{
                        data: [$scope.userForm, 100 - $scope.userForm],
                        backgroundColor: [
                            '#ec1800',
                            '#4e4e4e'
                        ]
                    }],
                    labels: [
                        'Aktualna forma',
                        'Braki do maksimum'
                    ]
                },
                options: {
                    tooltips: {
                        callbacks: {
                            afterLabel: (item)=>{ return `%`},
                        }
                    },
                }
            });
        }
    }

    function initMainSummaryRadar() {
        var label = [];
        var dataSe = [];
        for (var i = 0; i < $rootScope.actualStats.length; i++) {
            label.push($rootScope.actualStats[i].name);
            dataSe.push($rootScope.actualStats[i].summary);
        }
        var chart = new Chart($('#main-summary-chart-radar'), {
            type: 'radar',
            data: {
                datasets: [{
                    label: "Wyniki w poszczególnych kategoriach",
                    data: dataSe,
                    backgroundColor: 'rgba(236, 24, 0, 0.2)',
                    borderColor: '#ec1800',
                }],
                labels: label,
            },
            options: {
                legend: {
                    position: 'top',
                },
                scale: {
                    ticks: {
                        beginAtZero: true
                    }
                }
            }
        });
    }

    function checkTableScoreProgress() {
        $('.statTable tbody').each(function() {
            var thisBest = $(this).parent().parent().find('.bestSc').first().html();
            var thisWorst = $(this).parent().parent().find('.worstSc').first().html();
            var bestIsMore = false;
            if (thisBest > thisWorst) bestIsMore = true;

            var allTr = $(this).find('tr');
            for (var i = 0; i < allTr.length - 1; i++) {
                var actual = parseFloat($(this).find('tr').eq(i).find('td').eq(0).html());
                var before = parseFloat($(this).find('tr').eq(i + 1).find('td').eq(0).html());
                var progress = actual - before;
                if (progress == 0) continue;
                var word = progress > 0 ? "+" : "-";
                progress = Math.abs(progress);
                var className = (word == '+' ? "tableProgressElementPositive" : "tableProgressElementNegative");
                className = bestIsMore ? className : className == "tableProgressElementPositive" ? "tableProgressElementNegative" : "tableProgressElementPositive";
                progress = progress.toFixed(2);
                $(this).find('tr').eq(i).find('td').eq(0).append("<span class='" + className + "'> " + word + " " + progress + "</span>");
            }
        });
    }

    $scope.initChart = function() {
        moment.locale('pl');
        if (!$scope.dataViewAsTable && $scope.acutalSelectedGroupTest) {
            for (var i = 0; i < $scope.acutalSelectedGroupTest.length; i++) {
                var data = [];
                var labels = [];
                if ($scope.acutalSelectedGroupTest[i].scores != null) {
                    for (var j = 0; j < $scope.acutalSelectedGroupTest[i].scores.length; j++) {
                        var thisDate = moment($scope.acutalSelectedGroupTest[i].scores[j].data);
                        labels.push(thisDate.format('LL'));
                        data.push({
                            t: thisDate,
                            y: $scope.acutalSelectedGroupTest[i].scores[j].wynik
                        });
                    }
                    var chart = new Chart($('#chart-' + $scope.acutalSelectedGroupTest[i].id), {
                        type: 'line',
                        data: {
                            labels: labels,
                            datasets: [{
                                label: "Wyniki testów",
                                data: data,
                                borderColor: '#ec1800'
                            }],
                            options: {
                                scales: {
                                    xAxes: [{
                                        type: 'time',
                                        distribution: 'series',
                                        ticks: {
                                            source: 'labels'
                                        }
                                    }]
                                }
                            }
                        }
                    });
                }
            }
        }
    }

    function getAllPlayers() {
        request.backend('getAllPlayers', { tmid: $rootScope.user.tmid }, function(data) {
            $scope.users = data;
            for (key in data) {
                if (data[key].roleName == 'ZAWODNIK') {
                    $('#selectUserToStat').append('<option value="' + data[key].usid + '">' + data[key].firstname + ' ' + data[key].lastname + '</option>');
                }
            }
            $rootScope.showContent = true;
            Materialize.updateTextFields();
            $('select').material_select();
        });
    }
});
app.controller('tabController', function($scope, auth, $rootScope, notify, request) {
    $scope.lastId = 0;
    $scope.posts = [];
    $scope.maxPost = 5;
    $scope.showContent = false;
    $scope.canGetMorePost = false;

    $scope.morePost = function() {
        $scope.maxPost += 5;
        if ($scope.posts.length > $scope.maxPost) {
            $scope.canGetMorePost = true;
        } else {
            $scope.canGetMorePost = false;
        }
    }

    $scope.moreComment = function(id) {
        for (var i = 0; i < $scope.posts.length; i++) {
            if ($scope.posts[i].psid == id) {
                $scope.posts[i].maxComment += 5;
                return;
            }
        }
    }

    $scope.getLastPost = function() {
        request.backend('getPost', { tmid: $rootScope.user.tmid }, function(data) {
            $scope.$apply(function() {
                $scope.showContent = true;
                $scope.posts = [];
            });
            if (data.length > 5) $scope.canGetMorePost = true;
            for (var i = 0; i < data.length; i++) {
                $scope.$apply(function() {
                    $scope.posts.push(data[i]);
                    $scope.posts[i].maxComment = 2;
                });
            }
            if (data[0] != null && data[0].psid != null) $scope.lastId = data[0].psid;
        });
    }

    $scope.addPost = function() {
        $('#errorNewPost').html("").hide();
        var message = $("#newPostInput").val();
        if (message.length < 5 || message.length > 500) {
            notify.localNotify('Walidacja', 'Wiadomosc musi być dłuższa niż 5 znaków oraz krótsza niż 500');
            return;
        }

        request.backend('addPost', { msg: message, tmid: $rootScope.user.tmid }, function(data) {
            $scope.getLastPost();
            notify.addNew(new notify.Notification($rootScope.user.firstname + " " + $rootScope.user.lastname + " dodał post", null, "#!/tab", true));
        }, 'Twój post został pomyślnie dodany');
    }

    $scope.addComment = function(psid) {
        var message = $("#tx_" + psid).val();
        if (message.length < 5 || message.length > 500) {
            notify.localNotify('Walidacja', 'Komentarz musi zawierać od 5 do 500 znaków');
            return;
        }

        request.backend('addComment', { msg: message, post_id: psid }, function(data) {
            $scope.getLastPost();
        }, 'Twój komentarz został pomyślnie dodany');
    }

    $(document).off('keydown', '.commentPostInput');
    $(document).on('keydown', '.commentPostInput', function(e) {
        if (e.which == 13) {
            var postId = $(this).attr('id').split("_")[1];
            $scope.addComment(postId);
        }
    });


    $scope.deletePost = function(id) {
        request.backend('deletePost', { psid: id }, function(data) {
            $scope.getLastPost();
        }, 'Post został usunięty pomyślnie');
    }

    $scope.deleteComment = function(id) {
        request.backend('deleteComment', { cmid: id }, function(data) {
            $scope.getLastPost();
        }, 'Komentarz został usunięty pomyślnie');
    }

});
app.controller('timetableController', function($scope, auth, $rootScope, notify, request) {
    $scope.showContent = false;
    $scope.events = [];
    $scope.selectedColor = '#de5c8a';

    $scope.initTimetable = function() {
        if ($rootScope.user.tmid && $rootScope.user.tmid != '') {
            request.backend('getTimetableEvent', { tmid: $rootScope.user.tmid }, function(data) {
                $scope.$apply(function() {
                    $scope.events = data;
                    $scope.showContent = true;
                });
            });
        } else {
            $scope.showContent = true;
        }
    }

    $scope.selectColor = function(color) {
        $('.borderSelectedColor').css("border-color", color);
        $scope.selectedColor = color;
    }

    $scope.iniTimetableSettings = function() {
        request.backend('getTimetableEventFull', { tmid: $rootScope.user.tmid }, function(data) {
            $scope.$apply(function() {
                $scope.events = data;
                $scope.showContent = true;
            });
        });
    }

    $scope.deleteTimetableEvent = function(id) {

        $rootScope.showModalWindow("Nieodwracalne usunięcie zajęć z grafiku", function() {
            request.backend('deleteTimetableEvent', { id: id }, function(data) {
                $scope.iniTimetableSettings();
            }, "Usunięto z grafiku");
        });


    }

    $scope.addTimetableEvent = function() {

        var title = $('#addTitleNews').val();
        var day = $('#dayName').val();
        var time = $('#timeEVENT').val();
        var timeEnd = $('#timeEventEnd').val();

        if (!day || !time || !title || !timeEnd) {
            notify.localNotify("Walidacja", "Wpisz wszystkie dane");
            return;
        }

        if (!title || title.length <= 3) {
            notify.localNotify("Walidacja", "Wpisz dłuższy tytuł");
            return;
        }
        var regexp = /([01][0-9]|[02][0-3]):[0-5][0-9]/;
        var correct = (time.search(regexp) >= 0) ? true : false;
        var correctEnd = (timeEnd.search(regexp) >= 0) ? true : false;
        if (!correct || !correctEnd) {
            notify.localNotify("Walidacja", "Błędny format czasu (hh:mm)");
            return;
        }

        request.backend('addTimetableEvent', { title: title, day: day, time: time, color: $scope.selectedColor, tmid: $rootScope.user.tmid, timeEnd: timeEnd }, function(data) {
            $scope.iniTimetableSettings();
        }, "Dodano pomyślnie");
    }

});
app.controller('todoController', function($scope, auth, $rootScope, request, notify) {
    $scope.todoList;
    $scope.selectedColor = '#de5c8a';
    $scope.selectedKey = 1;

    $scope.initToDo = function() {
        getMyTodo();
        setInputColor();
    }

    $scope.addTodo = function() {
        var titlea = $('#todoText').val();
        var colora = $scope.selectedColor;

        if (titlea.length <= 3) {
            notify.localNotify('Walidacja', "Wpisz dłuższy tekst");
            return;
        }

        if (titlea.length > 50) {
            notify.localNotify('Walidacja', "Wpisz mniej tekstu");
            return;
        }

        var dataToSend = { usid: $rootScope.user.id, title: titlea, color: colora };
        request.backend('addTodo', dataToSend, function() {
            $('#todoText').val('');
            $('#todoColor').val('#f44336');
            getMyTodo();
        }, "Twoje zadanie zostało dodane");
    }

    $scope.endTodo = function(todoId) {
        request.backend('endTodo', { tid: todoId }, function() {
            var last = $scope.todoList;
            var newTodo = [];
            for (var i = 0; i < last.length; i++) {
                if (last[i].id != todoId)
                    newTodo.push(last[i]);
            }
            $scope.$apply(function() {
                $scope.todoList = newTodo;
            });
        }, "Twoje zadanie pomyślnie zakończone");
    }

    $scope.selectColor = function(value) {
        $scope.selectedColor = value;
        setInputColor();
    }

    function getMyTodo() {
        request.backend('getTodo', {}, function(data) {
            $scope.$apply(function() {
                $scope.todoList = data;
            });
        });
    }

    function setInputColor() {
        $("#todoText").css("border-color", $scope.selectedColor);
        $("#todoButton").css("border-color", $scope.selectedColor);
    }
});
app.controller('conspectusCreatorController', function($scope, auth, $rootScope, notify, request, $location, $compile) {
    $scope.selectedObjImg = null;
    $scope.selectedField = null;
    $scope.selectedArrow = null;
    $scope.arrowPointCount = 0;
    $scope.shapePointCount = 0;
    $scope.shapePoint = [];
    $scope.arrowPoint = [];
    $scope.lastSelected = null;
    $scope.fieldImage = null;
    $scope.onlyPlayer = false;
    $scope.orientation = 'landscape';
    $scope.animId = -1;
    $scope.turnOnHelperNet = false;
    $scope.turnOnRotation = false;
    $scope.turnOnHekperFullScreen = false;
    $scope.fullElement = null;
    $scope.iloscklatekPomiedzyGlownymi = 40;
    $scope.jakoscAnimacji = 40;
    $scope.iloscfps = 30;
    $scope.selectedItemList = [];
    $scope.startPointSelectShape = null;
    $scope.endPointSelectShape = null;
    $scope.canAddItem = false;
    var multiDragPositionStart = { x: 0, y: 0 };



    $("#animCreator").niceScroll({
        cursorborderradius: '0px', // Scroll cursor radius
        cursorborder: 'none',
        scrollspeed: 60, // scrolling speed
        emulatetouch: true,
        hwacceleration: true,
        smoothscroll: true,
        bouncescroll: true,
        mousescrollstep: 30, // scrolling speed with mouse wheel (pixel)
        background: 'transparent', // The scrollbar rail color
        cursorwidth: '4px', // Scroll cursor width
        cursorcolor: '#a51100'
    });

    $scope.objConfig = {
        player: {
            confName: "player",
            text: " ",
            selectedColorText: "rgb(255,255,255)",
            selectedTextSize: "17",
            selectedColor: {
                background: "rgb(255, 255, 255)",
                border: "rgb(255, 255, 255)"
            },
            colors: [{
                background: "rgb(0,126,255)",
                border: "rgb(255, 255, 255)"
            }, {
                background: "rgb(144, 0, 255)",
                border: "rgb(255, 255, 255)"
            }, {
                background: "rgb(174, 174, 174)",
                border: "rgb(255, 255, 255)"
            }, {
                background: "rgb(255, 48, 0)",
                border: "rgb(255, 255, 255)"
            }, {
                background: "rgb(255, 204, 0)",
                border: "rgb(255, 255, 255)"
            }, {
                background: "rgb(255, 255, 255)",
                border: "rgb(255, 255, 255)"
            }]
        },
        arrow: {
            confName: "arrow",
            text: " ",
            selectedColorText: "rgb(255,255,255)",
            selectedTextSize: "17",
            arrowTypes: ["Podanie", "Prowadzenie piłki", "Bieg bez piłki", "Linia pomocnicza", "Odległość zawodników", "Strzał"],
            arrowType: "Podanie"
        },
        shape: {
            confName: "shape",
            text: " ",
            selectedColorText: "rgb(255,255,255)",
            selectedTextSize: "17",
            selectedColor: {
                border: "rgb(255, 255, 255)",
                background: "rgba(255, 255, 255, 0.4)"
            },
            colors: [{
                border: "rgb(0, 126, 255)",
                background: "rgba(0, 126, 255, 0.4)"
            }, {
                border: "rgb(202, 203, 203)",
                background: "rgba(202, 203, 203, 0.4)"
            }, {
                border: "rgb(0, 126, 255)",
                background: "rgba(0, 126, 255, 0.4)"
            }, {
                border: "rgb(144, 0, 255)",
                background: "rgba(144, 0, 255, 0.4)"
            }, {
                border: "rgb(255, 48, 0)",
                background: "rgba(255, 48, 0, 0.4)"
            }, {
                border: "rgb(255, 204, 0)",
                background: "rgba(255, 204, 0, 0.4)"
            }]
        },
        ball: {
            confName: "ball",
            text: " ",
            selectedColorText: "rgb(255,255,255)",
            selectedTextSize: "17",
            selectedColor: {
                background: "rgb(255, 255, 255)",
                border: "rgb(0, 0, 0)"
            },
            colors: [{
                background: "rgb(254,100,62)",
                border: "rgb(0, 0, 0)"
            }, {
                background: "rgb(255, 255, 255)",
                border: "rgb(0, 0, 0)"
            }]
        },
        cones: {
            confName: "cones",
            text: " ",
            selectedColorText: "rgb(255,255,255)",
            selectedTextSize: "17",
            selectedColor: {
                background: "rgb(255, 255, 255)",
                border: "rgb(255,255,255)"
            },
            colors: [{
                background: "rgb(255, 255, 255)",
                border: "rgb(255,255,255)"
            }, {
                background: "rgb(255, 204, 0)",
                border: "rgb(255,255,255)"
            }, {
                background: "rgb(255, 48, 0)",
                border: "rgb(255,255,255)"
            }, {
                background: "rgb(174, 174, 174)",
                border: "rgb(255,255,255)"
            }, {
                background: "rgb(144, 0, 255)",
                border: "rgb(255,255,255)"
            }, {
                background: "rgb(0, 126, 255)",
                border: "rgb(255,255,255)"
            }]
        },
        rings: {
            confName: "rings",
            text: " ",
            selectedColorText: "rgb(255,255,255)",
            selectedTextSize: "17",
            selectedColor: {
                background: "rgb(255, 255, 255)",
                border: "rgb(255, 255, 255)"
            },
            colors: [{
                background: "rgb(0,126,255)",
                border: "rgb(255, 255, 255)"
            }, {
                background: "rgb(144, 0, 255)",
                border: "rgb(255, 255, 255)"
            }, {
                background: "rgb(174, 174, 174)",
                border: "rgb(255, 255, 255)"
            }, {
                background: "rgb(255, 48, 0)",
                border: "rgb(255, 255, 255)"
            }, {
                background: "rgb(255, 204, 0)",
                border: "rgb(255, 255, 255)"
            }, {
                background: "rgb(255, 255, 255)",
                border: "rgb(255, 255, 255)"
            }]
        },
        flags: {
            confName: "flags",
            text: " ",
            selectedColorText: "rgb(255,255,255)",
            selectedTextSize: "17",
            selectedColor: {
                background: "rgb(255, 255, 255)",
                border: "rgb(255, 255, 255)"
            },
            colors: [{
                background: "rgb(0,126,255)",
                border: "rgb(255, 255, 255)"
            }, {
                background: "rgb(144, 0, 255)",
                border: "rgb(255, 255, 255)"
            }, {
                background: "rgb(174, 174, 174)",
                border: "rgb(255, 255, 255)"
            }, {
                background: "rgb(255, 48, 0)",
                border: "rgb(255, 255, 255)"
            }, {
                background: "rgb(255, 204, 0)",
                border: "rgb(255, 255, 255)"
            }, {
                background: "rgb(255, 255, 255)",
                border: "rgb(255, 255, 255)"
            }]
        },
        poles: {
            confName: "poles",
            text: " ",
            selectedColorText: "rgb(255,255,255)",
            selectedTextSize: "17",
            selectedColor: {
                background: "rgb(255, 255, 255)",
                border: "rgb(255, 255, 255)"
            },
            colors: [{
                background: "rgb(0,126,255)",
                border: "rgb(255, 255, 255)"
            }, {
                background: "rgb(144, 0, 255)",
                border: "rgb(255, 255, 255)"
            }, {
                background: "rgb(174, 174, 174)",
                border: "rgb(255, 255, 255)"
            }, {
                background: "rgb(255, 48, 0)",
                border: "rgb(255, 255, 255)"
            }, {
                background: "rgb(255, 204, 0)",
                border: "rgb(255, 255, 255)"
            }, {
                background: "rgb(255, 255, 255)",
                border: "rgb(255, 255, 255)"
            }]
        },
        onlyText: {
            confName: "onlyText",
            text: " ",
            selectedColorText: "rgb(255,255,255)",
            selectedTextSize: "17"
        }
    };

    $scope.cwName = '';
    $scope.arrowArrayPostionAnchor = [];
    $scope.shapeArrayPostionAnchor = [];
    $scope.gif = '';
    $scope.tags = '';
    $scope.cwFieldType = '';
    $scope.cwMaxTime = 0;
    $scope.cwMinTime = 0;
    $scope.cwMaxPerson = 0;
    $scope.cwMinPerson = 0;
    $scope.cwOps = '';
    $scope.cwWsk = '';
    $scope.showAnimCreator = false;
    $scope.selectedObjConfig = [];

    $scope.initObjList = function() {
        request.backend('getConspectAnimObj', {}, function(data) {
            $scope.$apply(function() {
                if (data.length > 0) {
                    for (var i = 0; i < data.length; i++) {
                        var content = $compile(data[i].category)($scope);
                        $('#categoryFromItemBox').append(content);
                        if (data[i].obj) {
                            var content = $compile(data[i].obj)($scope);
                            $('#itemBoxFromCat').append(content);
                        }
                    }
                    $(document).ready(function() {
                        $('.tooltipped').tooltip({
                            delay: 50
                        });
                        $('.collapsible').collapsible();
                    });

                }
            });
        });
    }

    $scope.initBackPrompt = function(){
        $scope.$on("$locationChangeStart", function(event) {
            if (!confirm('Niezapisane zmiany nie zostaną zapisane! Na pewno chcesz wyjść ?')) {
                event.preventDefault();
            }else{
                $(window).off('beforeunload');
            }
        });
        $(window).off('beforeunload');
        $(window).on('beforeunload',function(){
            return confirm('Niezapisane zmiany nie zostaną zapisane! Na pewno chcesz wyjść ?');
        });
    };

    if ($rootScope.idFromAnimConspectToEdit && $rootScope.idFromAnimConspectToEdit != '' && $rootScope.idFromAnimConspectToEdit != null) {
        $scope.animId = $rootScope.idFromAnimConspectToEdit;
        $rootScope.idFromAnimConspectToEdit = null;
        loadAnimation(function() {
            $scope.isSelectedField = true;
            $scope.showAnimCreator = true;
        });
    }

    $scope.mouseActionType = {
        MOVE: 0,
        OBJECT_ADD: 1,
        ARROW_ADD: 2,
        FIELD_LIST: 3,
        SHAPE_ADD: 4
    }
    $scope.arrowType = {
        FULL_2: 1,
        FULL_3: 2,
        STRIPED_2: 3,
        STRIPED_3: 4,
    };
    $scope.shapeType = {
        WHITE_3: 1,
        WHITE_4: 2,
        WHITE_5: 3,

        GREY_3: 4,
        GREY_4: 5,
        GREY_5: 6,

        BLUE_3: 7,
        BLUE_4: 8,
        BLUE_5: 9,

        PURPLE_3: 10,
        PURPLE_4: 11,
        PURPLE_5: 12,

        ORANGE_3: 13,
        ORANGE_4: 14,
        ORANGE_5: 15,

        RED_3: 16,
        RED_4: 17,
        RED_5: 18,
    };
    var stageWidth = 800;
    var stageHeight = stageWidth * 0.6;
    var selectedFrame = new Konva.Stage({
        container: 'canvasPlayerContainer',
        width: stageWidth,
        height: stageHeight
    });
    var saveNow = false;
    var customObjectPerFrame = [];
    var allObjectPerFrame = [];
    $scope.animName = '';
    allObjectPerFrame.push({
        arrow: [],
        obj: [],
        shapes: [],
        text: []
    });
    $scope.selectedShape = null;
    var currentObjPerFrame = 0;
    var allAnimFrame = [];
    var anchorHistory = [];
    var actualPlayerFrame = 0;
    var pauseAnim = false;
    var fieldLayer = null;
    var mainLayer = null;
    var curveLayer = null;
    var selectShapeLayer = null;
    var anchorLayer = null;
    var lineLayer = null;
    var quadCurves = [];
    var somethingIsDraw = false;
    var isPlayerOpen = false;
    $scope.shiftPressed = false;

    $(window).resize(function() {
        resize();
    });

    $(window).on("orientationchange", function(event) {
        $scope.orientation = $(window).width() > $(window).height() ? 'sd' : 'landscape';
        resize();
    });

    $scope.actualMouseAction = $scope.mouseActionType.FIELD_LIST;

    $scope.selectArrow = function(arrowTypw) {
        $scope.actualMouseAction = $scope.mouseActionType.ARROW_ADD;
        $scope.arrowPointCount = 0;
        $scope.arrowPoint = [];
    }

    $scope.selectShape = function(shapeType) {
        $scope.selectedShape = shapeType;
        $scope.shapePointCount = 0;
        $scope.shapePoint = [];
    }

    $scope.changeCategories = function(categoryType) {
        $scope.actualMouseAction = categoryType;
        if ($scope.actualMouseAction == $scope.mouseActionType.MOVE) {
            var shapes = selectedFrame.find(".movementObject");
            shapes.each(function(shape) {
                shape.draggable(true);
            });
        } else {
            var shapes = selectedFrame.find(".movementObject");
            shapes.each(function(shape) {
                shape.draggable(false);
            });
        }
        if ($scope.actualMouseAction == $scope.mouseActionType.ARROW_ADD) {
            $scope.selectedArrow = null;
        } else if ($scope.actualMouseAction == $scope.mouseActionType.SHAPE_ADD) {
            $scope.selectedShape = null;
        }

        $('.categories').each(function() {
            $(this).css("border-color", "");
        });
        $('.categories').eq(0).css("border-color", "rgb(191, 72, 36)");
    }

    selectedFrame.on('contentClick contentTap', function(e) {
        clickOnContent();
    })

    selectedFrame.on('mousedown touchstart', function(e) {
        onMuseDown();
    });

    selectedFrame.on('mousemove touchmove', function(e) {
        onMuseMove();
    });

    selectedFrame.on('mouseup touchend', function(e) {
        onMuseUp();
    });

    $(document).ready(function() {
        $("#animCreator").off('keydown');
        $("#animCreator").off('keyup');
        $("#animCreator").on('keydown', function(e) {
            if (e.keyCode == 16) {
                $scope.shiftPressed = true;
            }
        });
        $("#animCreator").on('keyup', function(e) {
            $scope.shiftPressed = false;
            if (e.keyCode == 46) {
                $rootScope.showModalWindow("Nieodwracalnie usunie zaznaczone obiekty oraz wszystkie ich wystąpienia w następnych klatkach animacji", function() {
                    deleteCurrent();
                });
            }
        });
    });

    function onMuseUp() {
        if ($scope.actualMouseAction == $scope.mouseActionType.MOVE && $scope.startPointSelectShape != null && $scope.endPointSelectShape != null && !somethingIsDraw) {
            selectFromMultiSelectShape();
        }
    }

    function onMuseMove() {
        if ($scope.actualMouseAction == $scope.mouseActionType.MOVE && $scope.startPointSelectShape != null) {
            var scale = selectedFrame.getAttr('scaleX');
            var mousePos = selectedFrame.getPointerPosition();
            $scope.endPointSelectShape = {
                x: mousePos.x / scale,
                y: mousePos.y / scale
            }
            if (!somethingIsDraw) redrawMultiSelectShape();
        }
    }

    function onMuseDown() {
        if ($scope.actualMouseAction == $scope.mouseActionType.MOVE) {
            var scale = selectedFrame.getAttr('scaleX');
            var mousePos = selectedFrame.getPointerPosition();
            $scope.startPointSelectShape = {
                x: mousePos.x / scale,
                y: mousePos.y / scale
            }
        }
    }

    $(document).off('click touch', '.categories');
    $(document).on('click touch', '.categories', function() {
        if ($(window).width() > 1000) {
            $(".itemBoxWithItem").first().width(750);
        } else {
            // $(".itemBoxWithItem").first().width($(window).width() - 200);
        }
        $('.categories').each(function() {
            $(this).css("border-color", "");
        });

        $('.categoryItems').each(function() {
            $(this).css("border-color", "");
        });
        $(this).css("border-color", "rgb(191, 72, 36)");
        $scope.selectedObjConfig = $(this).data('config') ? $scope.objConfig[$(this).data('config')] : [];
        $scope.canAddItem = false;
    })

    $(document).off('click touch', '.confTitle');
    $(document).on('click touch', '.confTitle', function() {
        if ($(this).hasClass("hideIs")) {
            $(this).removeClass("hideIs");
            $(this).addClass("showIs");
            $(this).next('.configleftContent').first().stop().show('slide', { direction: "up" }, 300);
        } else {
            $(this).addClass("hideIs");
            $(this).removeClass("showIs");
            $(this).next('.configleftContent').first().stop().hide('slide', { direction: "up" }, 300);
        }
    })

    $(document).off('click touch', '.categoryItems');
    $(document).on('click touch', '.categoryItems', function() {
        $scope.arrowPointCount = 0;
        $scope.arrowPoint = [];
        $('.categoryItems').each(function() {
            $(this).css("border-color", "");
        });
        $(this).css("border-color", "rgb(191, 72, 36)");

        if ($scope.actualMouseAction == $scope.mouseActionType.OBJECT_ADD) {
            $scope.selectedObjImg = new Image();
            $scope.selectedObjImg.src = $(this).find('img').attr('src');
        }
        $scope.canAddItem = true;
        $scope.selectedObjConfig = $(this).find('img').data('config') ? $scope.objConfig[$(this).find('img').data('config')] : [];

    })

    $scope.showObjConfig = function() {

        var settingsDiv = "<div class='lastSelectedConfigContent'><p class='confInfo' >Brak dostępnych opcji konfiguracyjnych</p></div>";
        $("#lastSelectedConfig").first().html("");
        $("#lastSelectedConfig").first().append(settingsDiv);
        if (!$scope.lastSelected && $scope.selectedItemList.length <= 0) return;
        if (!$scope.lastSelected) return;
        var config = $scope.lastSelected.getAttr("config");
        if (!config) return;
        if (config.text || config.colors || config.arrowTypes)
            $('.lastSelectedConfigContent').first().html("");
        //text
        if (config.text) {
            var textEdit = "<div class='configColorPickerForText'>";

            textEdit += "<p class='confInfo' style='width: 100%'>Kolor czcionki:</p>"
            textEdit += "<div class='configColorText' style='background-color:rgb(255,255,255); border-color:rgb(0,0,0)'></div>";
            textEdit += "<div class='configColorText' style='background-color:rgb(0,0,0); border-color:rgb(0,0,0)'></div>";
            textEdit += "<div class='configColorText' style='background-color:rgb(255,82,82); border-color:rgb(0,0,0)'></div>";
            textEdit += "<div class='configColorText' style='background-color:rgb(253,216,53); border-color:rgb(0,0,0)'></div>";
            textEdit += "</div>";

            textEdit += "<div class='textSizeChanger'>"
            textEdit += "<p class='confInfo' style='padding-bottom:0'>Rozmiar czcionki:</p>"
            textEdit += "<input style='height: 30px; margin-bottom:10px;text-align:center; color: #adadad' class='configTextSize' type='number' class='validate' value='" + config.selectedTextSize + "'></input>";
            textEdit += "</div>";

            textEdit += "<p class='confInfo' style='padding-bottom:0'>Tekst przy obiekcie</p>";
            textEdit += "<div style='margin-top:0' class='input-field col s12'>";
            textEdit += "<input style='height: 30px; margin-bottom:0;text-align:center' class='configEditText' placeholder='Treść' type='text' class='validate' value='" + config.text + "'></input>";
            textEdit += "</div>";
            $('.lastSelectedConfigContent').first().append(textEdit);
            var thisObj = $scope.lastSelected;
            thisObj = $scope.selectedItemList.length > 0 ? $scope.selectedItemList : thisObj;

            $(document).off('click', '.configColorText');
            $(document).on('click', '.configColorText', function() {
                if ($.isArray(thisObj)) {
                    for (let i = 0; i < thisObj.length; i++) {
                        var configNow = thisObj[i].getAttr('config');
                        configNow.selectedColorText = ($(this).css("background-color"));
                        thisObj[i].setAttr('config', configNow);
                        var text = thisObj[i].getAttr('textObj');
                        text.setAttr("fill", ($(this).css("background-color")));
                        configTextUpdate(thisObj[i]);
                    }
                } else {
                    var configNow = thisObj.getAttr('config');
                    configNow.selectedColorText = ($(this).css("background-color"));
                    thisObj.setAttr('config', configNow);
                    var text = thisObj.getAttr('textObj');
                    text.setAttr("fill", ($(this).css("background-color")));
                    configTextUpdate(thisObj);
                }
                mainLayer.draw();
            });

            $(document).off('change', '.configTextSize');
            $(document).on('change', '.configTextSize', function() {
                if ($.isArray(thisObj)) {
                    for (let i = 0; i < thisObj.length; i++) {
                        var configNow = thisObj[i].getAttr('config');
                        configNow.selectedTextSize = $(this).val();
                        thisObj[i].setAttr('config', configNow);
                        var text = thisObj[i].getAttr('textObj');
                        text.setAttr("fontSize", $(this).val());
                        text.setAttr("offsetY", 30 - $(this).val());
                        configTextUpdate(thisObj[i]);
                    }
                } else {
                    var configNow = thisObj.getAttr('config');
                    configNow.selectedTextSize = $(this).val();
                    thisObj.setAttr('config', configNow);
                    var text = thisObj.getAttr('textObj');
                    text.setAttr("fontSize", $(this).val());
                    text.setAttr("offsetY", 30 - $(this).val());
                    configTextUpdate(thisObj);
                }
                mainLayer.draw();
            });

            $(document).off('change', '.configEditText');
            $(document).on('change', '.configEditText', function() {
                if ($.isArray(thisObj)) {
                    for (let i = 0; i < thisObj.length; i++) {
                        var val = $(this).val();
                        var actualConf = thisObj[i].getAttr("config");
                        actualConf.text = val;
                        thisObj[i].setAttr("config", actualConf);

                        var textObj = thisObj[i].getAttr("textObj");
                        textObj.setAttr("text", actualConf.text);
                        thisObj[i].setAttr("textObj", textObj);

                        configTextUpdate(thisObj[i]);
                    }
                } else {
                    var val = $(this).val();
                    var actualConf = thisObj.getAttr("config");
                    actualConf.text = val;
                    thisObj.setAttr("config", actualConf);

                    var textObj = thisObj.getAttr("textObj");
                    textObj.setAttr("text", actualConf.text);
                    thisObj.setAttr("textObj", textObj);

                    configTextUpdate(thisObj);
                }
                mainLayer.draw();
            });
        }

        //createColorPicker
        if (config.colors) {
            var colorPicker = "<div class='configColorPicker'>";
            colorPicker += "<p class='confInfo'>Wersja kolorystyczna obiektu:</p>"
            for (var i = 0; i < config.colors.length; i++) {
                colorPicker += "<div class='configColor' style='background-color:" + (config.colors[i].background) + "; border-color:" + (config.colors[i].border) + "'></div>";
            }
            colorPicker += "</div>";
            $('.lastSelectedConfigContent').first().append(colorPicker);

            var thisObj = $scope.lastSelected;
            thisObj = $scope.selectedItemList.length > 0 ? $scope.selectedItemList : thisObj;

            $(document).off('click', '.configColor');
            $(document).on('click', '.configColor', function() {
                if ($.isArray(thisObj)) {
                    for (let i = 0; i < thisObj.length; i++) {
                        var configNow = thisObj[i].getAttr('config');
                        configNow.selectedColor = {
                            background: ($(this).css("background-color")),
                            border: ($(this).css("border-color"))
                        };
                        thisObj[i].setAttr('config', configNow);
                        var back = $(this).css("background-color").replace(/ /g, "");
                        var border = $(this).css("border-color").replace(/ /g, "");
                        // osobne zmiany dla kazdego typu obiektu TODO
                        switch (thisObj[i].getAttr("name")) {
                            case "movementObject":
                                break;
                            case "shapes":
                                thisObj[i].setAttr('stroke', border);
                                thisObj[i].setAttr('fill', back);
                                break;
                            default:
                                break;
                        }
                        configColorUpdate(thisObj[i]);
                    }
                } else {
                    var configNow = thisObj.getAttr('config');
                    configNow.selectedColor = {
                        background: ($(this).css("background-color")),
                        border: ($(this).css("border-color"))
                    };
                    thisObj.setAttr('config', configNow);
                    var back = $(this).css("background-color").replace(/ /g, "");
                    var border = $(this).css("border-color").replace(/ /g, "");
                    // osobne zmiany dla kazdego typu obiektu TODO
                    switch (thisObj.getAttr("name")) {
                        case "movementObject":
                            break;
                        case "shapes":
                            thisObj.setAttr('stroke', border);
                            thisObj.setAttr('fill', back);
                            break;
                        default:
                            break;
                    }
                    configColorUpdate(thisObj);
                }
                mainLayer.draw();
            });
        }

        //arrow type
        if (config.arrowTypes) {
            var arrowPicker = "<div class='configArrowTypes'>";
            arrowPicker += "<form style='display: table;margin: 10px;'>"
            arrowPicker += "<p class='confInfo'>Typ akcji:</p>"
            for (var i = 0; i < config.arrowTypes.length; i++) {
                if (config.arrowTypes[i] == config.arrowType) add = "checked='checked'";
                else add = '';
                arrowPicker += "<p><input name='arrowTypeGroup' " + add + " type='radio' id='" + config.arrowTypes[i] + "' /><label for='" + config.arrowTypes[i] + "'>" + config.arrowTypes[i] + "</label></p>";
            }
            arrowPicker += "</form>";
            arrowPicker += "</div>";

            var thisObj = $scope.lastSelected;
            thisObj = $scope.selectedItemList.length > 0 ? $scope.selectedItemList : thisObj;

            $('.lastSelectedConfigContent').first().append(arrowPicker);
            $('input[name=arrowTypeGroup]').on('change', function() {
                if ($.isArray(thisObj)) {
                    for (let i = 0; i < thisObj.length; i++) {
                        config.arrowType = $(this).attr("id");
                        thisObj[i].setAttr("config", config);
                        configTextUpdate(thisObj[i]);
                    }
                } else {
                    config.arrowType = $(this).attr("id");
                    thisObj.setAttr("config", config);
                    configTextUpdate(thisObj);
                }
                mainLayer.draw();
            });
        }
    }

    function configTextUpdate(obj) {
        var id = obj.getAttr("id");
        var config = obj.getAttr("config");
        var txt = obj.getAttr("textObj");
        for (var i = 0; i < allObjectPerFrame.length; i++) {
            for (var j = 0; j < allObjectPerFrame[i].obj.length; j++) {
                if (allObjectPerFrame[i].obj[j].getAttr("id") == id) {
                    allObjectPerFrame[i].obj[j].setAttr("config", config);
                    if (txt) {
                        var thisTxt = allObjectPerFrame[i].obj[j].getAttr("textObj");
                        thisTxt.setAttr('fill', txt.getAttr('fill'));
                        thisTxt.setAttr('text', txt.getAttr('text'));
                        thisTxt.setAttr('fontSize', txt.getAttr('fontSize'));
                    }
                    break;
                }
            }
            for (var j = 0; j < allObjectPerFrame[i].arrow.length; j++) {
                if (allObjectPerFrame[i].arrow[j].getAttr("id") == id) {
                    allObjectPerFrame[i].arrow[j].setAttr("config", config);
                    if (txt) {
                        var thisTxt = allObjectPerFrame[i].arrow[j].getAttr("textObj");
                        thisTxt.setAttr('fill', txt.getAttr('fill'));
                        thisTxt.setAttr('text', txt.getAttr('text'));
                        thisTxt.setAttr('fontSize', txt.getAttr('fontSize'));
                    }
                    break;
                }
            }
            for (var j = 0; j < allObjectPerFrame[i].shapes.length; j++) {
                if (allObjectPerFrame[i].shapes[j].getAttr("id") == id) {
                    allObjectPerFrame[i].shapes[j].setAttr("config", config);
                    if (txt) {
                        var thisTxt = allObjectPerFrame[i].shapes[j].getAttr("textObj");
                        thisTxt.setAttr('fill', txt.getAttr('fill'));
                        thisTxt.setAttr('text', txt.getAttr('text'));
                        thisTxt.setAttr('fontSize', txt.getAttr('fontSize'));
                    }
                    break;
                }
            }
        }
    }

    function configColorUpdate(obj) {
        var id = obj.getAttr("id");
        var config = obj.getAttr("config");

        for (var i = 0; i < allObjectPerFrame.length; i++) {
            for (var j = 0; j < allObjectPerFrame[i].obj.length; j++) {
                if (allObjectPerFrame[i].obj[j].getAttr("id") == id) {
                    allObjectPerFrame[i].obj[j].setAttr("config", config);
                    var src = allObjectPerFrame[i].obj[j].getAttr("image").src;
                    var srcExt = src.substring(src.length - 4, src.length);
                    var back = allObjectPerFrame[i].obj[j].getAttr("config").selectedColor.background;
                    var border = allObjectPerFrame[i].obj[j].getAttr("config").selectedColor.border;
                    src = src.split("-rgb")[0];
                    src = "" + src + "-" + back + border + srcExt;
                    src = src.replace(/ /g, "");
                    src = src.replace(/\%20/g, "");
                    var img = new Image();
                    img.onload = function() {
                        mainLayer.draw();
                    }
                    img.src = src;
                    allObjectPerFrame[i].obj[j].setAttr("image", img);
                }
            }
            for (var j = 0; j < allObjectPerFrame[i].arrow.length; j++) {
                if (allObjectPerFrame[i].arrow[j].getAttr("id") == id) {
                    allObjectPerFrame[i].arrow[j].setAttr("config", config);
                }
            }
            for (var j = 0; j < allObjectPerFrame[i].shapes.length; j++) {
                if (allObjectPerFrame[i].shapes[j].getAttr("id") == id) {
                    allObjectPerFrame[i].shapes[j].setAttr("config", config);
                }
            }
        }
    }

    $(document).off('click touch', '.soccerField');
    $(document).on('click touch', '.soccerField', function() {
        $('.soccerField').each(function() {
            $(this).css("transform", "");
        });
        selectField($(this).find('img').attr('src'));
    })

    function selectField(src) {
        $scope.$apply(function() {
            $scope.selectedField = new Image();
            $scope.fieldImage = $scope.selectedField;
            $scope.selectedField.onload = function() {
                $scope.fieldImage = $scope.selectedField;
                drawNewStage();
            }
            $scope.actualMouseAction = $scope.mouseActionType.MOVE;
            $scope.selectedField.src = src;
        });
    }

    $(document).off('click touch', '#canActionPlay');
    $(document).on('click touch', '#canActionPlay', function() {
        showPlayer();
    });

    $(document).off('change', '#rotationConfig');
    $(document).on('change', '#rotationConfig', function() {
        rotateCurrent($(this).val());
        showInConfigObjData();
    });

    $(document).off('change', '#scaleConfig');
    $(document).on('change', '#scaleConfig', function() {
        scaleCurrent($(this).val());
        showInConfigObjData();
    });

    $(document).off('click touch', '#canActionDel');
    $(document).on('click touch', '#canActionDel', function() {
        $rootScope.showModalWindow("Nieodwracalnie usunie zaznaczone obiekty oraz wszystkie ich wystąpienia w następnych klatkach animacji", function() {
            deleteCurrent();
        });
    });

    function deleteCurrent() {
        if ($scope.lastSelected && $scope.selectedItemList.length <= 0) {
            deleteItem($scope.lastSelected);
        } else if ($scope.selectedItemList.length > 0) {
            for (let i = 0; i < $scope.selectedItemList.length; i++) {
                deleteItem($scope.selectedItemList[i]);
            }
        }
    }

    function deleteItem(item) {
        if (!item) return;

        $scope.$apply(function() {
            selectObjStyle(null);
            $scope.changeCategories($scope.mouseActionType.MOVE);
        });

        var id = item.getAttr('id');
        for (let c = currentObjPerFrame; c < allObjectPerFrame.length; c++) {
            var actual = -1;
            var actualItem = null;
            for (var i = 0; i < allObjectPerFrame[c].obj.length; i++) {
                var obb = allObjectPerFrame[c].obj[i].getAttr('id');
                if (obb == id) {
                    actual = i;
                    actualItem = allObjectPerFrame[c].obj[i];
                    break;
                }
            }
            if (actual < 0) {
                for (var i = 0; i < allObjectPerFrame[c].arrow.length; i++) {
                    var obb = allObjectPerFrame[c].arrow[i].getAttr('id');
                    if (obb == id) {
                        actual = i;
                        actualItem = allObjectPerFrame[c].arrow[i];
                        break;
                    }
                }
                if (actual >= 0) allObjectPerFrame[c].arrow.splice(actual, 1);
                else {
                    for (var i = 0; i < allObjectPerFrame[c].shapes.length; i++) {
                        var obb = allObjectPerFrame[c].shapes[i].getAttr('id');
                        if (obb == id) {
                            actual = i;
                            actualItem = allObjectPerFrame[c].shapes[i];
                            break;
                        }
                    }
                    if (actual >= 0) allObjectPerFrame[c].shapes.splice(actual, 1);
                    else {
                        for (var i = 0; i < allObjectPerFrame[c].text.length; i++) {
                            var obb = allObjectPerFrame[c].text[i].getAttr('id');
                            if (obb == id) {
                                actual = i;
                                actualItem = allObjectPerFrame[c].text[i];
                                break;
                            }
                        }
                        if (actual >= 0) allObjectPerFrame[c].text.splice(actual, 1)
                    }
                }
            } else {
                allObjectPerFrame[c].obj.splice(actual, 1);
            }
            deleteAnchor(c, id);
            deleteAnchor(c + 1, id);
            if (anchorLayer != null) {
                anchorLayer.destroy();
                anchorLayer = null;
            }
            anchorLayer = new Konva.Layer();
            selectedFrame.add(anchorLayer);
            if (actualItem) {
                var txt = actualItem.getAttr("textObj");
                if (txt) txt.destroy();
                actualItem.destroy();
                $scope.$apply(function() {
                    actualItem = null;
                });
            }
        }
        selectedFrame.draw();
    }

    function rotateCurrent(rot) {
        if ($scope.lastSelected && $scope.selectedItemList.length <= 0) {
            var thisId = $scope.lastSelected.getAttr("id");
            for (let y = ($scope.turnOnRotation ? currentObjPerFrame : 0); y < ($scope.turnOnRotation ? currentObjPerFrame + 1 : allObjectPerFrame.length); y++) {
                for (let u = 0; u < allObjectPerFrame[y].obj.length; u++) {
                    if (allObjectPerFrame[y].obj[u].getAttr("id") == thisId) {
                        allObjectPerFrame[y].obj[u].setAttr("rotation", rot);
                        break;
                    }
                }
            }
        } else if ($scope.selectedItemList.length > 0) {
            for (let i = 0; i < $scope.selectedItemList.length; i++) {
                var thisId = $scope.selectedItemList[i].getAttr("id");
                for (let y = ($scope.turnOnRotation ? currentObjPerFrame : 0); y < ($scope.turnOnRotation ? currentObjPerFrame + 1 : allObjectPerFrame.length); y++) {
                    for (let u = 0; u < allObjectPerFrame[y].obj.length; u++) {
                        if (allObjectPerFrame[y].obj[u].getAttr("id") == thisId) {
                            allObjectPerFrame[y].obj[u].setAttr("rotation", rot);
                            break;
                        }
                    }
                }
            }
        }
        selectedFrame.draw();
    }

    function scaleCurrent(scale) {
        var newScale = {
            x: scale,
            y: scale
        };
        if ($scope.lastSelected && $scope.selectedItemList.length <= 0) {
            var thisId = $scope.lastSelected.getAttr("id");
            for (let y = ($scope.turnOnRotation ? currentObjPerFrame : 0); y < ($scope.turnOnRotation ? currentObjPerFrame + 1 : allObjectPerFrame.length); y++) {
                for (let u = 0; u < allObjectPerFrame[y].obj.length; u++) {
                    if (allObjectPerFrame[y].obj[u].getAttr("id") == thisId) {
                        allObjectPerFrame[y].obj[u].scale(newScale);
                        var txt = allObjectPerFrame[y].obj[u].getAttr("textObj");
                        txt.setAttr('y', allObjectPerFrame[y].obj[u].getAttr('y') + (allObjectPerFrame[y].obj[u].height() / 2) * newScale.x);
                        break;
                    }
                }
            }
        } else if ($scope.selectedItemList.length > 0) {
            for (let i = 0; i < $scope.selectedItemList.length; i++) {
                var thisId = $scope.selectedItemList[i].getAttr("id");

                for (let y = ($scope.turnOnRotation ? currentObjPerFrame : 0); y < ($scope.turnOnRotation ? currentObjPerFrame + 1 : allObjectPerFrame.length); y++) {
                    for (let u = 0; u < allObjectPerFrame[y].obj.length; u++) {
                        if (allObjectPerFrame[y].obj[u].getAttr("id") == thisId) {
                            allObjectPerFrame[y].obj[u].scale(newScale);
                            var txt = allObjectPerFrame[y].obj[u].getAttr("textObj");
                            txt.setAttr('y', allObjectPerFrame[y].obj[u].getAttr('y') + (allObjectPerFrame[y].obj[u].height() / 2) * newScale.x);
                            break;
                        }
                    }
                }
            }
        }
        selectedFrame.draw();
    }

    $(document).off('click touch', '.timeElement');
    $(document).on("click touch", ".timeElement", function(e) {
        var count = $(this).index('.timeElement');
        changeFrame(count);
        drawNewStage();
    });

    $(document).off('click touch', '#addFrame');
    $(document).on("click touch", "#addFrame", function(e) {
        var count = $(".timeElement").length + 1;
        $(".timeElement").last().after("<div class='timeElement' > " + count + " </div>");
        $(".timeElement").each(function() {
            $(this).css('border-color', "");
        });
        $(".timeElement").last().css('border-color', "#dd4213");
        addFrame();
        drawNewStage();
    });

    function newId() {
        var x = (Math.floor((Math.random() * 1000000) + 1));
        var y = (Math.floor((Math.random() * 1000000) + 1));
        var z = (Math.floor((Math.random() * 1000000) + 1));
        var s = Math.random()
        var id = (x + y + z) * s;
        return Math.round(id);
    }

    function selectObjStyle(thisObj) {
        var shapes = selectedFrame.find(".movementObject");
        shapes.each(function(shape) {
            shape.stroke('transparent');
        });
        var shapes = selectedFrame.find(".arrow");
        shapes.each(function(shape) {
            shape.stroke('white');
        });
        var shapes = selectedFrame.find(".shapes");
        shapes.each(function(shape) {
            var fillColor = shape.getAttr('fill');
            fillColor.replace('0.4', '1');
            shape.stroke(fillColor);
        });
        if (thisObj) {
            thisObj.stroke('#dd4213');
            thisObj.strokeWidth(1);

            $scope.$apply(function() {
                $scope.lastSelected = thisObj;
            });
            showInConfigObjData(thisObj);
        }
        $scope.showObjConfig();
        selectedFrame.draw();
    }

    function createAnchorToArrow(x, y, arrowObj, arrowArrayIndex) {
        var anchor = new Konva.Circle({
            x: x + arrowObj.getAttr("x"),
            y: y + arrowObj.getAttr("y"),
            radius: 5,
            stroke: '#ddd',
            fill: '#dda613',
            strokeWidth: 1,
            visible: true,
            draggable: true
        });

        // add hover styling
        anchor.on('mouseover touchstart', function() {
            document.body.style.cursor = 'pointer';
            this.setStrokeWidth(3);
            anchorLayer.draw();
        });
        anchor.on('mouseout touchend', function() {
            document.body.style.cursor = 'default';
            this.setStrokeWidth(1);
            anchorLayer.draw();

        });
        anchor.on('dragend', function() {
            $scope.arrowArrayPostionAnchor[arrowArrayIndex] = {
                x: anchor.getAttr("x") - arrowObj.getAttr("x"),
                y: anchor.getAttr("y") - arrowObj.getAttr("y")
            }
            updateArrow(arrowObj);
        });

        anchor.on('dragstart', function() {
            somethingIsDraw = true;
            $scope.startPointSelectShape = null;
            $scope.endPointSelectShape = null;
        });

        anchor.on('touchstart', function() {
            somethingIsDraw = true;
            $scope.startPointSelectShape = null;
            $scope.endPointSelectShape = null;
        });

        anchor.on('mouseup', function() {
            somethingIsDraw = false;
            $scope.startPointSelectShape = null;
            $scope.endPointSelectShape = null;
        });

        anchor.on('touchend', function() {
            somethingIsDraw = false;
            $scope.startPointSelectShape = null;
            $scope.endPointSelectShape = null;
        });
        anchorLayer.add(anchor);

        return anchor;
    }

    function updateArrow(arrowObj) {
        arrowObj.setAttr('points', $scope.arrowArrayPostionAnchor);
        var id = arrowObj.getAttr('id');
        for (let i = 0; i < allObjectPerFrame.length; i++) {
            for (let y = 0; y < allObjectPerFrame[i].arrow.length; y++) {
                if (id == allObjectPerFrame[i].arrow[y].getAttr("id")) {
                    allObjectPerFrame[i].arrow[y].setAttr("x", arrowObj.getAttr('x'));
                    allObjectPerFrame[i].arrow[y].setAttr("y", arrowObj.getAttr('y'));
                }
            }
        }
        var txtObj = arrowObj.getAttr("textObj");
        txtObj.setAttr('x', $scope.arrowArrayPostionAnchor[0].x + arrowObj.getAttr('x'));
        txtObj.setAttr('y', $scope.arrowArrayPostionAnchor[0].y + arrowObj.getAttr('y'));
        if ($scope.arrowArrayPostionAnchor[0].y < $scope.arrowArrayPostionAnchor[1].y) txtObj.setAttr('offsetY', 50);
        else txtObj.setAttr('offsetY', 10);
        arrowObj.setAttr('textObj', txtObj);
        mainLayer.draw();
    }

    function createAnchorToShape(x, y, shapeObj, shapeArrayIndex) {
        var anchor = new Konva.Circle({
            x: x + shapeObj.getAttr("x"),
            y: y + shapeObj.getAttr("y"),
            radius: 5,
            stroke: '#ddd',
            fill: '#dda613',
            strokeWidth: 1,
            visible: true,
            draggable: true
        });
        // add hover styling
        anchor.on('mouseover touchstart', function() {
            document.body.style.cursor = 'pointer';
            this.setStrokeWidth(3);
            anchorLayer.draw();
        });
        anchor.on('mouseout touchend', function() {
            document.body.style.cursor = 'default';
            this.setStrokeWidth(1);
            anchorLayer.draw();
        });
        anchor.on('dragend', function() {
            somethingIsDraw = false;
            $scope.startPointSelectShape = null;
            $scope.endPointSelectShape = null;
            $scope.shapeArrayPostionAnchor[shapeArrayIndex] = {
                x: anchor.getAttr("x") - shapeObj.getAttr("x"),
                y: anchor.getAttr("y") - shapeObj.getAttr("y")
            }
            updateShape(shapeObj);
        });

        anchor.on('dragstart', function() {
            somethingIsDraw = true;
            $scope.startPointSelectShape = null;
            $scope.endPointSelectShape = null;
        });

        anchor.on('touchstart', function() {
            somethingIsDraw = true;
            $scope.startPointSelectShape = null;
            $scope.endPointSelectShape = null;
        });

        anchor.on('mouseup', function() {
            somethingIsDraw = false;
            $scope.startPointSelectShape = null;
            $scope.endPointSelectShape = null;
        });

        anchor.on('touchend', function() {
            somethingIsDraw = false;
            $scope.startPointSelectShape = null;
            $scope.endPointSelectShape = null;
        });
        anchorLayer.add(anchor);
        return anchor;
    }


    function updateShape(shapeObj) {
        shapeObj.setAttr('arrowPoint', $scope.shapeArrayPostionAnchor);
        var id = shapeObj.getAttr('id');
        for (let i = 0; i < allObjectPerFrame.length; i++) {
            for (let y = 0; y < allObjectPerFrame[i].shapes.length; y++) {
                if (id == allObjectPerFrame[i].shapes[y].getAttr("id")) {
                    allObjectPerFrame[i].shapes[y].setAttr("x", shapeObj.getAttr('x'));
                    allObjectPerFrame[i].shapes[y].setAttr("y", shapeObj.getAttr('y'));
                }
            }
        }
        var txtObj = shapeObj.getAttr("textObj");
        txtObj.setAttr('x', $scope.shapeArrayPostionAnchor[0].x + shapeObj.getAttr('x'));
        txtObj.setAttr('y', $scope.shapeArrayPostionAnchor[0].y + shapeObj.getAttr('y'));
        if ($scope.shapeArrayPostionAnchor[0].y < $scope.shapeArrayPostionAnchor[1].y) txtObj.setAttr('offsetY', 50);
        else txtObj.setAttr('offsetY', 10);
        shapeObj.setAttr('textObj', txtObj);
        mainLayer.draw();
        mainLayer.draw();
    }

    function createTextB(x, y, text) {
        return new Konva.Text({
            x: x,
            y: y,
            offsetX: 100,
            offsetY: 30 - $scope.selectedObjConfig.selectedTextSize,
            text: text,
            fontSize: $scope.selectedObjConfig.selectedTextSize,
            fontFamily: 'Calibri',
            fill: $scope.selectedObjConfig.selectedColorText,
            padding: 20,
            width: 200,
            listening: false,
            align: 'center'
        });
    }

    function drawArrowStyle(context, obj, isHitRegion = false) {
        context.beginPath();
        context.lineJoin = "round";
        context.lineCap = 'round';
        var pkt = obj.getAttr("points");
        context.lineWidth = isHitRegion ? 10 : obj.getAttr("strokeWidth");
        if (isHitRegion) obj.setAttr("strokeWidth", 10);
        context.strokeStyle = obj.getAttr("stroke");
        context.moveTo(pkt[0].x, pkt[0].y);
        var poz = 90;
        var odchylenie = 10;
        var pkt1, pkt2, pkt3;

        for (var z = 0; z < pkt.length; z += 2) {
            var ile = pkt.length - z;
            if (ile >= 3) {
                pkt1 = pkt[z];
                pkt2 = pkt[z + 1];
                pkt3 = pkt[z + 2];
            } else if (ile == 2) {
                pkt1 = pkt[z];
                pkt3 = pkt[z + 1];
                pkt2 = {
                    x: (pkt1.x + pkt3.x) / 2,
                    y: (pkt1.y + pkt3.y) / 2,
                }
            } else {
                break;
            }

            var odleglosc = Math.sqrt(Math.pow(pkt2.x - pkt1.x, 2) + Math.pow(pkt2.y - pkt1.y, 2)) +
                Math.sqrt(Math.pow(pkt3.x - pkt2.x, 2) + Math.pow(pkt3.y - pkt2.y, 2));
            var iloscCzesci = odleglosc / odchylenie;
            var ubytek = (1.0 / iloscCzesci);
            var last;
            var wykonanie = 0;
            for (var i = ubytek; i <= 1 - ubytek; i += ubytek) {

                last = getPosOnCurves(pkt1, pkt2, pkt3, i);
                switch (String(obj.getAttr("config").arrowType)) {
                    case "Odległość zawodników":
                    case "Podanie":
                        var pkts = getPosOnCurves(pkt1, pkt2, pkt3, i);
                        var pktsEnd = getPosOnCurves(pkt1, pkt2, pkt3, i + ubytek);
                        context.quadraticCurveTo(pkts.x, pkts.y, pktsEnd.x, pktsEnd.y);
                        break;
                    case "Strzał":
                        var pkts = getPosOnCurves(pkt1, pkt2, pkt3, i);
                        var pktsEnd = getPosOnCurves(pkt1, pkt2, pkt3, i + ubytek);
                        var angle = Math.atan((pktsEnd.y - pkts.y) / (pktsEnd.x - pkts.x));
                        var newpx = parseFloat(odchylenie / 2 * (Math.cos(angle + 1.57)));
                        var newpy = parseFloat(odchylenie / 2 * (Math.sin(angle + 1.57)));
                        pkts.x += newpx;
                        pkts.y += newpy;
                        context.lineTo(pkts.x, pkts.y);
                        break;
                    case "Linia pomocnicza":
                    case "Bieg bez piłki":
                        if (wykonanie % 2 == 0) {
                            context.beginPath();
                            var pkts = getPosOnCurves(pkt1, pkt2, pkt3, i);
                            var pktsEnd = getPosOnCurves(pkt1, pkt2, pkt3, i + ubytek);
                            context.quadraticCurveTo(pkts.x, pkts.y, pktsEnd.x, pktsEnd.y);
                            context.stroke();
                            context.fillStrokeShape(obj);
                            context.closePath();
                        }
                        break;
                    case "Prowadzenie piłki":
                        var pkts = getPosOnCurves(pkt1, pkt2, pkt3, i);
                        var pktsEnd = getPosOnCurves(pkt1, pkt2, pkt3, i + ubytek);
                        var angle = Math.atan((pktsEnd.y - pkts.y) / (pktsEnd.x - pkts.x));
                        var newpx = parseFloat(odchylenie * (Math.cos(angle + poz)));
                        var newpy = parseFloat(odchylenie * (Math.sin(angle + poz)));
                        pkts.x += newpx;
                        pkts.y += newpy;
                        poz *= -1;
                        context.lineTo(pkts.x, pkts.y);
                        break;

                }
                wykonanie++;
            }


            if ((String(obj.getAttr("config").arrowType)) != "Linia pomocnicza")
                if ((ile - 2) <= 1) {
                    context.stroke();
                    context.fillStrokeShape(obj);
                    context.closePath();
                    context.beginPath();
                    context.moveTo(last.x, last.y);
                    var pktsEnd = getPosOnCurves(pkt1, pkt2, pkt3, 1);
                    var angle = parseFloat(Math.atan((pktsEnd.y - last.y) / (pktsEnd.x - last.x)));
                    var newpx = parseFloat((3) * Math.cos(angle + parseFloat(1.57)));
                    var newpy = parseFloat((3) * Math.sin(angle + parseFloat(1.57)));
                    var newPos = {
                        x: parseFloat(last.x + newpx),
                        y: parseFloat(last.y + newpy),
                    };
                    context.lineTo(newPos.x, newPos.y);
                    context.lineTo(pktsEnd.x, pktsEnd.y);
                    var newpx = parseFloat((3) * Math.cos(angle - parseFloat(1.57)));
                    var newpy = parseFloat((3) * Math.sin(angle - parseFloat(1.57)));
                    var newPos = {
                        x: parseFloat(last.x + newpx),
                        y: parseFloat(last.y + newpy),
                    };
                    context.lineTo(newPos.x, newPos.y);
                    context.lineTo(last.x, last.y);
                    context.fillStyle = '#ffffff';
                    context.fill();

                }
        }
        context.stroke();
        context.fillStrokeShape(obj);

        if ((String(obj.getAttr("config").arrowType)) == "Odległość zawodników") {
            if (pkt.length >= 3) {
                pkt1 = pkt[0];
                pkt2 = pkt[1];
                pkt3 = pkt[2];
            } else if (pkt.length == 2) {
                pkt1 = pkt[0];
                pkt3 = pkt[1];
                pkt2 = {
                    x: (pkt1.x + pkt3.x) / 2,
                    y: (pkt1.y + pkt3.y) / 2,
                }
            }
            var odleglosc = Math.sqrt(Math.pow(pkt2.x - pkt1.x, 2) + Math.pow(pkt2.y - pkt1.y, 2)) +
                Math.sqrt(Math.pow(pkt3.x - pkt2.x, 2) + Math.pow(pkt3.y - pkt2.y, 2));
            var iloscCzesci = odleglosc / odchylenie;
            var ubytek = (1.0 / iloscCzesci);
            context.beginPath();
            var pktsStart = getPosOnCurves(pkt1, pkt2, pkt3, 0);
            context.moveTo(pktsStart.x, pktsStart.y);
            var last = getPosOnCurves(pkt1, pkt2, pkt3, ubytek);

            var angle = parseFloat(Math.atan((pktsStart.y - last.y) / (pktsStart.x - last.x)));
            var newpx = parseFloat((3) * Math.cos(angle + parseFloat(1.57)));
            var newpy = parseFloat((3) * Math.sin(angle + parseFloat(1.57)));
            var newPos = {
                x: parseFloat(last.x + newpx),
                y: parseFloat(last.y + newpy),
            };
            context.lineTo(newPos.x, newPos.y);
            var newpx = parseFloat((3) * Math.cos(angle - parseFloat(1.57)));
            var newpy = parseFloat((3) * Math.sin(angle - parseFloat(1.57)));
            var newPos = {
                x: parseFloat(last.x + newpx),
                y: parseFloat(last.y + newpy),
            };
            context.lineTo(newPos.x, newPos.y);
            context.lineTo(pktsStart.x, pktsStart.y);
            context.fillStyle = '#ffffff';
            context.fill();
        } else if ((String(obj.getAttr("config").arrowType)) == "Strzał") {
            context.stroke();
            context.fillStrokeShape(obj);
            context.beginPath();
            context.moveTo(pkt[0].x, pkt[0].y);
            for (var z = 0; z < pkt.length; z += 2) {
                var ile = pkt.length - z;
                if (ile >= 3) {
                    pkt1 = pkt[z];
                    pkt2 = pkt[z + 1];
                    pkt3 = pkt[z + 2];
                } else if (ile == 2) {
                    pkt1 = pkt[z];
                    pkt3 = pkt[z + 1];
                    pkt2 = {
                        x: (pkt1.x + pkt3.x) / 2,
                        y: (pkt1.y + pkt3.y) / 2,
                    }
                } else {
                    break;
                }
                var odleglosc = Math.sqrt(Math.pow(pkt2.x - pkt1.x, 2) + Math.pow(pkt2.y - pkt1.y, 2)) +
                    Math.sqrt(Math.pow(pkt3.x - pkt2.x, 2) + Math.pow(pkt3.y - pkt2.y, 2));
                var iloscCzesci = odleglosc / odchylenie;
                var ubytek = (1.0 / iloscCzesci);
                var last;
                var wykonanie = 0;
                for (var i = ubytek; i <= 1 - ubytek; i += ubytek) {
                    last = getPosOnCurves(pkt1, pkt2, pkt3, i);
                    var pkts = getPosOnCurves(pkt1, pkt2, pkt3, i);
                    var pktsEnd = getPosOnCurves(pkt1, pkt2, pkt3, i + ubytek);
                    var angle = Math.atan((pktsEnd.y - pkts.y) / (pktsEnd.x - pkts.x));
                    var newpx = parseFloat(odchylenie / 2 * (Math.cos(angle - 1.57)));
                    var newpy = parseFloat(odchylenie / 2 * (Math.sin(angle - 1.57)));
                    pkts.x += newpx;
                    pkts.y += newpy;
                    context.lineTo(pkts.x, pkts.y);
                    wykonanie++;
                }
            }
        }

        context.stroke();
        context.fillStrokeShape(obj);
        if (isHitRegion) obj.setAttr("strokeWidth", 1);
    }

    function addToMultiSelect(obj) {
        var id = obj.getAttr('id');
        var isIn = false;
        var pos = 0;

        if ($scope.lastSelected) {
            for (let i = 0; i < $scope.selectedItemList.length; i++) {
                if ($scope.lastSelected.getAttr('id') == $scope.selectedItemList[i].getAttr('id')) {
                    isIn = true;
                    pos = i;
                    break;
                }
            }
            if (!isIn) {
                $scope.selectedItemList.push($scope.lastSelected);
            }
            $scope.lastSelected = null;
        }

        var isIn = false;
        var pos = 0;

        for (let i = 0; i < $scope.selectedItemList.length; i++) {
            if (id == $scope.selectedItemList[i].getAttr('id')) {
                isIn = true;
                pos = i;
                break;
            }
        }
        if (!isIn) {
            $scope.selectedItemList.push(obj);
        } else {
            $scope.selectedItemList.splice(pos, 1);
        }


        $scope.lastSelected = null;
        $scope.startPointSelectShape = null;
        $scope.endPointSelectShape = null;

        var isSameConfig = true;
        var confName = '';

        var shapes = selectedFrame.find(".movementObject");
        shapes.each(function(shape) {
            shape.stroke('transparent');
            for (let i = 0; i < $scope.selectedItemList.length; i++) {
                if ($scope.selectedItemList[i].getAttr("id") == shape.getAttr("id")) {
                    shape.strokeWidth(1);
                    shape.stroke('red');
                    var config = shape.getAttr("config");
                    if (!config) isSameConfig = false;
                    else {
                        if (confName == '') {
                            confName = config.confName;
                        } else if (confName != config.confName) {
                            isSameConfig = false;
                        }
                    }
                }
            }
        });


        var shapes = selectedFrame.find(".arrow");
        shapes.each(function(shape) {
            shape.stroke('white');
            for (let i = 0; i < $scope.selectedItemList.length; i++) {
                if ($scope.selectedItemList[i].getAttr("id") == shape.getAttr("id")) {
                    shape.stroke('red');
                    var config = shape.getAttr("config");
                    if (!config) isSameConfig = false;
                    else {
                        if (confName == '') {
                            confName = config.confName;
                        } else if (confName != config.confName) {
                            isSameConfig = false;
                        }
                    }
                }
            }
        });
        var shapes = selectedFrame.find(".shapes");
        shapes.each(function(shape) {
            var fillColor = shape.getAttr('fill');
            fillColor.replace('0.4', '1');
            shape.stroke(fillColor);
            for (let i = 0; i < $scope.selectedItemList.length; i++) {
                if ($scope.selectedItemList[i].getAttr("id") == shape.getAttr("id")) {
                    shape.stroke('red');
                    var config = shape.getAttr("config");
                    if (!config) isSameConfig = false;
                    else {
                        if (confName == '') {
                            confName = config.confName;
                        } else if (confName != config.confName) {
                            isSameConfig = false;
                        }
                    }
                }
            }
        });

        if (isSameConfig && $scope.selectedItemList.length > 0) {
            $scope.lastSelected = $scope.selectedItemList[0];
        }

        if (selectShapeLayer != null) {
            selectShapeLayer.destroy();
            selectShapeLayer = null;
        }
        $scope.showObjConfig();
        selectedFrame.draw();


    }

    function dragAllSelectedItem(idMain, offset) {

        var isIn = false;
        for (let x = 0; x < $scope.selectedItemList.length; x++) {
            var id = $scope.selectedItemList[x].getAttr('id');
            if (id == idMain) {
                isIn = true;
                break;
            }
        }
        if (!isIn) return;

        for (let x = 0; x < $scope.selectedItemList.length; x++) {
            var id = $scope.selectedItemList[x].getAttr('id');

            for (let z = 0; z < allObjectPerFrame[currentObjPerFrame].obj.length; z++) {
                if (allObjectPerFrame[currentObjPerFrame].obj[z].getAttr('id') == id) {
                    if (idMain == allObjectPerFrame[currentObjPerFrame].obj[z].getAttr('id')) break;
                    allObjectPerFrame[currentObjPerFrame].obj[z].setAttr("x", allObjectPerFrame[currentObjPerFrame].obj[z].getAttr("x") - offset.x);
                    allObjectPerFrame[currentObjPerFrame].obj[z].setAttr("y", allObjectPerFrame[currentObjPerFrame].obj[z].getAttr("y") - offset.y);
                    var txt = allObjectPerFrame[currentObjPerFrame].obj[z].getAttr("textObj");
                    txt.setAttr('x', allObjectPerFrame[currentObjPerFrame].obj[z].getAttr('x'));
                    txt.setAttr('y', allObjectPerFrame[currentObjPerFrame].obj[z].getAttr('y') + (allObjectPerFrame[currentObjPerFrame].obj[z].height() / 2) * allObjectPerFrame[currentObjPerFrame].obj[z].scale().x);
                }
            }

            for (let i = 0; i < allObjectPerFrame.length; i++) {
                var isFinded = false;

                if (!isFinded)
                    for (let z = 0; z < allObjectPerFrame[i].arrow.length; z++) {
                        if (allObjectPerFrame[i].arrow[z].getAttr('id') == id) {
                            isFinded = true;
                            if (idMain == allObjectPerFrame[i].arrow[z].getAttr('id') && i == currentObjPerFrame) break;
                            allObjectPerFrame[i].arrow[z].setAttr("x", allObjectPerFrame[i].arrow[z].getAttr("x") - offset.x);
                            allObjectPerFrame[i].arrow[z].setAttr("y", allObjectPerFrame[i].arrow[z].getAttr("y") - offset.y);
                            var txt = allObjectPerFrame[i].arrow[z].getAttr("textObj");
                            txt.setAttr('x', allObjectPerFrame[i].arrow[z].getAttr('points')[0].x + allObjectPerFrame[i].arrow[z].getAttr("x"));
                            txt.setAttr('y', allObjectPerFrame[i].arrow[z].getAttr('points')[0].y + allObjectPerFrame[i].arrow[z].getAttr("y"));
                        }
                    }
                if (!isFinded)
                    for (let z = 0; z < allObjectPerFrame[i].shapes.length; z++) {
                        if (allObjectPerFrame[i].shapes[z].getAttr('id') == id) {
                            if (idMain == allObjectPerFrame[i].shapes[z].getAttr('id') && i == currentObjPerFrame) break;
                            allObjectPerFrame[i].shapes[z].setAttr("x", allObjectPerFrame[i].shapes[z].getAttr("x") - offset.x);
                            allObjectPerFrame[i].shapes[z].setAttr("y", allObjectPerFrame[i].shapes[z].getAttr("y") - offset.y);
                            var txt = allObjectPerFrame[i].shapes[z].getAttr("textObj");
                            txt.setAttr('x', allObjectPerFrame[i].shapes[z].getAttr('arrowPoint')[0].x + allObjectPerFrame[i].shapes[z].getAttr("x"));
                            txt.setAttr('y', allObjectPerFrame[i].shapes[z].getAttr('arrowPoint')[0].y + allObjectPerFrame[i].shapes[z].getAttr("y"));
                        }
                    }
            }
        }

        drawBeforePositionPoint();
        updateNextFrameBeforePosition();

        if ($scope.turnOnRotation) rotateObject();
        if (anchorLayer != null) {
            anchorLayer.destroy();
            anchorLayer = null;
        }
    }

    function clickOnContent() {
        $scope.startPointSelectShape = null;
        $scope.endPointSelectShape = null;
        if ($scope.actualMouseAction == $scope.mouseActionType.OBJECT_ADD && $scope.selectedObjImg && $scope.canAddItem) {
            if (anchorLayer != null) {
                anchorLayer.destroy();
                anchorLayer = null;
            }
            anchorLayer = new Konva.Layer();
            selectedFrame.add(anchorLayer);
            var mousePos = selectedFrame.getPointerPosition();
            var scale = selectedFrame.getAttr('scaleX');
            var id = newId();

            var obj = new Konva.Image({
                x: mousePos.x / scale,
                y: mousePos.y / scale,
                offsetX: ($scope.selectedObjImg.width / 2.0),
                offsetY: ($scope.selectedObjImg.height / 2.0),
                image: $scope.selectedObjImg,
                config: $.extend(true, {}, $scope.selectedObjConfig),
                name: "movementObject",
                id: id,
                textObj: null
            });


            obj.hitFunc(function(context) {
                context.beginPath();
                var width = this.getWidth() * this.scaleX();
                var height = this.getHeight() * this.scaleX();
                var procW = 15;
                var procH = 15;
                context.rect(-procW, -procH, width + (procW * 2), height + (procH * 2));
                context.closePath();
                context.fillStrokeShape(this);
            });

            $scope.$apply(function() {
                $scope.lastSelected = obj;
            });

            var complexText = createTextB(mousePos.x / scale, (mousePos.y / scale) + (obj.height() / 2), $scope.selectedObjConfig && $scope.selectedObjConfig.text ? $scope.selectedObjConfig.text : "");
            mainLayer.add(complexText);
            obj.setAttr('textObj', complexText);

            obj.on('mousedown touchstart', function() {
                somethingIsDraw = true;
                $scope.startPointSelectShape = null;
                $scope.endPointSelectShape = null;
                obj.setAttr('draggable', true);
                if ($scope.shiftPressed) {} else if ($scope.selectedItemList.length <= 0) {
                    $scope.selectedItemList = [];
                    selectObjStyle(this);
                    drawBeforePositionPoint();
                    updateNextFrameBeforePosition();
                    if ($scope.turnOnRotation) rotateObject();
                }
            });

            obj.on('click tap', function() {
                if ($scope.shiftPressed) {
                    addToMultiSelect(this);
                } else {
                    $scope.selectedItemList = [];
                    selectObjStyle(this);
                }
            });

            obj.on('dragmove', function() {
                var offset = {
                    x: multiDragPositionStart.x - this.attrs.x,
                    y: multiDragPositionStart.y - this.attrs.y
                }
                if ($scope.selectedItemList.length > 0) dragAllSelectedItem(this.getAttr('id'), offset);
                multiDragPositionStart = {
                    x: this.getAttr("x"),
                    y: this.getAttr("y")
                }
                var txtObj = obj.getAttr("textObj");
                txtObj.setAttr('x', obj.getAttr("x"));
                txtObj.setAttr('y', obj.getAttr("y") + (obj.height() / 2) * obj.scale().x);
                obj.setAttr('textObj', txtObj);
                mainLayer.draw();
            });

            obj.on('dragstart', function() {
                multiDragPositionStart = {
                    x: this.getAttr("x"),
                    y: this.getAttr("y")
                }
                somethingIsDraw = true;
                $scope.startPointSelectShape = null;
                $scope.endPointSelectShape = null;
            });

            obj.on('touchstart', function() {
                somethingIsDraw = true;
                $scope.startPointSelectShape = null;
                $scope.endPointSelectShape = null;
            });

            obj.on('mouseup', function() {
                somethingIsDraw = false;
                $scope.startPointSelectShape = null;
                $scope.endPointSelectShape = null;
            });

            obj.on('touchend', function() {
                somethingIsDraw = false;
                $scope.startPointSelectShape = null;
                $scope.endPointSelectShape = null;
            });

            obj.on('dragend', function(e) {
                somethingIsDraw = false;
                $scope.startPointSelectShape = null;
                $scope.endPointSelectShape = null;

                if ($scope.selectedItemList.length <= 1) {
                    drawBeforePositionPoint();
                    updateNextFrameBeforePosition();
                    if ($scope.turnOnRotation) rotateObject();
                }
            });

            obj.strokeWidth(1);
            selectObjStyle(obj);

            // add the shape to the mainLayer
            mainLayer.add(obj);
            allObjectPerFrame[currentObjPerFrame].obj.push(obj);

            for (let z = currentObjPerFrame + 1; z < allObjectPerFrame.length; z++) {
                allObjectPerFrame[z].obj.push(createObjFromOther(obj));
            }

            selectedFrame.find(".movementObject").each(function(shape) {
                shape.on('mouseenter', function() {
                    if ($scope.actualMouseAction == $scope.mouseActionType.MOVE) {
                        selectedFrame.container().style.cursor = 'move';
                    }
                });
                shape.on('mouseleave', function() {
                    selectedFrame.container().style.cursor = 'default';
                });
            });
            selectedFrame.draw();

        } else if ($scope.actualMouseAction == $scope.mouseActionType.ARROW_ADD) {
            $scope.arrowPointCount++;
            var scale = selectedFrame.getAttr('scaleX');
            var mousePos = selectedFrame.getPointerPosition();
            $scope.arrowPoint.push({
                x: mousePos.x / scale,
                y: mousePos.y / scale
            });
            var countLimit = 10;

            var pointsArray = [];
            for (var index = 0; index < $scope.arrowPoint.length; index++) {
                pointsArray.push($scope.arrowPoint[index].x);
                pointsArray.push($scope.arrowPoint[index].y);
            }

            if ($scope.arrowPointCount == 2) {
                var id = newId();

                var arrow = new Konva.Shape({
                    points: $scope.arrowPoint,
                    stroke: 'white',
                    strokeWidth: 1,
                    id: id,
                    textObj: null,
                    name: 'arrow',
                    draggable: true,
                    config: $.extend(true, {}, $scope.selectedObjConfig),
                    sceneFunc: function(context) {
                        drawArrowStyle(context, this);
                    }
                });
                selectObjStyle(arrow);

                arrow.hitFunc(function(context) {
                    drawArrowStyle(context, this, true);
                });

                if (anchorLayer) {
                    anchorLayer.destroy();
                    anchorLayer = null;
                }
                anchorLayer = new Konva.Layer();
                selectedFrame.add(anchorLayer);

                var complexText = createTextB($scope.arrowPoint[0].x, $scope.arrowPoint[0].y, ($scope.selectedObjConfig && $scope.selectedObjConfig.text) ? $scope.selectedObjConfig.text : "");
                mainLayer.add(complexText);
                if (pointsArray[1] < pointsArray[3]) complexText.setAttr('offsetY', 50);
                else complexText.setAttr('offsetY', 10);
                arrow.setAttr('textObj', complexText);



                $scope.arrowArrayPostionAnchor = $scope.arrowPoint;
                for (var index = 0; index < $scope.arrowPoint.length; index++) {
                    createAnchorToArrow($scope.arrowPoint[index].x, $scope.arrowPoint[index].y, arrow, index);
                }
                selectedFrame.draw();

                arrow.on('mousedown touchstart', function() {
                    somethingIsDraw = true;
                    $scope.startPointSelectShape = null;
                    $scope.endPointSelectShape = null;
                    if ($scope.shiftPressed) {} else if ($scope.selectedItemList.length <= 0) {
                        $scope.selectedItemList = [];
                        selectObjStyle(this);
                    }
                    if (anchorLayer) {
                        anchorLayer.destroy();
                        anchorLayer = null;
                    }
                    anchorLayer = new Konva.Layer();
                    selectedFrame.add(anchorLayer);
                    $scope.arrowArrayPostionAnchor = this.getAttr('points');
                    for (var index = 0; index < $scope.arrowArrayPostionAnchor.length; index++) {
                        createAnchorToArrow($scope.arrowArrayPostionAnchor[index].x, $scope.arrowArrayPostionAnchor[index].y, this, index);
                    }
                    selectedFrame.draw();
                });

                arrow.on('dragmove', function() {
                    somethingIsDraw = true;
                    var offset = {
                        x: multiDragPositionStart.x - this.attrs.x,
                        y: multiDragPositionStart.y - this.attrs.y
                    }

                    if ($scope.selectedItemList.length > 0) dragAllSelectedItem(this.getAttr('id'), offset);
                    multiDragPositionStart = {
                        x: this.getAttr("x"),
                        y: this.getAttr("y")
                    }
                    var textObj = this.getAttr("textObj");
                    var pt = this.getAttr("points");
                    textObj.setAttr('x', this.getAttr("x") + pt[0].x);
                    textObj.setAttr('y', this.getAttr("y") + pt[0].y);
                    $scope.startPointSelectShape = null;
                    $scope.endPointSelectShape = null;
                    if (anchorLayer) {
                        anchorLayer.destroy();
                        anchorLayer = null;
                    }
                    anchorLayer = new Konva.Layer();
                    selectedFrame.add(anchorLayer);
                    $scope.arrowArrayPostionAnchor = this.getAttr('points');
                    for (var index = 0; index < $scope.arrowArrayPostionAnchor.length; index++) {
                        createAnchorToArrow($scope.arrowArrayPostionAnchor[index].x, $scope.arrowArrayPostionAnchor[index].y, this, index);
                    }
                    selectedFrame.draw();
                });

                arrow.on('click tap', function() {
                    if ($scope.shiftPressed) {
                        addToMultiSelect(this);
                    } else {
                        $scope.selectedItemList = [];
                        selectObjStyle(this);
                    }
                });

                arrow.on('dragstart', function() {
                    multiDragPositionStart = {
                        x: this.getAttr("x"),
                        y: this.getAttr("y")
                    }
                    somethingIsDraw = true;
                    $scope.startPointSelectShape = null;
                    $scope.endPointSelectShape = null;
                });

                arrow.on('touchstart', function() {
                    somethingIsDraw = true;
                    $scope.startPointSelectShape = null;
                    $scope.endPointSelectShape = null;
                });

                arrow.on('dragend', function() {
                    somethingIsDraw = false;
                    $scope.startPointSelectShape = null;
                    $scope.endPointSelectShape = null;
                });

                arrow.on('mouseup', function() {
                    somethingIsDraw = false;
                    $scope.startPointSelectShape = null;
                    $scope.endPointSelectShape = null;
                    var id = this.getAttr('id');
                    for (let i = 0; i < allObjectPerFrame.length; i++) {
                        for (let y = 0; y < allObjectPerFrame[i].arrow.length; y++) {
                            if (id == allObjectPerFrame[i].arrow[y].getAttr("id")) {
                                allObjectPerFrame[i].arrow[y].setAttr("x", this.getAttr('x'));
                                allObjectPerFrame[i].arrow[y].setAttr("y", this.getAttr('y'));
                            }
                        }
                    }
                });

                arrow.on('touchend', function() {
                    somethingIsDraw = false;
                    $scope.startPointSelectShape = null;
                    $scope.endPointSelectShape = null;
                });

                mainLayer.add(arrow);
                allObjectPerFrame[currentObjPerFrame].arrow.push(arrow);
                for (let z = currentObjPerFrame + 1; z < allObjectPerFrame.length; z++) {
                    allObjectPerFrame[z].arrow.push(createObjFromOther(arrow));
                }

                selectedFrame.find(".arrow").each(function(shape) {
                    shape.on('mouseenter', function() {
                        if ($scope.actualMouseAction == $scope.mouseActionType.MOVE) {
                            selectedFrame.container().style.cursor = 'move';
                        }
                    });
                    shape.on('mouseleave', function() {
                        selectedFrame.container().style.cursor = 'default';
                    });
                });

                mainLayer.draw();
            } else if ($scope.arrowPointCount > 2) {
                $scope.lastSelected.setAttr("points", $scope.arrowPoint);
                if (anchorLayer != null) {
                    anchorLayer.destroy();
                    anchorLayer = null;
                }
                anchorLayer = new Konva.Layer();
                selectedFrame.add(anchorLayer);
                $scope.arrowArrayPostionAnchor = $scope.lastSelected.getAttr('points');
                for (var index = 0; index < $scope.arrowArrayPostionAnchor.length; index++) {
                    createAnchorToArrow($scope.arrowArrayPostionAnchor[index].x, $scope.arrowArrayPostionAnchor[index].y, $scope.lastSelected, index);
                }
                selectedFrame.draw();
            }
        } else if ($scope.actualMouseAction == $scope.mouseActionType.SHAPE_ADD && $scope.selectedShape) {
            $scope.shapePointCount++;
            var scale = selectedFrame.getAttr('scaleX');
            var mousePos = selectedFrame.getPointerPosition();
            $scope.shapePoint.push({
                x: mousePos.x / scale,
                y: mousePos.y / scale
            });
            var countLimit = 0;
            var fillColor = '#ffffff';
            var strokeColor = '#ffffff';
            switch ($scope.selectedShape) {
                case $scope.shapeType.WHITE_3:
                    countLimit = 3;
                    fillColor = 'rgba(255,255,255,0.4)';
                    strokeColor = 'rgba(255,255,255,1)';
                    break;
                case $scope.shapeType.WHITE_4:
                    countLimit = 4;
                    fillColor = 'rgba(255,255,255,0.4)';
                    strokeColor = 'rgba(255,255,255,1)';
                    break;
                case $scope.shapeType.WHITE_5:
                    countLimit = 5;
                    fillColor = 'rgba(255,255,255,0.4)';
                    strokeColor = 'rgba(255,255,255,1)';
                    break;
                case $scope.shapeType.GREY_3:
                    countLimit = 3;
                    fillColor = 'rgba(217,217,217,0.4)';
                    strokeColor = 'rgba(217,217,217,1)';
                    break;
                case $scope.shapeType.GREY_4:
                    countLimit = 4;
                    fillColor = 'rgba(217,217,217,0.4)';
                    strokeColor = 'rgba(217,217,217,1)';
                    break;
                case $scope.shapeType.GREY_5:
                    countLimit = 5;
                    fillColor = 'rgba(217,217,217,0.4)';
                    strokeColor = 'rgba(217,217,217,1)';
                    break;
                case $scope.shapeType.BLUE_3:
                    countLimit = 3;
                    fillColor = 'rgba(0, 126, 255,0.4)';
                    strokeColor = 'rgba(0, 126, 255,1)';
                    break;
                case $scope.shapeType.BLUE_4:
                    countLimit = 4;
                    fillColor = 'rgba(0, 126, 255,0.4)';
                    strokeColor = 'rgba(0, 126, 255,1)';
                    break;
                case $scope.shapeType.BLUE_5:
                    countLimit = 5;
                    fillColor = 'rgba(0, 126, 255,0.4)';
                    strokeColor = 'rgba(0, 126, 255,1)';
                    break;
                case $scope.shapeType.PURPLE_3:
                    countLimit = 3;
                    fillColor = 'rgba(144, 0, 255,0.4)';
                    strokeColor = 'rgba(144, 0, 255,1)';
                    break;
                case $scope.shapeType.PURPLE_4:
                    countLimit = 4;
                    fillColor = 'rgba(144, 0, 255,0.4)';
                    strokeColor = 'rgba(144, 0, 255,1)';
                    break;
                case $scope.shapeType.PURPLE_5:
                    countLimit = 5;
                    fillColor = 'rgba(144, 0, 255,0.4)';
                    strokeColor = 'rgba(144, 0, 255,1)';
                    break;
                case $scope.shapeType.ORANGE_3:
                    countLimit = 3;
                    fillColor = 'rgba(255, 204, 0,0.4)';
                    strokeColor = 'rgba(255, 204, 0,1)';
                    break;
                case $scope.shapeType.ORANGE_4:
                    countLimit = 4;
                    fillColor = 'rgba(255, 204, 0,0.4)';
                    strokeColor = 'rgba(255, 204, 0,1)';
                    break;
                case $scope.shapeType.ORANGE_5:
                    countLimit = 5;
                    fillColor = 'rgba(255, 204, 0,0.4)';
                    strokeColor = 'rgba(255, 204, 0,1)';
                    break;
                case $scope.shapeType.RED_3:
                    countLimit = 3;
                    fillColor = 'rgba(247, 49, 3,0.4)';
                    strokeColor = 'rgba(247, 49, 3,1)';
                    break;
                case $scope.shapeType.RED_4:
                    countLimit = 4;
                    fillColor = 'rgba(247, 49, 3,0.4)';
                    strokeColor = 'rgba(247, 49, 3,1)';
                    break;
                case $scope.shapeType.RED_5:
                    countLimit = 5;
                    fillColor = 'rgba(247, 49, 3,0.4)';
                    strokeColor = 'rgba(247, 49, 3,1)';
                    break;
            }

            if ($scope.shapePointCount >= countLimit) {
                var shapPointArr = $scope.shapePoint;
                var id = newId();
                var triangle = new Konva.Shape({
                    arrowPoint: shapPointArr,
                    sceneFunc: function(context) {
                        context.beginPath();
                        context.moveTo(shapPointArr[0].x, shapPointArr[0].y);
                        for (var i = 1; i < shapPointArr.length; i++) {
                            context.lineTo(shapPointArr[i].x, shapPointArr[i].y);
                        }
                        context.closePath();
                        context.fillStrokeShape(this);
                    },
                    draggable: true,
                    name: "shapes",
                    fill: fillColor,
                    stroke: strokeColor,
                    strokeWidth: 2,
                    id: id,
                    textObj: null,
                    config: $.extend(true, {}, $scope.selectedObjConfig)
                });
                selectObjStyle(triangle);

                var complexText = createTextB(shapPointArr[0].x, shapPointArr[0].y, ($scope.selectedObjConfig && $scope.selectedObjConfig.text) ? $scope.selectedObjConfig.text : "");
                mainLayer.add(complexText);
                if (shapPointArr[0].y < shapPointArr[1].y) complexText.setAttr('offsetY', 50);
                else complexText.setAttr('offsetY', 10);
                triangle.setAttr('textObj', complexText);

                // add the shape to the layer
                mainLayer.add(triangle);


                if (anchorLayer != null) {
                    anchorLayer.destroy();
                    anchorLayer = null;
                }
                anchorLayer = new Konva.Layer();
                selectedFrame.add(anchorLayer);

                $scope.shapeArrayPostionAnchor = $scope.shapePoint;
                for (var index = 0; index < $scope.shapePoint.length; index++) {
                    createAnchorToShape($scope.shapePoint[index].x, $scope.shapePoint[index].y, triangle, index);
                }

                triangle.on('mousedown touchstart', function() {
                    somethingIsDraw = true;
                    $scope.startPointSelectShape = null;
                    $scope.endPointSelectShape = null;
                    if ($scope.shiftPressed) {} else if ($scope.selectedItemList.length <= 0) {
                        $scope.selectedItemList = [];
                        selectObjStyle(this);
                    }
                    if (anchorLayer != null) {
                        anchorLayer.destroy();
                        anchorLayer = null;
                    }
                    anchorLayer = new Konva.Layer();
                    selectedFrame.add(anchorLayer);
                    $scope.shapeArrayPostionAnchor = this.getAttr('arrowPoint');
                    for (var index = 0; index < $scope.shapeArrayPostionAnchor.length; index++) {
                        createAnchorToShape($scope.shapeArrayPostionAnchor[index].x, $scope.shapeArrayPostionAnchor[index].y, this, index);
                    }
                    selectedFrame.draw();
                });

                triangle.on('dragmove', function() {
                    somethingIsDraw = true;
                    var offset = {
                        x: multiDragPositionStart.x - this.attrs.x,
                        y: multiDragPositionStart.y - this.attrs.y
                    }
                    if ($scope.selectedItemList.length > 0) dragAllSelectedItem(this.getAttr('id'), offset);
                    multiDragPositionStart = {
                        x: this.getAttr("x"),
                        y: this.getAttr("y")
                    }
                    var textObj = this.getAttr("textObj")
                    var pt = this.getAttr("arrowPoint");
                    textObj.setAttr('x', this.getAttr("x") + pt[0].x);
                    textObj.setAttr('y', this.getAttr("y") + pt[0].y);
                    $scope.startPointSelectShape = null;
                    $scope.endPointSelectShape = null;
                    if (anchorLayer != null) {
                        anchorLayer.destroy();
                        anchorLayer = null;
                    }
                    anchorLayer = new Konva.Layer();
                    selectedFrame.add(anchorLayer);
                    $scope.shapeArrayPostionAnchor = this.getAttr('arrowPoint');
                    for (var index = 0; index < $scope.shapeArrayPostionAnchor.length; index++) {
                        createAnchorToShape($scope.shapeArrayPostionAnchor[index].x, $scope.shapeArrayPostionAnchor[index].y, this, index);
                    }

                    selectedFrame.draw();
                });

                triangle.on('click tap', function() {
                    if ($scope.shiftPressed) {
                        addToMultiSelect(this);
                    } else {
                        $scope.selectedItemList = [];
                        selectObjStyle(this);
                    }
                });

                triangle.on('dragstart', function() {
                    multiDragPositionStart = {
                        x: this.getAttr("x"),
                        y: this.getAttr("y")
                    }
                    somethingIsDraw = true;
                    $scope.startPointSelectShape = null;
                    $scope.endPointSelectShape = null;
                });

                triangle.on('touchstart', function() {
                    somethingIsDraw = true;
                    $scope.startPointSelectShape = null;
                    $scope.endPointSelectShape = null;
                });

                triangle.on('dragend', function() {
                    somethingIsDraw = false;
                    $scope.startPointSelectShape = null;
                    $scope.endPointSelectShape = null;
                    var id = this.getAttr('id');
                    for (let i = 0; i < allObjectPerFrame.length; i++) {
                        for (let y = 0; y < allObjectPerFrame[i].shapes.length; y++) {
                            if (id == allObjectPerFrame[i].shapes[y].getAttr("id")) {
                                allObjectPerFrame[i].shapes[y].setAttr("x", this.getAttr('x'));
                                allObjectPerFrame[i].shapes[y].setAttr("y", this.getAttr('y'));
                            }
                        }
                    }
                });

                triangle.on('mouseup', function() {
                    somethingIsDraw = false;
                    $scope.startPointSelectShape = null;
                    $scope.endPointSelectShape = null;
                });

                triangle.on('touchend', function() {
                    somethingIsDraw = false;
                    $scope.startPointSelectShape = null;
                    $scope.endPointSelectShape = null;
                });

                allObjectPerFrame[currentObjPerFrame].shapes.push(triangle);

                for (let z = currentObjPerFrame + 1; z < allObjectPerFrame.length; z++) {
                    allObjectPerFrame[z].triangle.push(createObjFromOther(triangle));
                }


                selectedFrame.find(".shapes").each(function(shape) {
                    shape.on('mouseenter', function() {
                        if ($scope.actualMouseAction == $scope.mouseActionType.MOVE) {
                            selectedFrame.container().style.cursor = 'move';
                        }
                    });
                    shape.on('mouseleave', function() {
                        selectedFrame.container().style.cursor = 'default';
                    });
                });

                $scope.$apply(function() {
                    $scope.changeCategories($scope.mouseActionType.MOVE);
                });

                $scope.shapePointCount = 0;
                $scope.shapePoint = [];
                anchorLayer.draw();
                mainLayer.draw();
                mainLayer.draw();
            }
        } else if ($scope.actualMouseAction == $scope.mouseActionType.TEXT_ADD) {
            if (anchorLayer != null) {
                anchorLayer.destroy();
                anchorLayer = null;
            }
            anchorLayer = new Konva.Layer();
            selectedFrame.add(anchorLayer);
            var mousePos = selectedFrame.getPointerPosition();
            var scale = selectedFrame.getAttr('scaleX');
            var id = newId();
            var obj = new Konva.Text({
                x: mousePos.x / scale,
                y: mousePos.y / scale,
                offsetX: 140,
                offsetY: 20,
                text: 'Kliknij dwa razy, aby edytować',
                fontSize: 20,
                fill: 'white',
                align: 'center',
                name: "movementObject",
                id: id
            });


            selectObjStyle(obj);

            // add the shape to the mainLayer
            mainLayer.add(obj);

            selectedFrame.draw();

            obj.on('dblclick', function() {
                // create textarea over canvas with absolute position
                // first we need to find its positon
                var textPosition = obj.getAbsolutePosition();
                var stageBox = selectedFrame.getContainer().getBoundingClientRect();
                var areaPosition = {
                    x: textPosition.x + stageBox.left,
                    y: textPosition.y + stageBox.top
                };
                // create textarea and style it
                var textarea = document.createElement('textarea');
                textarea.className = "textToEditInCv";
                document.body.appendChild(textarea);
                textarea.value = obj.text();
                textarea.style.position = 'absolute';
                textarea.style.top = areaPosition.y + 5 + 'px';
                textarea.style.left = areaPosition.x - 100 + 'px';
                textarea.style.zIndex = '300';
                textarea.style.width = "200px";
                textarea.style.color = "white";
                textarea.style.backogrund = "rgba(0, 0, 0, 0.34)";
                textarea.focus();
                $(document).off('keydown', '.textToEditInCv');
                $(document).on('keydown', '.textToEditInCv', function(e) {
                    if (e.keyCode === 13) {
                        obj.text(textarea.value);
                        selectedFrame.draw();
                        document.body.removeChild(textarea);
                    }
                });
            })
            allObjectPerFrame[currentObjPerFrame].text.push(obj);
            for (let z = currentObjPerFrame + 1; z < allObjectPerFrame.length; z++) {
                allObjectPerFrame[z].text.push(createObjFromOther(text));
            }
            $scope.$apply(function() {
                $scope.changeCategories($scope.mouseActionType.MOVE);
            });
        }
    }


    function createArrowObjFromOther(other, isNoObj = false) {
        var arrow;
        if (!isNoObj) {
            var lastText = other.getAttr("textObj");
            var complexText = new Konva.Text({
                x: lastText.getAttr('x'),
                y: lastText.getAttr('y'),
                offsetX: lastText.getAttr('offsetX'),
                offsetY: lastText.getAttr('offsetY'),
                text: lastText.getAttr('text'),
                fontSize: lastText.getAttr('fontSize'),
                fontFamily: 'Calibri',
                fill: lastText.getAttr('fill'),
                padding: 20,
                width: 200,
                align: 'center'
            });
            if (other.getAttr("points")[1] < other.getAttr("points")[3]) complexText.setAttr('offsetY', 50);
            else complexText.setAttr('offsetY', 10);
            arrow = new Konva.Shape({
                x: other.getAttr("x"),
                y: other.getAttr("y"),
                points: other.getAttr("points"),
                stroke: other.getAttr("stroke"),
                strokeWidth: other.getAttr("strokeWidth"),
                sceneFunc: function(context) {
                    drawArrowStyle(context, this);
                },
                id: other.getAttr("id"),
                textObj: complexText,
                draggable: true,
                name: 'arrow',
                config: other.getAttr("config")
            });
        } else {
            var complexText = new Konva.Text({
                x: other.attrs.points[0].x,
                y: other.attrs.points[0].y,
                offsetX: 100,
                offsetY: other.attrs.offsetY,
                text: (other.attrs.config && other.attrs.config.text) ? other.attrs.config.text : "",
                fontSize: 18,
                fontFamily: 'Calibri',
                fill: '#fff',
                padding: 20,
                align: 'center'
            });
            if (other.attrs.points[1] < other.attrs.points[3]) complexText.setAttr('offsetY', 50);
            else complexText.setAttr('offsetY', 10);
            arrow = new Konva.Shape({
                x: other.attrs.x,
                y: other.attrs.y,
                points: other.attrs.points,
                stroke: other.attrs.stroke,
                strokeWidth: other.attrs.strokeWidth,
                sceneFunc: function(context) {
                    drawArrowStyle(context, this);
                },
                id: other.attrs.id,
                draggable: true,
                textObj: complexText,
                name: 'arrow',
                config: other.attrs.config
            });
        }
        if (mainLayer) mainLayer.add(complexText);
        arrow.off('mousedown touchstart');
        arrow.on('mousedown touchstart', function() {
            somethingIsDraw = true;
            $scope.startPointSelectShape = null;
            $scope.endPointSelectShape = null;
            if ($scope.shiftPressed) {} else if ($scope.selectedItemList.length <= 0) {
                $scope.selectedItemList = [];
                selectObjStyle(this);
            }
            if (anchorLayer != null) {
                anchorLayer.destroy();
                anchorLayer = null;
            }
            anchorLayer = new Konva.Layer();
            selectedFrame.add(anchorLayer);
            $scope.arrowArrayPostionAnchor = arrow.getAttr('points');
            for (var index = 0; index < $scope.arrowArrayPostionAnchor.length; index++) {
                createAnchorToArrow($scope.arrowArrayPostionAnchor[index].x, $scope.arrowArrayPostionAnchor[index].y, arrow, index);
            }
            selectedFrame.draw();

        });
        arrow.off('click tap');
        arrow.on('click tap', function() {
            if ($scope.shiftPressed) {
                addToMultiSelect(this);
            } else {
                $scope.selectedItemList = [];
                selectObjStyle(this);
            }
        });
        arrow.off('dragmove');
        arrow.on('dragmove', function() {
            somethingIsDraw = true;
            var offset = {
                x: multiDragPositionStart.x - this.attrs.x,
                y: multiDragPositionStart.y - this.attrs.y
            }
            if ($scope.selectedItemList.length > 0) dragAllSelectedItem(this.getAttr('id'), offset);
            multiDragPositionStart = {
                x: this.getAttr("x"),
                y: this.getAttr("y")
            }
            var textObj = this.getAttr("textObj")
            var pt = this.getAttr("points");
            textObj.setAttr('x', this.getAttr("x") + pt[0].x);
            textObj.setAttr('y', this.getAttr("y") + pt[0].y);
            $scope.startPointSelectShape = null;
            $scope.endPointSelectShape = null;
            if (anchorLayer) {
                anchorLayer.destroy();
                anchorLayer = null;
            }
            anchorLayer = new Konva.Layer();
            selectedFrame.add(anchorLayer);
            $scope.arrowArrayPostionAnchor = this.getAttr('points');
            for (var index = 0; index < $scope.arrowArrayPostionAnchor.length; index++) {
                createAnchorToArrow($scope.arrowArrayPostionAnchor[index].x, $scope.arrowArrayPostionAnchor[index].y, this, index);
            }

            selectedFrame.draw();
        });

        arrow.off('dragstart');
        arrow.off('touchstart');
        arrow.off('mouseup');
        arrow.off('touchend');
        arrow.off('dragend');
        arrow.on('dragstart', function() {
            multiDragPositionStart = {
                x: this.getAttr("x"),
                y: this.getAttr("y")
            }
            somethingIsDraw = true;
            $scope.startPointSelectShape = null;
            $scope.endPointSelectShape = null;
        });

        arrow.on('touchstart', function() {
            somethingIsDraw = true;
            $scope.startPointSelectShape = null;
            $scope.endPointSelectShape = null;
        });

        arrow.on('dragend', function() {
            somethingIsDraw = false;
            $scope.startPointSelectShape = null;
            $scope.endPointSelectShape = null;
            var id = this.getAttr('id');
            for (let i = 0; i < allObjectPerFrame.length; i++) {
                for (let y = 0; y < allObjectPerFrame[i].arrow.length; y++) {
                    if (id == allObjectPerFrame[i].arrow[y].getAttr("id")) {
                        allObjectPerFrame[i].arrow[y].setAttr("x", this.getAttr('x'));
                        allObjectPerFrame[i].arrow[y].setAttr("y", this.getAttr('y'));
                    }
                }
            }
        });

        arrow.on('mouseup', function() {
            somethingIsDraw = false;
            $scope.startPointSelectShape = null;
            $scope.endPointSelectShape = null;
        });

        arrow.on('touchend', function() {
            somethingIsDraw = false;
            $scope.startPointSelectShape = null;
            $scope.endPointSelectShape = null;
        });

        arrow.hitFunc(function(context) {
            drawArrowStyle(context, this, true);
        });

        return arrow;
    }

    function createObjFromOther(other, isNoObj = false) {
        var obj;

        if (!isNoObj) {
            var lastText = other.getAttr("textObj");
            var complexText = new Konva.Text({
                x: lastText.getAttr('x'),
                y: lastText.getAttr('y'),
                offsetX: lastText.getAttr('offsetX'),
                offsetY: lastText.getAttr('offsetY'),
                text: lastText.getAttr('text'),
                fontSize: lastText.getAttr('fontSize'),
                fontFamily: 'Calibri',
                fill: lastText.getAttr('fill'),
                padding: 20,
                width: 200,
                align: 'center'
            });
            obj = new Konva.Image({
                x: other.getAttr("x"),
                y: other.getAttr("y"),
                offsetX: other.getAttr("offsetX"),
                offsetY: other.getAttr("offsetY"),
                rotation: other.getAttr("rotation"),
                image: other.getAttr("image"),
                name: other.getAttr("name"),
                scale: other.getAttr("scale"),
                id: other.getAttr("id"),
                config: other.getAttr("config"),
                textObj: complexText
            });
        } else {
            var newImg = new Image();
            newImg.src = other.attrs.image;
            var complexText = new Konva.Text({
                x: other.attrs.x,
                y: other.attrs.y + other.attrs.height / 4,
                offsetX: 100,
                offsetX: other.attrs.offsetX,
                offsetY: other.attrs.offsetY,
                text: (other.attrs.config && other.attrs.config.text) ? other.attrs.config.text : "",
                fontSize: (other.attrs.config && other.attrs.config.selectedTextSize) ? other.attrs.config.selectedTextSize : 17,
                fontFamily: 'Calibri',
                fill: (other.attrs.config && other.attrs.config.selectedColorText) ? other.attrs.config.selectedColorText : "rgb(255,255,255)",
                padding: 20,
                listening: false,
                align: 'center'
            });
            obj = new Konva.Image({
                x: other.attrs.x,
                y: other.attrs.y,
                offsetX: other.attrs.offsetX,
                offsetY: other.attrs.offsetY,
                rotation: other.attrs.rotation,
                image: newImg,
                scale: {
                    x: other.attrs.scaleX,
                    y: other.attrs.scaleY
                },
                name: other.attrs.name,
                id: other.attrs.id,
                config: other.attrs.config,
                textObj: complexText
            });
        }
        if (mainLayer) mainLayer.add(complexText);
        obj.stroke('transparent');
        obj.strokeWidth(1);
        obj.off('mousedown touchstart');
        obj.on('mousedown touchstart', function() {
            somethingIsDraw = true;
            $scope.startPointSelectShape = null;
            $scope.endPointSelectShape = null;
            if ($scope.shiftPressed) {} else if ($scope.selectedItemList.length <= 0) {
                $scope.selectedItemList = [];
                selectObjStyle(this);
                drawBeforePositionPoint();
                updateNextFrameBeforePosition();
                if ($scope.turnOnRotation) rotateObject();
            }
        });
        obj.hitFunc(function(context) {
            context.beginPath();
            var width = this.getWidth() * this.scaleX();
            var height = this.getHeight() * this.scaleX();
            var procW = 15;
            var procH = 15;
            context.rect(-procW, -procH, width + (procW * 2), height + (procH * 2));
            context.closePath();
            context.fillStrokeShape(this);
        });
        obj.off('click tap');
        obj.on('click tap', function() {
            if ($scope.shiftPressed) {
                addToMultiSelect(this);
            } else {
                $scope.selectedItemList = [];
                selectObjStyle(this);
            }
        });
        obj.off('dragmove');
        obj.on('dragmove', function() {
            var offset = {
                x: multiDragPositionStart.x - this.attrs.x,
                y: multiDragPositionStart.y - this.attrs.y
            }
            if ($scope.selectedItemList.length > 0) dragAllSelectedItem(this.getAttr('id'), offset);
            multiDragPositionStart = {
                x: this.getAttr("x"),
                y: this.getAttr("y")
            }
            var txtObj = obj.getAttr("textObj");
            txtObj.setAttr('x', obj.getAttr("x"));
            txtObj.setAttr('y', obj.getAttr("y") + obj.height() / 2);
            obj.setAttr('textObj', txtObj);
            mainLayer.draw();
        });
        obj.off('dragstart');
        obj.off('touchstart');
        obj.off('mouseup');
        obj.off('touchend');
        obj.off('dragend');
        obj.on('dragstart', function() {
            multiDragPositionStart = {
                x: this.getAttr("x"),
                y: this.getAttr("y")
            }
            somethingIsDraw = true;
            $scope.startPointSelectShape = null;
            $scope.endPointSelectShape = null;
        });

        obj.on('touchstart', function() {
            somethingIsDraw = true;
            $scope.startPointSelectShape = null;
            $scope.endPointSelectShape = null;
        });

        obj.on('mouseup', function() {
            somethingIsDraw = false;
            $scope.startPointSelectShape = null;
            $scope.endPointSelectShape = null;
        });

        obj.on('touchend', function() {
            somethingIsDraw = false;
            $scope.startPointSelectShape = null;
            $scope.endPointSelectShape = null;
        });

        obj.on('dragend', function() {
            somethingIsDraw = false;
            $scope.startPointSelectShape = null;
            $scope.endPointSelectShape = null;
            if ($scope.selectedItemList.length <= 1) {
                drawBeforePositionPoint();
                updateNextFrameBeforePosition();
                if ($scope.turnOnRotation) rotateObject();
            }
        });
        return obj;
    }

    function createShapeObjFromOther(other, isNoObj = false) {
        var shape;
        if (!isNoObj) {
            var lastText = other.getAttr("textObj");
            var complexText = new Konva.Text({
                x: lastText.getAttr('x'),
                y: lastText.getAttr('y'),
                offsetX: lastText.getAttr('offsetX'),
                offsetY: lastText.getAttr('offsetY'),
                text: lastText.getAttr('text'),
                fontSize: lastText.getAttr('fontSize'),
                fontFamily: 'Calibri',
                fill: lastText.getAttr('fill'),
                padding: 20,
                width: 200,
                align: 'center'
            });
            if (other.getAttr("arrowPoint")[0].y < other.getAttr("arrowPoint")[1].y) complexText.setAttr('offsetY', 50);
            else complexText.setAttr('offsetY', 10);
            shape = new Konva.Shape({
                x: other.getAttr("x"),
                y: other.getAttr("y"),
                arrowPoint: other.getAttr("arrowPoint"),
                sceneFunc: function(context) {
                    context.beginPath();
                    context.moveTo(other.getAttr("arrowPoint")[0].x, other.getAttr("arrowPoint")[0].y);
                    for (var i = 1; i < other.getAttr("arrowPoint").length; i++) {
                        context.lineTo(other.getAttr("arrowPoint")[i].x, other.getAttr("arrowPoint")[i].y);
                    }
                    context.closePath();
                    context.fillStrokeShape(this);
                },
                name: other.getAttr("name"),
                fill: other.getAttr("fill"),
                stroke: other.getAttr("stroke"),
                scale: other.getAttr("scale"),
                strokeWidth: other.getAttr("strokeWidth"),
                id: other.getAttr("id"),
                config: other.getAttr("config"),
                draggable: true,
                textObj: complexText
            });
        } else {
            var complexText = new Konva.Text({
                x: other.attrs.arrowPoint[0].x,
                y: other.attrs.arrowPoint[0].y,
                offsetX: 100,
                offsetY: other.attrs.offsetY,
                text: (other.attrs.config && other.attrs.config.text) ? other.attrs.config.text : "",
                fontSize: 18,
                fontFamily: 'Calibri',
                fill: '#fff',
                padding: 20,
                listening: false,
                align: 'center'
            });
            if (other.attrs.arrowPoint[0].y < other.attrs.arrowPoint[1].y) complexText.setAttr('offsetY', 50);
            else complexText.setAttr('offsetY', 10);
            shape = new Konva.Shape({
                x: other.attrs.x,
                y: other.attrs.y,
                arrowPoint: other.attrs.arrowPoint,
                sceneFunc: function(context) {
                    context.beginPath();
                    context.moveTo(other.attrs.arrowPoint[0].x, other.attrs.arrowPoint[0].y);
                    for (var i = 1; i < other.attrs.arrowPoint.length; i++) {
                        context.lineTo(other.attrs.arrowPoint[i].x, other.attrs.arrowPoint[i].y);
                    }
                    context.closePath();
                    context.fillStrokeShape(this);
                },
                name: other.attrs.name,
                fill: other.attrs.fill,
                draggable: true,
                stroke: other.attrs.stroke,
                scale: {
                    x: other.attrs.scaleX,
                    y: other.attrs.scaleY
                },
                strokeWidth: other.attrs.strokeWidth,
                id: other.attrs.id,
                config: other.attrs.config,
                textObj: complexText
            });
        }
        if (mainLayer) mainLayer.add(complexText);
        shape.off('click tap');
        shape.on('click tap', function() {
            if ($scope.shiftPressed) {
                addToMultiSelect(this);
            } else {
                $scope.selectedItemList = [];
                selectObjStyle(this);
            }
        });
        shape.off('mousedown touchstart');
        shape.on('mousedown touchstart', function() {
            somethingIsDraw = true;
            $scope.startPointSelectShape = null;
            $scope.endPointSelectShape = null;
            if ($scope.shiftPressed) {} else if ($scope.selectedItemList.length <= 0) {
                $scope.selectedItemList = [];
                selectObjStyle(this);
            }
            if (anchorLayer != null) {
                anchorLayer.destroy();
                anchorLayer = null;
            }
            anchorLayer = new Konva.Layer();
            selectedFrame.add(anchorLayer);
            $scope.shapeArrayPostionAnchor = this.getAttr('arrowPoint');
            for (var index = 0; index < $scope.shapeArrayPostionAnchor.length; index++) {
                createAnchorToShape($scope.shapeArrayPostionAnchor[index].x, $scope.shapeArrayPostionAnchor[index].y, this, index);
            }

            selectedFrame.draw();
        });

        shape.off('dragmove');
        shape.on('dragmove', function() {
            var offset = {
                x: multiDragPositionStart.x - this.attrs.x,
                y: multiDragPositionStart.y - this.attrs.y
            }
            if ($scope.selectedItemList.length > 0) dragAllSelectedItem(this.getAttr('id'), offset);
            multiDragPositionStart = {
                x: this.getAttr("x"),
                y: this.getAttr("y")
            }
            var textObj = this.getAttr("textObj")
            var pt = this.getAttr("arrowPoint");
            textObj.setAttr('x', this.getAttr("x") + pt[0].x);
            textObj.setAttr('y', this.getAttr("y") + pt[0].y);
            somethingIsDraw = true;
            $scope.startPointSelectShape = null;
            $scope.endPointSelectShape = null;
            if (anchorLayer != null) {
                anchorLayer.destroy();
                anchorLayer = null;
            }
            anchorLayer = new Konva.Layer();
            selectedFrame.add(anchorLayer);
            $scope.shapeArrayPostionAnchor = this.getAttr('arrowPoint');
            for (var index = 0; index < $scope.shapeArrayPostionAnchor.length; index++) {
                createAnchorToShape($scope.shapeArrayPostionAnchor[index].x, $scope.shapeArrayPostionAnchor[index].y, this, index);
            }
            selectedFrame.draw();
        });
        shape.off('dragstart');
        shape.off('touchstart');
        shape.off('mouseup');
        shape.off('touchend');
        shape.off('dragend');
        shape.on('dragstart', function() {
            multiDragPositionStart = {
                x: this.getAttr("x"),
                y: this.getAttr("y")
            }
            somethingIsDraw = true;
            $scope.startPointSelectShape = null;
            $scope.endPointSelectShape = null;
        });

        shape.on('touchstart', function() {
            somethingIsDraw = true;
            $scope.startPointSelectShape = null;
            $scope.endPointSelectShape = null;
        });

        shape.on('dragend', function() {
            somethingIsDraw = false;
            $scope.startPointSelectShape = null;
            $scope.endPointSelectShape = null;
            var id = this.getAttr('id');
            for (let i = 0; i < allObjectPerFrame.length; i++) {
                for (let y = 0; y < allObjectPerFrame[i].shapes.length; y++) {
                    if (id == allObjectPerFrame[i].shapes[y].getAttr("id")) {
                        allObjectPerFrame[i].shapes[y].setAttr("x", this.getAttr('x'));
                        allObjectPerFrame[i].shapes[y].setAttr("y", this.getAttr('y'));
                    }
                }
            }
        });

        shape.on('mouseup', function() {
            somethingIsDraw = false;
            $scope.startPointSelectShape = null;
            $scope.endPointSelectShape = null;
        });

        shape.on('touchend', function() {
            somethingIsDraw = false;
            $scope.startPointSelectShape = null;
            $scope.endPointSelectShape = null;
        });
        return shape;
    }

    function createTextFromOther(other, isNoObj = false) {
        var obj;
        if (!isNoObj) {
            obj = new Konva.Text({
                x: other.getAttr("x"),
                y: other.getAttr("y"),
                offsetX: other.getAttr("offsetX"),
                offsetY: other.getAttr("offsetY"),
                rotation: other.getAttr("rotation"),
                fontSize: other.getAttr("fontSize"),
                text: other.getAttr("text"),
                name: other.getAttr("name"),
                scale: other.getAttr("scale"),
                fill: other.getAttr("fill"),
                align: other.getAttr("align"),
                id: other.getAttr("id"),
                config: other.getAttr("config")
            });
        } else {
            obj = new Konva.Text({
                x: other.attrs.x,
                y: other.attrs.y,
                offsetX: other.attrs.offsetX,
                offsetY: other.attrs.offsetY,
                rotation: other.attrs.rotation,
                fontSize: other.attrs.fontSize,
                text: other.attrs.text,
                fill: other.attrs.fill,
                align: other.attrs.align,
                scale: {
                    x: other.attrs.scaleX,
                    y: other.attrs.scaleY
                },
                name: other.attrs.name,
                id: other.attrs.id,
                config: other.attrs.config
            });
        }
        obj.off('mousedown touchstart');
        obj.on('mousedown touchstart', function() {
            selectObjStyle(this);
        });
        selectObjStyle(obj);
        obj.off('dblclick');
        obj.on('dblclick', () => {
            // create textarea over canvas with absolute position
            // first we need to find its positon
            var textPosition = obj.getAbsolutePosition();
            var stageBox = selectedFrame.getContainer().getBoundingClientRect();
            var areaPosition = {
                x: textPosition.x + stageBox.left,
                y: textPosition.y + stageBox.top
            };
            // create textarea and style it
            var textarea = document.createElement('textarea');
            document.body.appendChild(textarea);
            textarea.value = obj.text();
            textarea.style.position = 'absolute';
            textarea.style.top = areaPosition.y + 5 + 'px';
            textarea.style.left = areaPosition.x - 100 + 'px';
            textarea.style.zIndex = '300';
            textarea.style.width = "200px";
            textarea.style.color = "white";
            textarea.style.backogrund = "rgba(0, 0, 0, 0.34)";
            textarea.focus();
            textarea.addEventListener('keydown', function(e) {
                // hide on enter
                if (e.keyCode === 13) {
                    obj.text(textarea.value);
                    selectedFrame.draw();
                    document.body.removeChild(textarea);
                }
            });
        })
        return obj;
    }

    function addFrame() {
        $scope.selectedItemList = [];
        selectObjStyle(null);
        allObjectPerFrame.push({ arrow: [], obj: [], shapes: [], text: [] });
        var beforeFrameNumber = allObjectPerFrame.length - 2;
        currentObjPerFrame = allObjectPerFrame.length - 1;

        for (var i = 0; i < allObjectPerFrame[beforeFrameNumber].arrow.length; i++) {
            var arrowBef = allObjectPerFrame[beforeFrameNumber].arrow[i];
            var obj = createArrowObjFromOther(arrowBef);
            allObjectPerFrame[currentObjPerFrame].arrow.push(obj);
        }
        for (var i = 0; i < allObjectPerFrame[beforeFrameNumber].obj.length; i++) {
            var objBef = allObjectPerFrame[beforeFrameNumber].obj[i];
            var obj = createObjFromOther(objBef);
            allObjectPerFrame[currentObjPerFrame].obj.push(obj);
        }
        for (var i = 0; i < allObjectPerFrame[beforeFrameNumber].shapes.length; i++) {
            var objBef = allObjectPerFrame[beforeFrameNumber].shapes[i];
            var obj = createShapeObjFromOther(objBef);
            allObjectPerFrame[currentObjPerFrame].shapes.push(obj);
        }
        for (var i = 0; i < allObjectPerFrame[beforeFrameNumber].text.length; i++) {
            var objBef = allObjectPerFrame[beforeFrameNumber].text[i];
            var obj = createTextFromOther(objBef);
            allObjectPerFrame[currentObjPerFrame].text.push(obj);
        }
        $scope.changeCategories($scope.mouseActionType.MOVE);
    }

    $scope.deleteFrame = function() {
        if (allObjectPerFrame.length <= 1) {
            notify.localNotify("Uwaga", "Nie można usunąć jedynej klatki animacji");
            return;
        }
        $rootScope.showModalWindow("Nieodwracalnie usunie klatkę animacji wraz z zawartością", function() {
            var frame = allObjectPerFrame.length - 1;
            allObjectPerFrame.splice(frame, 1);
            $(".timeElement").last().remove();
            for (let i = 0; i < anchorHistory.length; i++) {
                if (anchorHistory[i].frame == frame) {
                    anchorHistory.splice(i, 1);
                    break;
                }
            }
            changeFrame(frame - 1);
            drawNewStage();
        });
    }

    function changeFrame(count, frameContener = allObjectPerFrame) {
        currentObjPerFrame = count;
        updateNextFrameBeforePosition(frameContener);
        $(".timeElement").each(function() {
            $(this).css('border-color', "");
        });
        $(".timeElement").eq(count).css('border-color', "#dd4213");
    }

    function updateNextFrameBeforePosition(frameContener = allObjectPerFrame) {
        if (frameContener != allObjectPerFrame) return;
        for (var i = 0; i < frameContener[currentObjPerFrame].obj.length; i++) {
            var objBef = frameContener[currentObjPerFrame].obj[i];
            var objId = objBef.getAttr("id");
            if (isAnchorHistoryFor(currentObjPerFrame + 1, objId)) {
                getAnchorHistoryFor(currentObjPerFrame + 1, objId).start = {
                    x: objBef.getAttr("x"),
                    y: objBef.getAttr("y"),
                };
            }
        }
    }

    function isAnchorHistoryFor(frame, id) {
        for (var i = 0; i < anchorHistory.length; i++) {
            if (anchorHistory[i].frame == frame) {
                for (var x = 0; x < anchorHistory[i].history.length; x++) {
                    if (anchorHistory[i].history[x].id == id) {
                        return true;
                    }
                }
                return false;
            }
        }
        return false;
    }

    function getAnchorHistoryFor(frame, id) {
        for (var i = 0; i < anchorHistory.length; i++) {
            if (anchorHistory[i].frame == frame) {
                for (var x = 0; x < anchorHistory[i].history.length; x++) {
                    if (anchorHistory[i].history[x].id == id) {
                        return anchorHistory[i].history[x].anchor;
                    }
                }
            }
        }
    }

    function saveToAnchorHistory(frame, id, anchor) {
        for (var i = 0; i < anchorHistory.length; i++) {
            if (anchorHistory[i].frame == frame) {
                for (var x = 0; x < anchorHistory[i].history.length; x++) {
                    if (anchorHistory[i].history[x].id == id) {
                        anchorHistory[i].history[x].anchor = anchor;
                        return true;
                    }
                }
                anchorHistory[i].history.push({
                    id: id,
                    anchor: anchor
                });

                return true;
            }
        }
        anchorHistory.push({
            frame: frame,
            history: [{
                id: id,
                anchor: anchor
            }]
        });
    }

    function deleteAnchor(frame, id) {
        for (var i = 0; i < anchorHistory.length; i++) {
            if (anchorHistory[i].frame == frame) {
                for (var x = 0; x < anchorHistory[i].history.length; x++) {
                    if (anchorHistory[i].history[x].id == id) {
                        anchorHistory[i].history[x].id = null;
                        anchorHistory[i].history[x].anchor = null;
                        anchorHistory[i].history.splice(x, 1);
                        return;
                    }
                }
            }
        }
    }

    function drawNewStage(container = 'canvasContainer', frameContainer = allObjectPerFrame) {
        $scope.selectedItemList = [];
        if ($scope.onlyPlayer) container = 'canvasPlayerContainer';
        if (mainLayer != null) {
            selectedFrame.off('contentClick contentTap');
            selectedFrame.destroy();
            selectedFrame = null;
        }
        selectedFrame = new Konva.Stage({
            container: container,
            width: stageWidth,
            height: stageHeight
        });

        if (curveLayer != null) {
            curveLayer.destroy();
            curveLayer = null;
        }
        curveLayer = new Konva.Layer();
        if (lineLayer != null) {
            lineLayer.destroy();
            lineLayer = null;
        }
        lineLayer = new Konva.Layer();
        if (anchorLayer != null) {
            anchorLayer.destroy();
            anchorLayer = null;
        }
        anchorLayer = new Konva.Layer();

        if (mainLayer != null) {
            mainLayer.destroy();
            mainLayer = null;
        }
        mainLayer = new Konva.Layer();

        if (fieldLayer != null) {
            fieldLayer.destroy();
            fieldLayer = null;
        }
        fieldLayer = new Konva.Layer();
        var conImg = new Konva.Image({
            x: 0,
            y: 0,
            image: $scope.fieldImage,
            width: selectedFrame.getWidth(),
            height: selectedFrame.getHeight(),
            id: "field"
        });
        mainLayer.add(conImg);

        for (var i = 0; i < frameContainer[currentObjPerFrame].shapes.length; i++) {
            var obb = frameContainer[currentObjPerFrame].shapes[i];
            var obj = createShapeObjFromOther(obb);
            frameContainer[currentObjPerFrame].shapes[i] = obj;
            mainLayer.add(obj);
        }

        for (var i = 0; i < frameContainer[currentObjPerFrame].obj.length; i++) {
            var obb = frameContainer[currentObjPerFrame].obj[i];
            var obj = createObjFromOther(obb);
            frameContainer[currentObjPerFrame].obj[i] = obj;
            mainLayer.add(frameContainer[currentObjPerFrame].obj[i]);
        }

        for (var i = 0; i < frameContainer[currentObjPerFrame].arrow.length; i++) {
            var obb = frameContainer[currentObjPerFrame].arrow[i];
            var obj = createArrowObjFromOther(obb);
            frameContainer[currentObjPerFrame].arrow[i] = obj;
            mainLayer.add(obj);
        }

        for (var i = 0; i < frameContainer[currentObjPerFrame].text.length; i++) {
            var obb = frameContainer[currentObjPerFrame].text[i];
            var obj = createTextFromOther(obb);
            frameContainer[currentObjPerFrame].text[i] = obj;
            mainLayer.add(obj);
        }

        selectedFrame.add(mainLayer);

        $scope.selectedObjImg = null;
        $scope.selectedArrow = null;
        $scope.arrowPointCount = 0;
        $scope.arrowPoint = [];
        $scope.shapePointCount = 0;
        $scope.shapePoint = [];
        $scope.lastSelected = null;
        $scope.actualMouseAction = $scope.mouseActionType.MOVE;
        $(".categories").each(function() {
            $(this).css('border-color', "");
        });
        $(".categories").eq(0).css('border-color', "#dd4213");

        if (container == 'canvasContainer') {

            selectedFrame.add(lineLayer);
            selectedFrame.add(curveLayer);
            selectedFrame.add(anchorLayer);
            selectedFrame.on('contentClick contentTap', function(e) {
                clickOnContent();
            });

            selectedFrame.on('mousedown touchstart', function(e) {
                onMuseDown();
            });

            selectedFrame.on('mousemove touchmove', function(e) {
                onMuseMove();
            });

            selectedFrame.on('mouseup touchend', function(e) {
                onMuseUp();
            });

            selectedFrame.find(".movementObject").each(function(shape) {
                shape.on('mouseenter', function() {
                    if ($scope.actualMouseAction == $scope.mouseActionType.MOVE) {
                        selectedFrame.container().style.cursor = 'move';
                    }
                });
                shape.on('mouseleave', function() {
                    selectedFrame.container().style.cursor = 'default';
                });
            });

            selectedFrame.find(".arrow").each(function(shape) {
                shape.on('mouseenter', function() {
                    if ($scope.actualMouseAction == $scope.mouseActionType.MOVE) {
                        selectedFrame.container().style.cursor = 'move';
                    }
                });
                shape.on('mouseleave', function() {
                    selectedFrame.container().style.cursor = 'default';
                });
            });

            selectedFrame.find(".shapes").each(function(shape) {
                shape.on('mouseenter', function() {
                    if ($scope.actualMouseAction == $scope.mouseActionType.MOVE) {
                        selectedFrame.container().style.cursor = 'move';
                    }
                });
                shape.on('mouseleave', function() {
                    selectedFrame.container().style.cursor = 'default';
                });
            });
            var shapes = selectedFrame.find(".movementObject");
            shapes.each(function(shape) {
                shape.draggable(true);
            });
        }
        checkHelperNet();
        resize();
    }

    function redrawMultiSelectShape() {
        $scope.$apply(function() {
            if (selectShapeLayer != null) {
                selectShapeLayer.destroy();
                selectShapeLayer = null;
            }
            selectShapeLayer = new Konva.Layer();

            var start = $scope.startPointSelectShape;
            var end = $scope.endPointSelectShape;

            var poly = new Konva.Line({
                points: [start.x, start.y, end.x, start.y, end.x, end.y, start.x, end.y],
                fill: 'rgba(63, 127, 191, 0.25)',
                stroke: 'rgb(63, 127, 191)',
                strokeWidth: 2,
                closed: true
            });

            selectShapeLayer.add(poly);
            selectedFrame.add(selectShapeLayer);
        });
    }

    function selectFromMultiSelectShape() {
        if (!$scope.startPointSelectShape || !$scope.endPointSelectShape) return;

        if (anchorLayer) {
            anchorLayer.destroy();
            anchorLayer = null;
        }
        anchorLayer = new Konva.Layer();

        $scope.$apply(function() {
            var maxX = Math.max($scope.startPointSelectShape.x, $scope.endPointSelectShape.x);
            var minX = Math.min($scope.startPointSelectShape.x, $scope.endPointSelectShape.x);
            var maxY = Math.max($scope.startPointSelectShape.y, $scope.endPointSelectShape.y);
            var minY = Math.min($scope.startPointSelectShape.y, $scope.endPointSelectShape.y);
            $scope.lastSelected = null;
            $scope.startPointSelectShape = null;
            $scope.endPointSelectShape = null;
            $scope.selectedItemList = [];

            var isSameConfig = true;
            var confName = '';

            var shapes = selectedFrame.find(".movementObject");
            shapes.each(function(shape) {
                shape.stroke('transparent');
                var x = shape.getAttr("x");
                var y = shape.getAttr("y");
                if (x >= minX && x <= maxX && y >= minY && y <= maxY) {
                    $scope.selectedItemList.push(shape);
                    shape.strokeWidth(1);
                    shape.stroke('red');
                    var config = shape.getAttr("config");
                    if (!config) isSameConfig = false;
                    else {
                        if (confName == '') {
                            confName = config.confName;
                        } else if (confName != config.confName) {
                            isSameConfig = false;
                        }
                    }
                }
            });


            var shapes = selectedFrame.find(".arrow");
            shapes.each(function(shape) {
                shape.stroke('white');
                var x = shape.getAttr("x");
                var y = shape.getAttr("y");
                var shapePoint = shape.getAttr("points");

                var isAllInSelectShape = true;

                for (let a = 0; a < shapePoint.length; a++) {
                    if (!((shapePoint[a].x + x) >= minX && (shapePoint[a].x + x) <= maxX && (shapePoint[a].y + y) >= minY && (shapePoint[a].y + y) <= maxY)) {
                        isAllInSelectShape = false;
                        break;
                    }
                }

                if (isAllInSelectShape) {
                    $scope.selectedItemList.push(shape);
                    shape.stroke('red');
                    var config = shape.getAttr("config");
                    if (!config) isSameConfig = false;
                    else {
                        if (confName == '') {
                            confName = config.confName;
                        } else if (confName != config.confName) {
                            isSameConfig = false;
                        }
                    }
                }
            });
            var shapes = selectedFrame.find(".shapes");
            shapes.each(function(shape) {
                var fillColor = shape.getAttr('fill');
                fillColor.replace('0.4', '1');
                shape.stroke(fillColor);
                var x = shape.getAttr("x");
                var y = shape.getAttr("y");
                var shapePoint = shape.getAttr("arrowPoint");
                var isAllInSelectShape = true;

                for (let a = 0; a < shapePoint.length; a++) {
                    if (!((shapePoint[a].x + x) >= minX && (shapePoint[a].x + x) <= maxX && (shapePoint[a].y + y) >= minY && (shapePoint[a].y + y) <= maxY)) {
                        isAllInSelectShape = false;
                        break;
                    }
                }

                if (isAllInSelectShape) {
                    $scope.selectedItemList.push(shape);
                    shape.stroke('red');
                    var config = shape.getAttr("config");
                    if (!config) isSameConfig = false;
                    else {
                        if (confName == '') {
                            confName = config.confName;
                        } else if (confName != config.confName) {
                            isSameConfig = false;
                        }
                    }
                }
            });


            if (isSameConfig && $scope.selectedItemList.length > 0) {
                $scope.lastSelected = $scope.selectedItemList[0];
                showInConfigObjData($scope.selectedItemList[0]);
            }

            if (selectShapeLayer != null) {
                selectShapeLayer.destroy();
                selectShapeLayer = null;
            }
            $scope.showObjConfig();
            selectedFrame.draw();
        });
    }

    function checkHelperNet() {
        if ($scope.turnOnHelperNet) {
            var helperLayer = new Konva.Layer();
            var canvasWidth = selectedFrame.getAttr('width');
            var canvasHeight = selectedFrame.getAttr('height');
            var pos = canvasWidth / 16;

            while (pos < canvasWidth) {
                var whiteLine = new Konva.Line({
                    points: [pos, 0, pos, canvasHeight],
                    stroke: 'white',
                    strokeWidth: 1,
                    lineCap: 'round',
                    lineJoin: 'round'
                });
                helperLayer.add(whiteLine);
                pos += canvasWidth / 16;
            }
            pos = canvasHeight / 10;
            while (pos < canvasHeight) {
                var whiteLine = new Konva.Line({
                    points: [0, pos, canvasWidth, pos],
                    stroke: 'white',
                    strokeWidth: 1,
                    lineCap: 'round',
                    lineJoin: 'round'
                });
                helperLayer.add(whiteLine);
                pos += canvasHeight / 10;
            }
            selectedFrame.add(helperLayer);
        }
    }

    function goToFull() {
        $scope.fullElement = document.getElementById("animCreator");
        if ($scope.fullElement.requestFullScreen) {
            $scope.fullElement.requestFullscreen();
        } else if ($scope.fullElement.webkitRequestFullScreen) {
            $scope.fullElement.webkitRequestFullScreen();
        } else if ($scope.fullElement.mozRequestFullScreen) {
            $scope.fullElement.mozRequestFullScreen();
        }
    }

    $scope.endFromFull = function(endFromCreator = true) {
        if (endFromCreator) $scope.showAnimCreator = false;
        if (document.cancelFullScreen) {
            document.cancelFullScreen();
        } else if (document.webkitCancelFullScreen) {
            document.webkitCancelFullScreen();
        } else if (document.mozCancelFullScreen) {
            document.mozCancelFullScreen();
        }
    }

    function resize() {
        var container = isPlayerOpen || $scope.onlyPlayer ? 'canvasPlayerContainer' : 'canvasContainer';
        if ($scope.onlyPlayer) container = 'canvasPlayerContainer';
        container = document.querySelector('#' + container);
        if (!container) return;

        var containerWidth = container.offsetWidth;

        $scope.orientation = $(window).width() > $(window).height() ? 'sd' : 'landscape';
        if ($scope.orientation == 'sd' && isPlayerOpen) {
            var containerHeight = container.offsetHeight;
            containerWidth = containerHeight * 100 / 60;
        }
        var scale = containerWidth / stageWidth;

        selectedFrame.width(stageWidth * scale);
        selectedFrame.height(stageHeight * scale);
        selectedFrame.scale({ x: scale, y: scale });
        selectedFrame.draw();
    }

    function drawBeforePositionPointAllVersion(itemToDrawBef) {
        if (currentObjPerFrame <= 0 || itemToDrawBef == null ||
            itemToDrawBef.getAttr('name') !== 'movementObject') return;

        var id = itemToDrawBef.getAttr('id');
        var lastObj = null;

        for (var i = 0; i < allObjectPerFrame[currentObjPerFrame - 1].obj.length; i++) {
            var obb = allObjectPerFrame[currentObjPerFrame - 1].obj[i].getAttr("id");
            if (obb == id) {
                lastObj = allObjectPerFrame[currentObjPerFrame - 1].obj[i];
                break;
            }
        }
        if (lineLayer) lineLayer.destroy();
        if (anchorLayer) anchorLayer.destroy();
        if (anchorLayer) curveLayer.destroy();
        anchorLayer = new Konva.Layer();
        curveLayer = new Konva.Layer();
        selectedFrame.add(curveLayer);
        selectedFrame.add(anchorLayer);


        anchorLayer.off('beforeDraw');
        anchorLayer.on('beforeDraw', function() {
            drawCurves();
            updateDottedLines();
        });

        if (lastObj !== null) {
            var quadLine = new Konva.Line({
                dash: [10, 10, 0, 10],
                strokeWidth: 3,
                stroke: 'black',
                lineCap: 'round',
                id: 'quadLine',
                opacity: 0.3,
                points: [0, 0]
            });
            anchorLayer.add(quadLine);

            if (isAnchorHistoryFor(currentObjPerFrame, id)) {
                var history = getAnchorHistoryFor(currentObjPerFrame, id);
                var newo = {
                    x: itemToDrawBef.getAttr("x"),
                    y: itemToDrawBef.getAttr("y")
                };
                quadCurves = {
                    start: createAnchorPoint(history.start.x, history.start.y, 'start'),
                    control: createAnchorPoint(history.control.x, history.control.y, 'ster'),
                    end: createAnchorPoint(newo.x, newo.y, 'end')
                };
            } else {
                var last = {
                    x: lastObj.getAttr("x"),
                    y: lastObj.getAttr("y")
                };
                var newo = {
                    x: itemToDrawBef.getAttr("x"),
                    y: itemToDrawBef.getAttr("y")
                };
                quadCurves = {
                    start: createAnchorPoint(last.x, last.y, 'start'),
                    control: createAnchorPoint(Math.min(last.x, newo.x) + Math.abs(last.x - newo.x) / 2.0, Math.min(last.y, newo.y) + Math.abs(last.y - newo.y) / 2.0, 'ster'),
                    end: createAnchorPoint(newo.x, newo.y, 'end')
                };
            }

            saveAnchorPoint(currentObjPerFrame, itemToDrawBef, quadCurves);

            if (quadCurves.start.getAttr("x") == quadCurves.end.getAttr("x") &&
                quadCurves.start.getAttr("y") == quadCurves.end.getAttr("y")) return;


            if ($scope.turnOnRotation) rotateObject();
            selectedFrame.draw();
        } else {
            quadCurves = null;
        }
    }

    function drawBeforePositionPoint() {
        if ($scope.selectedItemList.length > 0) {
            for (let d = 0; d < $scope.selectedItemList.length; d++) {
                drawBeforePositionPointAllVersion($scope.selectedItemList[d]);
            }
        } else {
            drawBeforePositionPointAllVersion($scope.lastSelected);
        }
    }

    function createAnchorPoint(x, y, type) {
        var anchor = new Konva.Circle({
            x: x,
            y: y,
            radius: (type == 'end' || type == 'start') ? 5 : 8,
            stroke: (type == 'ster') ? '#ddd' : '#dd4213',
            fill: (type == 'ster') ? '#dda613' : '#dd4213',
            strokeWidth: 1,
            visible: (type == 'ster' || type == 'start'),
            draggable: (type == 'ster')
        });
        // add hover styling
        anchor.on('mouseover touchstart', function() {
            if (type == 'ster') {
                document.body.style.cursor = 'pointer';
                this.setStrokeWidth(3);
                anchorLayer.draw();
            }
        });
        anchor.on('mouseout touchend', function() {
            if (type == 'ster') {
                document.body.style.cursor = 'default';
                this.setStrokeWidth(1);
                anchorLayer.draw();
            }
        });
        anchor.on('dragend', function() {
            somethingIsDraw = false;
            $scope.startPointSelectShape = null;
            $scope.endPointSelectShape = null;
            if (type == 'ster') {
                saveAnchorPoint();
                drawCurves();
                updateDottedLines();
                if ($scope.turnOnRotation) rotateObject();
            }
        });

        anchor.on('dragstart', function() {
            somethingIsDraw = true;
            $scope.startPointSelectShape = null;
            $scope.endPointSelectShape = null;
        });

        anchor.on('touchstart', function() {
            somethingIsDraw = true;
            $scope.startPointSelectShape = null;
            $scope.endPointSelectShape = null;
        });

        anchor.on('mouseup', function() {
            somethingIsDraw = false;
            $scope.startPointSelectShape = null;
            $scope.endPointSelectShape = null;
        });

        anchor.on('touchend', function() {
            somethingIsDraw = false;
            $scope.startPointSelectShape = null;
            $scope.endPointSelectShape = null;
        });
        anchorLayer.add(anchor);
        return anchor;
    }

    function drawCurves() {
        if (quadCurves && $scope.selectedItemList.length <= 1) {
            var context = curveLayer.getContext();
            context.clear();
            context.beginPath();
            var scale = selectedFrame.getAttr('scaleX');
            context.moveTo(quadCurves.start.getAttr("x") * scale, quadCurves.start.getAttr("y") * scale);
            context.quadraticCurveTo(quadCurves.control.getAttr("x") * scale, quadCurves.control.getAttr("y") * scale, quadCurves.end.getAttr("x") * scale, quadCurves.end.getAttr("y") * scale);
            context.setAttr('strokeStyle', 'black');
            context.setAttr('lineWidth', 2);
            context.stroke();
            context.setAttr('strokeStyle', 'white');

        }
    }

    function updateDottedLines() {
        if (quadCurves) {
            var q = quadCurves;
            if (!(anchorLayer && anchorLayer.get('#quadLine').length > 0)) return;
            var quadLine = anchorLayer.get('#quadLine')[0];
            quadLine.setPoints([q.start.attrs.x, q.start.attrs.y, q.control.attrs.x, q.control.attrs.y, q.end.attrs.x, q.end.attrs.y]);
        }
    }

    function saveAnchorPoint(currentFrame = null, element = null, quadCurv = null) {
        if (!$scope.lastSelected && !element) return;
        var quadCurvess = quadCurv ? quadCurv : quadCurves;

        var el = element ? element : $scope.lastSelected;
        if (!el) return;

        if (quadCurvess.start.getAttr("x") == quadCurvess.end.getAttr("x") &&
            quadCurvess.start.getAttr("y") == quadCurvess.end.getAttr("y")) return;

        var anchorToSave = {
            start: {
                x: quadCurvess.start.getAttr("x"),
                y: quadCurvess.start.getAttr("y"),
            },
            control: {
                x: quadCurvess.control.getAttr("x"),
                y: quadCurvess.control.getAttr("y"),
            },
            end: {
                x: el.getAttr("x"),
                y: el.getAttr("y"),
            }
        };
        saveToAnchorHistory(currentFrame ? currentFrame : currentObjPerFrame, el.getAttr("id"), anchorToSave);
        if ($scope.turnOnRotation) rotateObject();

        selectedFrame.draw();
    }

    function removeAnchor() {
        deleteAnchor(currentObjPerFrame, $scope.lastSelected.getAttr("id"));
    }

    function getPosOnCurves(p1, p2, p3, percent) {
        t = percent;
        x = (1 - t) * (1 - t) * p1.x + 2 * (1 - t) * t * p2.x + t * t * p3.x;
        y = (1 - t) * (1 - t) * p1.y + 2 * (1 - t) * t * p2.y + t * t * p3.y;
        return {
            x: x,
            y: y
        }
    }

    function rotateObject(id = null, obj = $scope.lastSelected) {
        if ($scope.selectedItemList.length > 0) {
            for (let x = 0; x < $scope.selectedItemList.length; x++) {
                var id = $scope.selectedItemList[x].getAttr("id");
                if (isAnchorHistoryFor(currentObjPerFrame, id)) {
                    var actual = getAnchorHistoryFor(currentObjPerFrame, id);
                    var p1 = getPosOnCurves(actual.start, actual.control, actual.end, 0.9);
                    var p2 = getPosOnCurves(actual.start, actual.control, actual.end, 1);
                    var rotOffset = 0;
                    if (p1.x > p2.x) rotOffset = 180;
                    var a = (p2.y - p1.y) / (p2.x - p1.x);
                    var degree = ((Math.atan(a) * 180) / Math.PI);
                    $scope.selectedItemList[x].rotation(degree + rotOffset);
                } else if (isAnchorHistoryFor(currentObjPerFrame + 1, id)) {
                    var actual = getAnchorHistoryFor(currentObjPerFrame + 1, id);
                    var p1 = getPosOnCurves(actual.start, actual.control, actual.end, 0);
                    var p2 = getPosOnCurves(actual.start, actual.control, actual.end, 0.1);
                    var rotOffset = 0;
                    if (p1.x > p2.x) rotOffset = 180;
                    var a = (p2.y - p1.y) / (p2.x - p1.x);
                    var degree = ((Math.atan(a) * 180) / Math.PI);
                    $scope.selectedItemList[x].rotation(degree + rotOffset);
                }
                selectedFrame.draw();
                showInConfigObjData($scope.selectedItemList[x]);
            }
        } else {
            if (id == null) {
                if ($scope.lastSelected && $scope.lastSelected != null) {
                    id = $scope.lastSelected.getAttr("id");
                } else {
                    return;
                }
            }
            if (isAnchorHistoryFor(currentObjPerFrame, id)) {
                var actual = getAnchorHistoryFor(currentObjPerFrame, id);
                var p1 = getPosOnCurves(actual.start, actual.control, actual.end, 0.9);
                var p2 = getPosOnCurves(actual.start, actual.control, actual.end, 1);
                var rotOffset = 0;
                if (p1.x > p2.x) rotOffset = 180;
                var a = (p2.y - p1.y) / (p2.x - p1.x);
                var degree = ((Math.atan(a) * 180) / Math.PI);
                obj.rotation(degree + rotOffset);
            } else if (isAnchorHistoryFor(currentObjPerFrame + 1, id)) {
                var actual = getAnchorHistoryFor(currentObjPerFrame + 1, id);
                var p1 = getPosOnCurves(actual.start, actual.control, actual.end, 0);
                var p2 = getPosOnCurves(actual.start, actual.control, actual.end, 0.1);
                var rotOffset = 0;
                if (p1.x > p2.x) rotOffset = 180;
                var a = (p2.y - p1.y) / (p2.x - p1.x);
                var degree = ((Math.atan(a) * 180) / Math.PI);
                obj.rotation(degree + rotOffset);
            }
            selectedFrame.draw();
            showInConfigObjData(obj);
        }


    }

    function showInConfigObjData(obj = $scope.lastSelected) {
        if (obj == null) return;
        var rot = obj.getAttr("rotation");
        var scl = obj.getAttr("scale").x;
        $("#rotationConfig").parent().find("span").first().html(rot + "'");
        $("#scaleConfig").parent().find("span").first().html(scl);
        $("#rotationConfig").val(rot);
        $("#scaleConfig").val(scl);
    }

    function createFrameToAnim() {
        selectObjStyle(null);
        var animationFrames = [];

        for (var i = 0; i < allObjectPerFrame.length; i++) {
            var objs = allObjectPerFrame[i].obj;
            var arrows = allObjectPerFrame[i].arrow;
            var shapes = allObjectPerFrame[i].shapes;
            var text = allObjectPerFrame[i].text;

            if (allObjectPerFrame[i + 1]) {
                for (var x = 0; x < $scope.iloscklatekPomiedzyGlownymi; x++) {
                    arrowsArray = []
                    for (var z = 0; z < arrows.length; z++) {
                        var lastText = arrows[z].getAttr("textObj");
                        var complexText = new Konva.Text({
                            x: lastText.getAttr('x'),
                            y: lastText.getAttr('y'),
                            offsetX: lastText.getAttr('offsetX'),
                            offsetY: lastText.getAttr('offsetY'),
                            text: lastText.getAttr('text'),
                            fontSize: lastText.getAttr('fontSize'),
                            fontFamily: 'Calibri',
                            fill: lastText.getAttr('fill'),
                            padding: 20,
                            width: 200,
                            align: 'center'
                        });
                        if (arrows[z].getAttr("points")[0].y < arrows[z].getAttr("points")[1].y) complexText.setAttr('offsetY', 50);
                        else complexText.setAttr('offsetY', 10);
                        var arrow = new Konva.Shape({
                            x: arrows[z].getAttr("x"),
                            y: arrows[z].getAttr("y"),
                            offsetX: arrows[z].getAttr('offsetX'),
                            offsetY: arrows[z].getAttr('offsetY'),
                            points: arrows[z].getAttr("points"),
                            stroke: arrows[z].getAttr("stroke"),
                            strokeWidth: arrows[z].getAttr("strokeWidth"),
                            sceneFunc: function(context) {
                                drawArrowStyle(context, this);
                            },
                            id: arrows[z].getAttr("id"),
                            textObj: complexText,
                            name: 'arrow',
                            config: arrows[z].getAttr("config")
                        });
                        arrowsArray.push(arrow);
                    }

                    shapesArray = []
                    for (var z = 0; z < shapes.length; z++) {
                        var lastText = shapes[z].getAttr("textObj");
                        var complexText = new Konva.Text({
                            x: lastText.getAttr('x'),
                            y: lastText.getAttr('y'),
                            offsetX: lastText.getAttr('offsetX'),
                            offsetY: lastText.getAttr('offsetY'),
                            text: lastText.getAttr('text'),
                            fontSize: lastText.getAttr('fontSize'),
                            fontFamily: 'Calibri',
                            fill: lastText.getAttr('fill'),
                            padding: 20,
                            width: 200,
                            align: 'center'
                        });
                        var shape = new Konva.Shape({
                            x: shapes[z].getAttr("x"),
                            y: shapes[z].getAttr("y"),
                            offsetX: shapes[z].getAttr('offsetX'),
                            offsetY: shapes[z].getAttr('offsetY'),
                            arrowPoint: shapes[z].getAttr("arrowPoint"),
                            sceneFunc: shapes[z].getAttr("sceneFunc"),
                            name: shapes[z].getAttr("name"),
                            fill: shapes[z].getAttr("fill"),
                            stroke: shapes[z].getAttr("stroke"),
                            scale: shapes[z].getAttr("scale"),
                            strokeWidth: shapes[z].getAttr("strokeWidth"),
                            id: shapes[z].getAttr("id"),
                            config: shapes[z].getAttr("config"),
                            textObj: complexText
                        });
                        shapesArray.push(shape);
                    }

                    textArray = []
                    for (var z = 0; z < text.length; z++) {

                        var obj = new Konva.Text({
                            x: text[z].getAttr("x"),
                            y: text[z].getAttr("y"),
                            offsetX: text[z].getAttr("offsetX"),
                            offsetY: text[z].getAttr("offsetY"),
                            rotation: text[z].getAttr("rotation"),
                            fontSize: text[z].getAttr("fontSize"),
                            text: text[z].getAttr("text"),
                            name: text[z].getAttr("name"),
                            fill: text[z].getAttr("fill"),
                            align: text[z].getAttr("align"),
                            scale: text[z].getAttr("scale"),
                            id: text[z].getAttr("id"),
                            config: text[z].getAttr("config")
                        });
                        textArray.push(obj);
                    }

                    objectArrays = []
                    objs = allObjectPerFrame[i + 1].obj;
                    for (var z = 0; z < objs.length; z++) {
                        if (isAnchorHistoryFor(i + 1, objs[z].getAttr("id"))) {
                            var history = getAnchorHistoryFor(i + 1, objs[z].getAttr("id"));
                            var p1, p2, a, degree;

                            // check if user rotate it
                            p1 = getPosOnCurves(history.start, history.control, history.end, 0.9);
                            p2 = getPosOnCurves(history.start, history.control, history.end, 1);
                            var rotOffset = 0;
                            if (p1.x > p2.x) rotOffset = 180;
                            a = (p2.y - p1.y) / (p2.x - p1.x);
                            degree = parseFloat(((Math.atan(a) * 180) / Math.PI) + rotOffset, 2).toFixed(2);
                            var lastDegreee = parseDeg(parseInt(degree));
                            var isReRotation = parseDeg(parseInt(objs[z].getAttr("rotation"))) != lastDegreee;
                            p1 = getPosOnCurves(history.start, history.control, history.end, (x / $scope.iloscklatekPomiedzyGlownymi));
                            p2 = getPosOnCurves(history.start, history.control, history.end, ((x + 1) / $scope.iloscklatekPomiedzyGlownymi));
                            var rotOffset = 0;
                            if (p1.x > p2.x) rotOffset = 180;
                            a = (p2.y - p1.y) / (p2.x - p1.x);
                            degree = parseDeg(parseFloat(((Math.atan(a) * 180) / Math.PI) + rotOffset, 2).toFixed(2));

                            if (isReRotation) {
                                degree = parseFloat(degree) + Math.abs(lastDegreee - parseDeg(parseInt(objs[z].getAttr("rotation"))));
                            }

                            var lastText = objs[z].getAttr("textObj");
                            var complexText = new Konva.Text({
                                x: p1.x,
                                y: p1.y + objs[z].height() / 2,
                                offsetX: lastText.getAttr('offsetX'),
                                offsetY: lastText.getAttr('offsetY'),
                                text: lastText.getAttr('text'),
                                fontSize: lastText.getAttr('fontSize'),
                                fontFamily: 'Calibri',
                                fill: lastText.getAttr('fill'),
                                padding: 20,
                                width: 200,
                                align: 'center'
                            });
                            var obj = new Konva.Image({
                                x: p1.x,
                                y: p1.y,
                                offsetX: objs[z].getAttr("offsetX"),
                                offsetY: objs[z].getAttr("offsetY"),
                                rotation: ($scope.turnOnRotation) ? degree : objs[z].getAttr("rotation"),
                                image: objs[z].getAttr("image"),
                                scale: objs[z].getAttr("scale"),
                                name: objs[z].getAttr("name"),
                                id: objs[z].getAttr("id"),
                                config: objs[z].getAttr("config"),
                                textObj: complexText
                            });
                        } else {
                            var lastText = objs[z].getAttr("textObj");
                            var complexText = new Konva.Text({
                                x: lastText.getAttr('x'),
                                y: lastText.getAttr('y'),
                                offsetX: lastText.getAttr('offsetX'),
                                offsetY: lastText.getAttr('offsetY'),
                                text: lastText.getAttr('text'),
                                fontSize: lastText.getAttr('fontSize'),
                                fontFamily: 'Calibri',
                                fill: lastText.getAttr('fill'),
                                padding: 20,
                                width: 200,
                                align: 'center'
                            });
                            var obj = new Konva.Image({
                                x: objs[z].getAttr("x"),
                                y: objs[z].getAttr("y"),
                                offsetX: objs[z].getAttr("offsetX"),
                                offsetY: objs[z].getAttr("offsetY"),
                                rotation: objs[z].getAttr("rotation"),
                                image: objs[z].getAttr("image"),
                                scale: objs[z].getAttr("scale"),
                                name: objs[z].getAttr("name"),
                                id: objs[z].getAttr("id"),
                                config: objs[z].getAttr("config"),
                                textObj: complexText
                            });
                        }

                        objectArrays.push(obj);
                    }

                    animationFrames.push({
                        arrow: arrowsArray,
                        obj: objectArrays,
                        shapes: shapesArray,
                        text: textArray
                    });

                }
            } else {
                arrowsArray = []
                for (var z = 0; z < arrows.length; z++) {
                    var lastText = arrows[z].getAttr("textObj");
                    var complexText = new Konva.Text({
                        x: lastText.getAttr('x'),
                        y: lastText.getAttr('y'),
                        offsetX: lastText.getAttr('offsetX'),
                        offsetY: lastText.getAttr('offsetY'),
                        text: lastText.getAttr('text'),
                        fontSize: lastText.getAttr('fontSize'),
                        fontFamily: 'Calibri',
                        fill: lastText.getAttr('fill'),
                        padding: 20,
                        width: 200,
                        align: 'center'
                    });
                    if (arrows[z].getAttr("points")[0].y < arrows[z].getAttr("points")[1].y) complexText.setAttr('offsetY', 50);
                    else complexText.setAttr('offsetY', 10);
                    var arrow = new Konva.Shape({
                        x: arrows[z].getAttr("x"),
                        y: arrows[z].getAttr("y"),
                        offsetX: arrows[z].getAttr('offsetX'),
                        offsetY: arrows[z].getAttr('offsetY'),
                        points: arrows[z].getAttr("points"),
                        stroke: arrows[z].getAttr("stroke"),
                        strokeWidth: arrows[z].getAttr("strokeWidth"),
                        sceneFunc: function(context) {
                            drawArrowStyle(context, this);
                        },
                        id: arrows[z].getAttr("id"),
                        textObj: complexText,
                        name: 'arrow',
                        config: arrows[z].getAttr("config")
                    });
                    arrowsArray.push(arrow);
                }

                shapesArray = []
                for (var z = 0; z < shapes.length; z++) {
                    var lastText = shapes[z].getAttr("textObj");
                    var complexText = new Konva.Text({

                        x: lastText.getAttr('x'),
                        y: lastText.getAttr('y'),
                        offsetX: lastText.getAttr('offsetX'),
                        offsetY: lastText.getAttr('offsetY'),
                        text: lastText.getAttr('text'),
                        fontSize: lastText.getAttr('fontSize'),
                        fontFamily: 'Calibri',
                        fill: lastText.getAttr('fill'),
                        padding: 20,
                        width: 200,
                        align: 'center'
                    });
                    var shape = new Konva.Shape({
                        x: shapes[z].getAttr("x"),
                        y: shapes[z].getAttr("y"),
                        offsetX: shapes[z].getAttr('offsetX'),
                        offsetY: shapes[z].getAttr('offsetY'),
                        arrowPoint: shapes[z].getAttr("arrowPoint"),
                        sceneFunc: shapes[z].getAttr("sceneFunc"),
                        name: shapes[z].getAttr("name"),
                        fill: shapes[z].getAttr("fill"),
                        scale: shapes[z].getAttr("scale"),
                        stroke: shapes[z].getAttr("stroke"),
                        strokeWidth: shapes[z].getAttr("strokeWidth"),
                        id: shapes[z].getAttr("id"),
                        config: shapes[z].getAttr("config"),
                        textObj: complexText
                    });
                    shapesArray.push(shape);
                }

                textArray = []
                for (var z = 0; z < text.length; z++) {

                    var obj = new Konva.Text({
                        x: text[z].getAttr("x"),
                        y: text[z].getAttr("y"),
                        offsetX: text[z].getAttr("offsetX"),
                        offsetY: text[z].getAttr("offsetY"),
                        rotation: text[z].getAttr("rotation"),
                        fontSize: text[z].getAttr("fontSize"),
                        text: text[z].getAttr("text"),
                        name: text[z].getAttr("name"),
                        fill: text[z].getAttr("fill"),
                        align: text[z].getAttr("align"),
                        scale: text[z].getAttr("scale"),
                        id: text[z].getAttr("id"),
                        config: text[z].getAttr("config")
                    });
                    textArray.push(obj);
                }

                objectArrays = []
                for (var z = 0; z < objs.length; z++) {
                    var lastText = objs[z].getAttr("textObj");
                    var complexText = new Konva.Text({
                        x: lastText.getAttr('x'),
                        y: lastText.getAttr('y'),
                        offsetX: lastText.getAttr('offsetX'),
                        offsetY: lastText.getAttr('offsetY'),
                        text: lastText.getAttr('text'),
                        fontSize: lastText.getAttr('fontSize'),
                        fontFamily: 'Calibri',
                        fill: lastText.getAttr('fill'),
                        padding: 20,
                        width: 200,
                        align: 'center'
                    });
                    var obj = new Konva.Image({
                        x: objs[z].getAttr("x"),
                        y: objs[z].getAttr("y"),
                        offsetX: objs[z].getAttr("offsetX"),
                        offsetY: objs[z].getAttr("offsetY"),
                        rotation: objs[z].getAttr("rotation"),
                        image: objs[z].getAttr("image"),
                        scale: objs[z].getAttr("scale"),
                        name: objs[z].getAttr("name"),
                        id: objs[z].getAttr("id"),
                        config: objs[z].getAttr("config"),
                        textObj: complexText
                    });
                    objectArrays.push(obj);
                }

                animationFrames.push({
                    arrow: arrowsArray,
                    obj: objectArrays,
                    shapes: shapesArray,
                    text: textArray
                });
            }

        }
        return animationFrames;
    }

    function parseDeg(deg) {
        deg = parseFloat(deg);
        if (deg >= 0) return deg;
        return 360 + deg;
    }

    function playAnimate() {
        if (actualPlayerFrame >= allAnimFrame.length) {
            actualPlayerFrame = 0;
        }

        var mainPlay = setInterval(function() {
            if (pauseAnim) {
                window.clearInterval(mainPlay);
                return;
            }
            actualPlayerFrame++;
            if (actualPlayerFrame >= allAnimFrame.length) {
                window.clearInterval(mainPlay);
                turnOnAllSter();
            } else {
                var percent = setPlayerToFrame(actualPlayerFrame);
                currentObjPerFrame = actualPlayerFrame;
                drawNewStage("canvasPlayerContainer", allAnimFrame);
                $("#playerData p").first().text("Podgląd animacji - klatka: " + (actualPlayerFrame + 1) + " / " + allAnimFrame.length);
            }
        }, 1000 / $scope.iloscfps);
    }

    $(document).off('click touch', '#exitPlayer');
    $(document).on('click touch', '#exitPlayer', function() {
        exitPlayer();
    });

    $(document).off('click touch', '#playAnim');
    $(document).on('click touch', '#playAnim', function() {
        if (!canClickSter('playAnim')) return;
        playAnimate();
        pauseAnim = false;
        turnOnAllSter();
        playerTurnOffSter('backwardAnim');
        playerTurnOffSter('forwardAnim');
        playerTurnOffSter('playAnim');
    });

    $(document).off('click touch', '#pauseAnim');
    $(document).on('click touch', '#pauseAnim', function() {
        if (!canClickSter('pauseAnim')) return;
        pauseAnim = true;
        turnOnAllSter();
        playerTurnOffSter('pauseAnim');
    });

    $(document).off('click touch', '#stopAnim');
    $(document).on('click touch', '#stopAnim', function() {
        pauseAnim = true;
        actualPlayerFrame = 0;
        changeFrame(0, allAnimFrame);
        setPlayerToFrame(0);
        drawNewStage("canvasPlayerContainer", allAnimFrame);
        turnOnAllSter();
    });

    $(document).off('click touch', '#backwardAnim');
    $(document).on('click touch', '#backwardAnim', function() {
        if (!canClickSter('backwardAnim')) return;
        playerBeforeFrame();
        $("#playerData p").first().text("Podgląd animacji - klatka: " + (actualPlayerFrame + 1) + " / " + allAnimFrame.length);
    });

    $(document).off('click touch', '#forwardAnim');
    $(document).on('click touch', '#forwardAnim', function() {
        if (!canClickSter('forwardAnim')) return;
        playerNextFrame();
        $("#playerData p").first().text("Podgląd animacji - klatka: " + (actualPlayerFrame + 1) + " / " + allAnimFrame.length);
    });

    function playerBeforeFrame() {
        if (actualPlayerFrame == 0) return;
        actualPlayerFrame--;
        changeFrame(actualPlayerFrame, allAnimFrame);
        setPlayerToFrame(actualPlayerFrame);
        drawNewStage("canvasPlayerContainer", allAnimFrame);
    }

    function playerNextFrame() {
        if (actualPlayerFrame >= allAnimFrame.length - 1) return;
        actualPlayerFrame++;
        changeFrame(actualPlayerFrame, allAnimFrame);
        setPlayerToFrame(actualPlayerFrame);
        drawNewStage("canvasPlayerContainer", allAnimFrame);
    }

    function setPlayerToFrame(frame) {
        var percent = Math.round((frame / (allAnimFrame.length - 1)) * 100);
        $('#animTime').css("width", percent + "%");
        return percent;
    }

    function showPlayer() {
        pauseAnim = false;
        isPlayerOpen = true;
        allAnimFrame = null;
        allAnimFrame = createFrameToAnim();
        $('#canvasPlayer').show();
        if (actualPlayerFrame >= allAnimFrame.length) actualPlayerFrame = 0;
        changeFrame(actualPlayerFrame, allAnimFrame);
        setPlayerToFrame(actualPlayerFrame);
        drawNewStage("canvasPlayerContainer", allAnimFrame);
        playAnimate();
    }

    function exitPlayer() {
        pauseAnim = true;
        isPlayerOpen = false;
        $('#canvasPlayer').hide();
        turnOnAllSter();
        changeFrame(allObjectPerFrame.length - 1);
        drawNewStage();
    }

    function canClickSter(name) {
        return $('#' + name).hasClass('animCotrollerButton');
    }

    function turnOnAllSter() {
        playerTurnOnSter('playAnim');
        playerTurnOnSter('backwardAnim');
        playerTurnOnSter('pauseAnim');
        playerTurnOnSter('forwardAnim');
        playerTurnOnSter('stopAnim');
    }

    function playerTurnOnSter(name) {
        $('#' + name).removeClass('disableSter');
        $('#' + name).addClass('animCotrollerButton');
    }

    function playerTurnOffSter(name) {
        $('#' + name).removeClass('animCotrollerButton');
        $('#' + name).addClass('disableSter');
    }

    function loadAnimation(callback) {
        request.backend('loadConspectAnim', { id: $scope.animId }, function(data) {
            data.anchorHistory = JSON.parse(data.anchorHistory);
            data.animFrame = JSON.parse(data.animFrame);
            anchorHistory = null;
            anchorHistory = data.anchorHistory;

            allObjectPerFrame = null;
            allObjectPerFrame = [];

            $scope.cwName = data.name;
            $scope.cwFieldType = data.cwFieldType;
            $scope.cwMaxTime = parseInt(data.cwMaxTime);
            $scope.cwMinTime = parseInt(data.cwMinTime);
            $scope.cwMaxPerson = parseInt(data.cwMaxPerson);
            $scope.cwMinPerson = parseInt(data.cwMinPerson);
            $scope.cwOps = data.cwOps;
            $scope.cwWsk = data.cwWsk;
            $scope.iloscklatekPomiedzyGlownymi = parseInt(data.frameBeetween);
            $scope.jakoscAnimacji = parseInt(data.qualityAnim);
            $scope.iloscfps = parseInt(data.fps);

            for (var x = 0; x < data.animFrame.length; x++) {
                allObjectPerFrame.push({ arrow: [], obj: [], shapes: [], text: [] });

                if (data.animFrame[x].arrow)
                    for (var i = 0; i < data.animFrame[x].arrow.length; i++) {
                        var arrowBef = data.animFrame[x].arrow[i];
                        var obj = createArrowObjFromOther(arrowBef, true);
                        allObjectPerFrame[x].arrow.push(obj);
                    }
                if (data.animFrame[x].obj)
                    for (var i = 0; i < data.animFrame[x].obj.length; i++) {
                        var objBef = data.animFrame[x].obj[i];
                        var obj = createObjFromOther(objBef, true);
                        allObjectPerFrame[x].obj.push(obj);
                    }
                if (data.animFrame[x].shapes)
                    for (var i = 0; i < data.animFrame[x].shapes.length; i++) {
                        var objBef = data.animFrame[x].shapes[i];
                        var obj = createShapeObjFromOther(objBef, true);
                        allObjectPerFrame[x].shapes.push(obj);
                    }
                if (data.animFrame[x].text)
                    for (var i = 0; i < data.animFrame[x].text.length; i++) {
                        var objBef = data.animFrame[x].text[i];
                        var obj = createTextFromOther(objBef, true);
                        allObjectPerFrame[x].text.push(obj);
                    }

                if (x != 0) {
                    var count = $(".timeElement").length + 1;
                    $(".timeElement").last().after("<div class='timeElement' > " + count + " </div>");
                }
            }

            $scope.tags = data.tags.split(' ');
            var tagTo = {
                data: []
            };

            for (var ind = 0; ind < $scope.tags.length; ind++) {
                tagTo.data.push({
                    tag: $scope.tags[ind]
                });
            }

            $('.chips-placeholder').material_chip(tagTo);

            if (data.fieldImage && data.fieldImage.length > 2) {
                selectField(data.fieldImage);
                $scope.$apply(function() {
                    callback();
                    $scope.changeCategories($scope.mouseActionType.MOVE);
                    changeFrame(0);
                    setTimeout(function() {
                        resize();
                    }, 500);
                });
            }

        });

    }

    $(document).off('change', '#turnOnHelperNet');
    $(document).on('change', '#turnOnHelperNet', function() {
        drawNewStage();
    });

    $(document).off('change', '#turnOnHekperFullScreen');
    $(document).on('change', '#turnOnHekperFullScreen', function() {
        if ($scope.turnOnHekperFullScreen) {
            goToFull();
        } else {
            $scope.endFromFull(false);
        }
    });


    function renderAnim() {
        $scope.turnOnHelperNet = false;
        isPlayerOpen = true;
        allAnimFrame = null;
        allAnimFrame = createFrameToAnim();
        $('#canvasPlayer').show();
        actualPlayerFrame = 0;
        changeFrame(actualPlayerFrame, allAnimFrame);
        setPlayerToFrame(actualPlayerFrame);
        var encoder = new GIFEncoder();
        encoder.setRepeat(0);
        encoder.setQuality($scope.jakoscAnimacji);
        encoder.setDelay(1000 / $scope.iloscfps);
        encoder.start();

        var mainPlay = setInterval(function() {
            if (actualPlayerFrame >= allAnimFrame.length) {
                window.clearInterval(mainPlay);
                turnOnAllSter();
                encoder.finish();
                var binary_gif = encoder.stream().getData();
                $scope.gif = encode64(binary_gif);
                var tags = $('.chips-placeholder').material_chip('data');
                var allTagString = '';
                for (var x = 0; x < tags.length; x++) {
                    allTagString += " ";
                    allTagString += tags[x].tag;
                }

                var allObj = [];
                for (var index = 0; index < allObjectPerFrame.length; index++) {
                    allObj.push({
                        obj: [],
                        arrow: [],
                        shapes: [],
                        text: []
                    });
                    for (var x = 0; x < allObjectPerFrame[index].obj.length; x++) {
                        allObj[index].obj.push(allObjectPerFrame[index].obj[x].toObject());
                        allObj[index].obj[x].attrs.image = allObjectPerFrame[index].obj[x].getImage().src;
                    }
                    for (var x = 0; x < allObjectPerFrame[index].arrow.length; x++) {
                        allObj[index].arrow.push(allObjectPerFrame[index].arrow[x].toObject());
                    }
                    for (var x = 0; x < allObjectPerFrame[index].shapes.length; x++) {
                        allObj[index].shapes.push(allObjectPerFrame[index].shapes[x].toObject());
                    }
                    for (var x = 0; x < allObjectPerFrame[index].text.length; x++) {
                        allObj[index].text.push(allObjectPerFrame[index].text[x].toObject());
                    }
                }

                currentObjPerFrame = 0;
                drawNewStage("canvasPlayerContainer", allAnimFrame);

                var toSend = {
                    id: $scope.animId,
                    name: $scope.animName,
                    tags: allTagString,
                    mainImg: allAnimFrame.length <= 0 ? '' : $scope.gif,
                    mainImgShow: allAnimFrame.length <= 0 ? '' : selectedFrame.toCanvas().toDataURL("image/jpg").split(',')[1],
                    animFrame: JSON.stringify(allObj),
                    anchorHistory: JSON.stringify(anchorHistory),
                    fieldImage: $scope.isSelectedField ? $scope.fieldImage.src : '',
                    cwFieldType: $scope.cwFieldType,
                    cwMaxTime: $scope.cwMaxTime,
                    cwMinTime: $scope.cwMinTime,
                    cwMaxPerson: $scope.cwMaxPerson,
                    cwMinPerson: $scope.cwMinPerson,
                    cwOps: $scope.cwOps,
                    cwWsk: $scope.cwWsk,
                    usid: $rootScope.user.id,
                    frameBeetween: $scope.iloscklatekPomiedzyGlownymi,
                    qualityAnim: $scope.jakoscAnimacji,
                    fps: $scope.iloscfps
                };


                request.backend('saveConspectAnim', toSend, function(data) {
                    exitPlayer();
                    if ($scope.animId != -1) notify.localNotify("Sukces", "Animacja pomyślnie edytowana");
                    else notify.localNotify("Sukces", "Animacja zapisana pomyślnie");
                    $scope.animId = data;
                    $location.url("/conspectusAnimList");
                });

            } else {
                var percent = setPlayerToFrame(actualPlayerFrame);
                currentObjPerFrame = actualPlayerFrame;
                drawNewStage("canvasPlayerContainer", allAnimFrame);
                encoder.addFrame(selectedFrame.toCanvas().getContext('2d'));
                $("#playerData p").first().text("Renderowanie animacji - klatka: " + (actualPlayerFrame + 1) + " / " + allAnimFrame.length);
                actualPlayerFrame++;
            }
        }, 1000 / $scope.iloscfps);
    }

    function saveAnimation() {
        renderAnim();
    }

    $scope.saveAnim = function() {
        $scope.animName = $('#cwName').val();
        $scope.tags = $('.chips-placeholder').material_chip('data');

        $scope.cwFieldType = $('#cwFieldType').val();
        $scope.cwMaxTime = parseInt($('#maxTime').val());
        $scope.cwMinTime = parseInt($('#minTime').val());
        $scope.cwMaxPerson = parseInt($('#maxPerson').val());
        $scope.cwMinPerson = parseInt($('#minPerson').val());
        $scope.cwOps = $('#opCw').val();
        $scope.cwWsk = $('#wskCw').val();

        if (!$scope.animName || $scope.animName == '' || $scope.animName == ' ' || $scope.animName == null) {
            notify.localNotify("Walidacja", "Wpisz nazwę danego ćwiczenia");
            return;
        }

        if (!$scope.cwFieldType || $scope.cwFieldType.length <= 0) {
            notify.localNotify("Walidacja", "Wpisz poprawnie pole gry");
            return;
        }

        if (!$scope.cwMinTime || $scope.cwMinTime.length <= 0 || $scope.cwMinTime <= 0 || !$.isNumeric($scope.cwMinTime)) {
            notify.localNotify("Walidacja", "Wpisz poprawnie minimalny czas trwania ( więcej niż 0 )");
            return;
        }

        if (!$scope.cwMaxTime || $scope.cwMaxTime.length <= 0 || $scope.cwMaxTime < $scope.cwMinTime || $scope.cwMaxTime > 1000 || !$.isNumeric($scope.cwMaxTime)) {
            notify.localNotify("Walidacja", "Wpisz poprawnie maksymalny czas trwania ( wiecej niż " + $scope.cwMinTime + " mniej niż 1000 )");
            return;
        }

        if (!$scope.cwMinPerson || $scope.cwMinPerson.length <= 0 || $scope.cwMinPerson <= 0 || !$.isNumeric($scope.cwMinPerson)) {
            notify.localNotify("Walidacja", "Wpisz poprawnie minimalną ilość zawodników ( więcej niż 0 )");
            return;
        }

        if (!$scope.cwMaxPerson || $scope.cwMaxPerson.length <= 0 || $scope.cwMaxPerson < $scope.cwMinPerson || $scope.cwMaxPerson > 100 || !$.isNumeric($scope.cwMaxPerson)) {
            notify.localNotify("Walidacja", "Wpisz poprawnie maksymalną ilość zawodników ( wiecej niż " + $scope.cwMinPerson + " mniej niż 100 )");
            return;
        }

        if (!$scope.tags || $scope.tags.length < 2) {
            notify.localNotify("Walidacja", "Wpisz przynajmniej dwie frazy, z którymi będzie kojarzone dane ćwiczenie");
            return;
        }

        saveAnimation();
    }

    $scope.loadAndPlay = function(id) {
        $scope.onlyPlayer = true;
        currentObjPerFrame = 0;
        $scope.animId = id;
        $rootScope.idFromAnimConspectToEdit = null;
        loadAnimation(function() {
            showPlayer();
        });
    }

});
app.controller('shareList', function($scope, auth, $rootScope, notify, request, $location, $compile) {
    $scope.showContent = false;
    $scope.shareList = [];

    $scope.loadSharedList = function() {
        request.backend('getSharedListForAnim', { aid: $rootScope.sharedAnimId }, function(data) {
            $scope.$apply(function() {
                $scope.shareList = data;
                loadAvailableMasterList();
                $scope.showContent = true;
            });
        });
    }

    $scope.loadSharedListC = function() {
        request.backend('getSharedListForConsp', { aid: $rootScope.sharedConspId }, function(data) {
            $scope.$apply(function() {
                $scope.shareList = data;
                loadAvailableMasterListC();
                $scope.showContent = true;
            });
        });
    }

    function loadAvailableMasterList() {
        request.backend('getAvailableSharedMasterForAnim', { aid: $rootScope.sharedAnimId }, function(data) {
            $('#autocompleteMaster').autocomplete({
                data: data,
                limit: 20,
                minLength: 1,
                onAutocomplete: function(val) {
                    console.log(val);
                    $usid = val.split("-")[1];
                    addShareToAnim($usid);
                }
            });
        });
    }

    function loadAvailableMasterListC() {
        request.backend('getAvailableSharedMasterForConsp', { aid: $rootScope.sharedConspId }, function(data) {
            $('#autocompleteMaster').autocomplete({
                data: data,
                limit: 20,
                minLength: 1,
                onAutocomplete: function(val) {
                    console.log(val);
                    $usid = val.split("-")[1];
                    addShareToConsp($usid);
                }
            });
        });
    }

    function addShareToAnim(usid) {
        request.backend('addSharedForAnim', { aid: $rootScope.sharedAnimId, usid: usid }, function(data) {
            $scope.loadSharedList();
        }, "Dodano pozwolenie na wgląd");
    }

    function addShareToConsp(usid) {
        request.backend('addSharedForConsp', { aid: $rootScope.sharedConspId, usid: usid }, function(data) {
            $scope.loadSharedListC();
        }, "Dodano pozwolenie na wgląd");
    }

    $scope.deleteFromShared = function(usid) {

        $rootScope.showModalWindow("Usunięcie pozwolenia na wgląd", function() {
            request.backend('deleteSharedForAnim', { aid: $rootScope.sharedAnimId, usid: usid }, function(data) {
                $scope.loadSharedList();
            }, "Usunięto pozwolenie na wgląd");
        });


    }

    $scope.deleteFromSharedC = function(usid) {


        $rootScope.showModalWindow("Usunięcie pozwolenia na wgląd", function() {
            request.backend('deleteSharedForConsp', { aid: $rootScope.sharedConspId, usid: usid }, function(data) {
                $scope.loadSharedListC();
            }, "Usunięto pozwolenie na wgląd");
        });


    }

});
app.controller('showConspectController', function($scope, auth, $rootScope, notify, request, $location, $compile) {
    $scope.showContent = false;
    $scope.conspect = null;

    $scope.initConspect = function() {
        if ($rootScope.consepectShowId && $rootScope.consepectShowId != null && $rootScope.consepectShowId >= 0) {
            $scope.loadConspect($rootScope.consepectShowId);
            $rootScope.consepectShowId = null;
        }
    }

    $scope.loadConspect = function(id) {
        request.backend('getFullConspectById', { id: id }, function(data) {
            $scope.$apply(function() {
                $scope.conspect = data;
                $scope.conspect.tags = $scope.conspect.tags.replace('  ', ' ');
                $scope.conspect.tags = $scope.conspect.tags.split(' ');
                $scope.showContent = true;
            });

            setTimeout(function() {
                $('.collapsible').collapsible();
                $('.gifplayer').each(function() {
                    if (!$(this).hasClass('isGifed')) {
                        $(this).addClass('isGifed');
                        $(this).gifplayer();
                    }
                }); 
            }, 500);
        });
    }

});
app.controller('TrainingConspectusController', function($scope, auth, $rootScope, notify, request, $location, $compile) {
    $scope.showContent = false;
    $scope.animArray = [];
    $scope.showAnimCreator = false;
    $scope.allCoElement = [];
    $scope.conspectArray = [];
    $rootScope.lastPlaceInConspect = null;
    $rootScope.sharedAnimId = null;
    $rootScope.sharedConspId = null;

    $scope.coActualId = -1;
    $scope.coName = '';
    $scope.coMaster = '';
    $scope.coDate = '';
    $scope.coPlace = '';
    $scope.sezon = '';
    $scope.coTeam = '';
    $scope.coOp = '';
    $scope.coPower = '';
    $scope.coUserCount = '';
    $scope.coTags = '';

    if ($rootScope.widgetInterval) {
        clearInterval($rootScope.widgetInterval);
    }

    $rootScope.widgetInterval = setInterval(function() {
        if ($rootScope.widgetResponse && $rootScope.widgetResponse != null) {
            $scope.addCwCo({
                place: $rootScope.lastPlaceInConspect,
                name: $rootScope.widgetResponse.name,
                id: $rootScope.widgetResponse.id
            });
            $rootScope.widgetResponse = null;
        }
    }, 200);

    $scope.loadConspect = function(id) {
        request.backend('getConspectById', { id: id }, function(data) {
            $scope.$apply(function() {
                $scope.coActualId = id;
                $scope.coName = data.name;
                $scope.coMaster = data.master;
                $scope.coDate = data.date;
                $scope.coPlace = data.place;
                $scope.sezon = data.sezon;
                $scope.coTeam = data.team;
                $scope.coOp = data.about;
                $scope.coPower = data.powerCount;
                $scope.coUserCount = data.userCount;
                $scope.coTags = data.tags.split(' ');
            });

            var tagTo = {
                data: []
            };

            for (var ind = 0; ind < $scope.coTags.length; ind++) {
                tagTo.data.push({
                    tag: $scope.coTags[ind]
                });
            }

            $('.chips-placeholder').material_chip(tagTo);
            $('.collapsible').collapsible();

            var fullFieldData = JSON.parse(data.data);
            for (var i = 0; i < fullFieldData.length; i++) {
                if (fullFieldData[i].type == 'simple') {
                    $scope.addSimpleFieldCo(fullFieldData[i].data.place);
                    $scope.allCoElement[$scope.allCoElement.length - 1].data = {
                        content: fullFieldData[i].data.content,
                        timeMin: fullFieldData[i].data.timeMin,
                        timeMax: fullFieldData[i].data.timeMax,
                        wsk: fullFieldData[i].data.wsk,
                        place: fullFieldData[i].data.place
                    };
                } else {
                    var fieldData = {
                        id: fullFieldData[i].data.id,
                        name: fullFieldData[i].data.name,
                        place: fullFieldData[i].data.place
                    }
                    $scope.addCwCo(fieldData);
                }
            }
        });
    }

    $scope.selectFromWidget = function(place) {
        $rootScope.lastPlaceInConspect = place;
        $rootScope.showWidget('selectTraining', 'TrainingConspectus');
    }

    if ($rootScope.editConspectWithId && $rootScope.editConspectWithId != null && $rootScope.editConspectWithId >= 0) {
        $scope.loadConspect($rootScope.editConspectWithId);
        $rootScope.editConspectWithId = null;
    }

    $scope.goToEditConspect = function(id) {
        $rootScope.editConspectWithId = id;
        $location.url("/conspectusAdd");
    }

    $scope.initConsectusCreate = function() {
        $scope.showContent = true;
    }

    $scope.initConsAnimList = function() {
        request.backend('getListOfAnimConspect', { usid: $rootScope.user.id }, function(data) {
            $scope.$apply(function() {
                $scope.animArray = data;
                for (var i = 0; i < $scope.animArray.length; i++) {
                    var tags = $scope.animArray[i].tags.replace("  ", " ").split(" ");
                    $scope.animArray[i].tags = [];
                    for (var x = 0; x < tags.length; x++) {
                        $scope.animArray[i].tags.push(tags[x]);
                    }
                }
                $scope.showContent = true;
                $rootScope.idFromAnimConspectToEdit = null;
                setInterval(function() {
                    $('.gifplayer').each(function() {
                        if (!$(this).hasClass('isGifed')) {
                            $(this).addClass('isGifed');
                            $(this).gifplayer();
                        }
                    });
                }, 500);
            });
        });
    }

    $scope.initConspectusAdd = function() {
        $scope.showContent = true;
    }

    $scope.initConspectusList = function() {
        request.backend('getAllConspectList', { usid: $rootScope.user.id }, function(data) {
            $scope.conspectArray = data;
            for (var i = 0; i < $scope.conspectArray.length; i++) {
                var tags = $scope.conspectArray[i].tags.replace("  ", " ").split(" ");
                $scope.conspectArray[i].tags = [];
                for (var x = 0; x < tags.length; x++) {
                    $scope.conspectArray[i].tags.push(tags[x]);
                }
            }
            $scope.showContent = true;
        });
    }

    $scope.editAnimCon = function(id) {
        $rootScope.idFromAnimConspectToEdit = id;
        $location.url("/conspectusAnim");
    }

    $scope.deleteAnimCon = function(id) {
        $rootScope.showModalWindow("Nieodwracalne usunięcie ćwiczenia", function() {
            request.backend('deleteAnimConspect', { id: id }, function(data) {
                $scope.initConsAnimList();
            }, "Pomyślnie usunięto");
        });
    }

    $scope.showShareWidget = function(aid, isConspect = false) {
        if (isConspect) {
            $rootScope.sharedConspId = aid;
            $rootScope.showWidget('shareListC', 'TrainingConspectus');
        } else {
            $rootScope.sharedAnimId = aid;
            $rootScope.showWidget('shareList', 'TrainingConspectus');
        }
    }

    $scope.addSimpleFieldCo = function(placeId) {
        var thisId = $scope.allCoElement.length;
        $scope.allCoElement.push({
            id: thisId,
            type: 'simple',
            status: 'on',
            data: {
                content: '',
                timeMin: 1,
                timeMax: 2,
                wsk: '',
                place: placeId
            }
        });
        var el = "<div class='coElement' id='" + thisId + "-simpleField" + "'><div ng-click='deleteField(" + thisId + ");' style='position: absolute; top: 9px; right: 20px; color: white; font-size: 20px; cursor: pointer'><i class='fa fa-times' aria-hidden='true' ></i></div><div class='form-group'><div class='row'><div class='input-field col s12 m6'><input id='" + thisId + "-simpleContent" + "' type='text' placeholder='Treść' class='validate' ng-model='allCoElement[" + thisId + "].data.content' required><label for='" + thisId + "-simpleContent" + "'>Treść</label></div><div class='input-field col s12 m3'><input id='" + thisId + "-simpleMinTime" + "' type='text' ng-model='allCoElement[" + thisId + "].data.timeMin' placeholder='Czas min' class='validate' required><label for='" + thisId + "-simpleMinTime" + "'>Czas min</label></div><div class='input-field col s12 m3'><input id='" + thisId + "-simpleMaxTime" + "' type='text' ng-model='allCoElement[" + thisId + "].data.timeMax' placeholder='Czas max' class='validate' required><label for='" + thisId + "-simpleMaxTime" + "'>Czas max</label></div><div class='input-field col s12'><textarea id='" + thisId + "-simpleWsk" + "' placeholder='Wskazówki' ng-model='allCoElement[" + thisId + "].data.wsk' class='materialize-textarea' data-length='255'></textarea><label for='" + thisId + "-simpleWsk" + "'>Wskazówki</label></div></div></div></div>";
        var element = angular.element($('#' + placeId).find('.data').first());
        var generated = element.html(element.html() + el);
        $compile(generated.contents())($scope);
        Materialize.updateTextFields();
    }

    $scope.addCwCo = function(response) {
        var thisId = $scope.allCoElement.length;
        $scope.allCoElement.push({
            id: thisId,
            type: 'training',
            status: 'on',
            data: {
                id: response.id,
                name: response.name,
                place: response.place
            }
        });
        var el = "<div class='coElement' id='" + thisId + "-simpleField" + "'><div ng-click='deleteField(" + thisId + ");' style='position: absolute; top: 9px; right: 20px; color: white; font-size: 20px; cursor: pointer'><i class='fa fa-times' aria-hidden='true' ></i></div> <b>Ćwiczenie: </b>" + response.name + "  </div>";
        var element = angular.element($('#' + response.place).find('.data').first());
        var generated = element.html(element.html() + el);
        $compile(generated.contents())($scope);
        Materialize.updateTextFields();
    }

    $scope.deleteField = function(id) {
        $scope.allCoElement[id].status = 'off';
        $('#' + id + '-simpleField').hide(200);
    }

    $scope.saveConspect = function() {
        $scope.coName = $('#coName').val();
        $scope.coDate = $('#coDate').val();
        $scope.coPlace = $('#coPlace').val();
        $scope.sezon = $('#sezon').val();
        $scope.coTeam = $('#coTeam').val();
        $scope.coOp = $('#coOp').val();
        $scope.coPower = $('#coPower').val();
        $scope.coUserCount = $('#coUserCount').val();
        $scope.coTags = $('.chips-placeholder').material_chip('data');

        if (!$scope.coName || $scope.coName == '' || $scope.coName == ' ' || $scope.coName == null) {
            notify.localNotify("Walidacja", "Wpisz nazwę danego konspektu");
            return;
        }

        if (!$scope.coDate || $scope.coDate == '' || $scope.coDate == ' ' || $scope.coDate == null) {
            notify.localNotify("Walidacja", "Wpisz date");
            return;
        }

        if (!$scope.coPlace || $scope.coPlace == '' || $scope.coPlace == ' ' || $scope.coPlace == null) {
            notify.localNotify("Walidacja", "Wpisz miejsce");
            return;
        }

        if (!$scope.coTeam || $scope.coTeam == '' || $scope.coTeam == ' ' || $scope.coTeam == null) {
            notify.localNotify("Walidacja", "Wpisz przedział wiekowy");
            return;
        }

        if (!$scope.coTags || $scope.coTags.length < 2) {
            notify.localNotify("Walidacja", "Wpisz przynajmniej dwie frazy, z którymi będzie kojarzony dany konspekt");
            return;
        }

        var dataToSend = [];
        var isError = false;

        for (var i = 0; i < $scope.allCoElement.length; i++) {
            if ($scope.allCoElement[i].status == 'on') {
                if ($scope.allCoElement[i].type == 'simple') {

                    if ($scope.allCoElement[i].data.content == '') {
                        notify.localNotify("Walidacja", "Wpisz treść wszystkich prostych pól w konspekcie");
                        isError = true;
                    }
                    var minT = parseInt($scope.allCoElement[i].data.timeMin);
                    if (minT == 0) {
                        notify.localNotify("Walidacja", "Wpisz poprawnie wszystkie minimalne wartosci czasu w prostych polach");
                        isError = true;
                    }
                    var maxT = parseInt($scope.allCoElement[i].data.timeMax);
                    if (maxT == 0 || maxT <= minT) {
                        notify.localNotify("Walidacja", "Wpisz poprawnie wszystkie maksymalne wartosci czasu w prostych polach");
                        isError = true;
                    }

                    if (isError) return;
                }
                dataToSend.push({
                    type: $scope.allCoElement[i].type,
                    data: $scope.allCoElement[i].data,
                    place: $scope.allCoElement[i].place
                });
            }
        }

        var allTagString = '';
        for (var x = 0; x < $scope.coTags.length; x++) {
            allTagString += " ";
            allTagString += $scope.coTags[x].tag;
        }

        var toSend = {
            id: $scope.coActualId,
            coName: $scope.coName,
            id_user: $rootScope.user.id,
            coDate: $scope.coDate,
            coPlace: $scope.coPlace,
            sezon: $scope.sezon,
            coTeam: $scope.coTeam,
            coOp: $scope.coOp,
            powerCount: $scope.coPower,
            userCount: $scope.coUserCount,
            coTags: allTagString,
            data: JSON.stringify(dataToSend)
        }

        request.backend('saveConspect', toSend, function(data) {
            $location.url("/conspectusList");
        }, "Pomyślnie zapisano");
    }

    $scope.showThisContent = function(id) {
        $rootScope.consepectShowId = id;
        $location.url("/showConspect");
    }

    $scope.deleteCon = function(id) {
        $rootScope.showModalWindow("Nieodwracalne usunięcie konspektu", function() {
            request.backend('deleteConspect', { id: id }, function(data) {
                $scope.initConspectusList();
            }, "Pomyślnie usunięto");
        });
    }

});

app.controller('TrainingListAdditionalController', function($scope, auth, $rootScope, notify, request, $location, $compile) {
    $scope.showContent = false;

    $scope.initConsAnimList = function() {
        request.backend('getListOfAnimConspect', { usid: $rootScope.user.id }, function(data) {
            $scope.$apply(function() {
                $scope.animArray = data;
                for (var i = 0; i < $scope.animArray.length; i++) {
                    var tags = $scope.animArray[i].tags.split(" ");
                    $scope.animArray[i].tags = [];
                    for (var x = 0; x < tags.length; x++) {
                        $scope.animArray[i].tags.push(tags[x]);
                    }
                }
                $scope.showContent = true;
                $rootScope.idFromAnimConspectToEdit = null;
                setInterval(function() {
                    $('.collapsible').collapsible();
                    $('.gifplayer').each(function() {
                        if (!$(this).hasClass('isGifed')) {
                            $(this).addClass('isGifed');
                            $(this).gifplayer();
                        }
                    });
                }, 500);
            });
        });
    }

    $scope.initConspectusList = function() {
        request.backend('getAllConspectList', { usid: $rootScope.user.id }, function(data) {
            $scope.conspectArray = data;
            for (var i = 0; i < $scope.conspectArray.length; i++) {
                var tags = $scope.conspectArray[i].tags.split(" ");
                $scope.conspectArray[i].tags = [];
                for (var x = 0; x < tags.length; x++) {
                    $scope.conspectArray[i].tags.push(tags[x]);
                }
            }
            $scope.showContent = true;
        });
    }

    $scope.editAnimCon = function(id) {
        $rootScope.idFromAnimConspectToEdit = id;
        $location.url("/conspectusAnim");
    }

    $scope.deleteAnimCon = function(id) {


        $rootScope.showModalWindow("Nieodwracalne usunięcie animacji", function() {
            request.backend('deleteAnimConspect', { id: id }, function(data) {
                $scope.initConsAnimList();
            }, "Pomyślnie usunięto");
        });

    }

    $scope.addSimpleFieldCo = function(placeId) {
        var thisId = $scope.allCoElement.length;
        $scope.allCoElement.push({
            id: thisId,
            type: 'simple',
            status: 'on',
            data: {
                content: '',
                timeMin: 1,
                timeMax: 2,
                wsk: '',
                place: placeId
            }
        });
        var el = "<div class='coElement' id='" + thisId + "-simpleField" + "'><div ng-click='deleteField(" + thisId + ");' style='position: absolute; top: 9px; right: 20px; color: white; font-size: 20px; cursor: pointer'><i class='fa fa-times' aria-hidden='true' ></i></div><div class='form-group'><div class='row'><div class='input-field col s12 m6'><input id='" + thisId + "-simpleContent" + "' type='text' placeholder='Treść' class='validate' ng-model='allCoElement[" + thisId + "].data.content' required><label for='" + thisId + "-simpleContent" + "'>Treść</label></div><div class='input-field col s12 m3'><input id='" + thisId + "-simpleMinTime" + "' type='text' ng-model='allCoElement[" + thisId + "].data.timeMin' placeholder='Czas min' class='validate' required><label for='" + thisId + "-simpleMinTime" + "'>Czas min</label></div><div class='input-field col s12 m3'><input id='" + thisId + "-simpleMaxTime" + "' type='text' ng-model='allCoElement[" + thisId + "].data.timeMax' placeholder='Czas max' class='validate' required><label for='" + thisId + "-simpleMaxTime" + "'>Czas max</label></div><div class='input-field col s12'><textarea id='" + thisId + "-simpleWsk" + "' placeholder='Wskazówki' ng-model='allCoElement[" + thisId + "].data.wsk' class='materialize-textarea' data-length='255'></textarea><label for='" + thisId + "-simpleWsk" + "'>Wskazówki</label></div></div></div></div>";
        var element = angular.element($('#' + placeId).find('.data').first());
        var generated = element.html(element.html() + el);
        $compile(generated.contents())($scope);
        Materialize.updateTextFields();
    }

    $scope.addCwCo = function(response) {
        var thisId = $scope.allCoElement.length;
        $scope.allCoElement.push({
            id: thisId,
            type: 'training',
            status: 'on',
            data: {
                id: response.id,
                name: response.name,
                place: response.place
            }
        });
        var el = "<div class='coElement' id='" + thisId + "-simpleField" + "'><div ng-click='deleteField(" + thisId + ");' style='position: absolute; top: 9px; right: 20px; color: white; font-size: 20px; cursor: pointer'><i class='fa fa-times' aria-hidden='true' ></i></div> <b>Ćwiczenie: </b>" + response.name + "  </div>";
        var element = angular.element($('#' + response.place).find('.data').first());
        var generated = element.html(element.html() + el);
        $compile(generated.contents())($scope);
        Materialize.updateTextFields();
    }

    $scope.deleteField = function(id) {
        $scope.allCoElement[id].status = 'off';
        $('#' + id + '-simpleField').hide(200);
    }

    $scope.saveConspect = function() {

        $scope.coName = $('#coName').val();
        $scope.coMaster = $('#coMaster').val();
        $scope.coDate = $('#coDate').val();
        $scope.coSezon = $('#coSezon').val();
        $scope.coTeam = $('#coTeam').val();
        $scope.coOp = $('#coOp').val();
        $scope.coTags = $('.chips-placeholder').material_chip('data');

        if (!$scope.coName || $scope.coName == '' || $scope.coName == ' ' || $scope.coName == null) {
            notify.localNotify("Walidacja", "Wpisz nazwę danego konspektu");
            return;
        }

        if (!$scope.coMaster || $scope.coMaster == '' || $scope.coMaster == ' ' || $scope.coMaster == null) {
            notify.localNotify("Walidacja", "Wpisz imie, nazwisko trenera");
            return;
        }

        if (!$scope.coDate || $scope.coDate == '' || $scope.coDate == ' ' || $scope.coDate == null) {
            notify.localNotify("Walidacja", "Wpisz date");
            return;
        }

        if (!$scope.coSezon || $scope.coSezon == '' || $scope.coSezon == ' ' || $scope.coSezon == null) {
            notify.localNotify("Walidacja", "Wpisz nazwę sezonu");
            return;
        }

        if (!$scope.coTeam || $scope.coTeam == '' || $scope.coTeam == ' ' || $scope.coTeam == null) {
            notify.localNotify("Walidacja", "Wpisz przedział wiekowy");
            return;
        }

        if (!$scope.coTags || $scope.coTags.length < 2) {
            notify.localNotify("Walidacja", "Wpisz przynajmniej dwie frazy, z którymi będzie kojarzony dany konspekt");
            return;
        }

        var dataToSend = [];
        var isError = false;

        for (var i = 0; i < $scope.allCoElement.length; i++) {
            if ($scope.allCoElement[i].status == 'on') {
                if ($scope.allCoElement[i].type == 'simple') {

                    if ($scope.allCoElement[i].data.content == '') {
                        notify.localNotify("Walidacja", "Wpisz treść wszystkich prostych pól w konspekcie");
                        isError = true;
                    }
                    var minT = parseInt($scope.allCoElement[i].data.timeMin);
                    if (minT == 0) {
                        notify.localNotify("Walidacja", "Wpisz poprawnie wszystkie minimalne wartosci czasu w prostych polach");
                        isError = true;
                    }
                    var maxT = parseInt($scope.allCoElement[i].data.timeMax);
                    if (maxT == 0 || maxT <= minT) {
                        notify.localNotify("Walidacja", "Wpisz poprawnie wszystkie maksymalne wartosci czasu w prostych polach");
                        isError = true;
                    }

                    if (isError) return;
                }
                dataToSend.push({
                    type: $scope.allCoElement[i].type,
                    data: $scope.allCoElement[i].data,
                    place: $scope.allCoElement[i].place
                });
            }
        }

        var allTagString = '';
        for (var x = 0; x < $scope.coTags.length; x++) {
            allTagString += " ";
            allTagString += $scope.coTags[x].tag;
        }

        var toSend = {
            id: $scope.coActualId,
            coName: $scope.coName,
            coMaster: $scope.coMaster,
            coDate: $scope.coDate,
            coSezon: $scope.coSezon,
            coTeam: $scope.coTeam,
            coOp: $scope.coOp,
            coTags: allTagString,
            data: JSON.stringify(dataToSend),
            usid: $rootScope.user.id
        }

        request.backend('saveConspect', toSend, function(data) {
            $location.url("/conspectusList");
        }, "Pomyślnie zapisano");
    }

    $scope.showThisContent = function(id) {
        $rootScope.consepectShowId = id;
        $location.url("/showConspect");
    }

    $scope.deleteCon = function(id) {
        $rootScope.showModalWindow("Nieodwracalne usunięcie konspektu", function() {
            request.backend('deleteConspect', { id: id }, function(data) {
                $scope.initConspectusList();
            }, "Pomyślnie usunięto");
        });
    }

});
app.controller('showAnalizeController', function($scope, auth, $rootScope, notify, request) {
    $scope.showContent = false;
    $scope.fragmentList = [];

    $scope.loadAnalizeById = function() {
        request.backend('getAnalizeFragment', { id: $rootScope.analizeId }, function(data) {
            $scope.$apply(function() {
                for (let i = 0; i < data.length; i++) {
                    var isExist = false;

                    for (let x = 0; x < $scope.fragmentList.length; x++) {
                        if ($scope.fragmentList[x].name == data[i].name) {
                            $scope.fragmentList[x].list.push({
                                start_time: data[i].start_time,
                                end_time: data[i].end_time,
                                url: data[i].url
                            });
                            isExist = true;
                            break;
                        }
                    }

                    if (!isExist) {
                        $scope.fragmentList.push({
                            name: data[i].name,
                            list: [{
                                start_time: data[i].start_time,
                                end_time: data[i].end_time,
                                url: data[i].url
                            }]
                        });
                    }
                }
                $scope.showContent = true;
            });
        });
    }

    $scope.showInPlayer = function(url) {
        $('#videoPlayerContMain').show();
        $('#videoPlayerContMain video').first().attr("src", url);
        $('#videoPlayerContMain video')[0].load();
    }

});
app.controller('videoController', function($scope, auth, $rootScope, notify, request, $location) {
    $scope.showContent = false;
    $scope.showVideoPlayer = false;
    $scope.fragmentName = '';
    $scope.fragmentList = [];
    $scope.endFragmentSelect = false;
    $scope.showSendProgressBar = false;
    $scope.stillIsSending = true;
    $scope.analizeList = [];
    $scope.iconList = [];
    $scope.selectedList = [];
    var cutterStart = null;
    var cutterEnd = null;
    var start;
    var end;
    var fullTime;
    var player;
    var progressBar;

    $scope.initVideo = function() {
        request.backend('getVideoIconFull', {}, function(data) {
            $scope.$apply(function() {
                $scope.showContent = true;
                $scope.iconList = data;
            });

            setTimeout(() => {
                $('.tooltipped').tooltip({
                    delay: 50
                });

            }, 500);
        });
    }

    $scope.initOptionsVid = function() {
        request.backend('getVideoIcon', {}, function(data) {
            $scope.$apply(function() {
                $scope.showContent = true;
                $scope.iconList = data;
            });
        });
    }

    $scope.deleteIcon = function(id) {
        request.backend('deleteVideoIcon', { id: id }, function(data) {
            $scope.initOptionsVid();
        }, "Usuwanie przebiegło pomyślnie");
    }


    $(document).off('change', "#iconAdder");
    $(document).on('change', "#iconAdder", function() {
        request.backend('addVideoIcon', new FormData($("#iconAdderForm")[0]), function(data) {
            $scope.initOptionsVid();
        }, "Dodano nową ikonę", true);
    });

    $(document).off('change', ".analizeChecked");
    $(document).on('change', ".analizeChecked", function() {
        const thisElement = $(this);
        $scope.$apply(function() {
            const id = thisElement.attr("id").split("-")[1];
            const notAll = id == 'all' ? false : true;
            if (notAll) {
                if (thisElement.is(':checked')) {
                    addToSelectedList(id);
                } else {
                    deleteFromSelectedList(id);
                }
            } else {
                if (thisElement.is(':checked')) {
                    $scope.selectedList = [];
                    $(".analizeChecked").each(function() {
                        const id = $(this).attr("id").split("-")[1];
                        $(this).prop('checked', true);
                        if (id != 'all') {
                            $scope.selectedList.push(id);
                        }
                    })
                } else {
                    $scope.selectedList = [];
                    $(".analizeChecked").each(function() {
                        const id = $(this).attr("id").split("-")[1];
                        $(this).prop('checked', false);
                    })
                }
            }
        });
    });

    $scope.deleteList = function() {
        $rootScope.showModalWindow("Nieodwracalne usunięcie analiz w liczbie: " + $scope.selectedList.length, function() {
            for (let i = 0; i < $scope.selectedList.length; i++) {
                request.backend('deleteAnalize', { id: $scope.selectedList[i] }, function(data) {});
                for (let j = 0; j < $scope.analizeList.length; j++) {
                    if ($scope.analizeList[j].id == $scope.selectedList[i]) {
                        $scope.$apply(function() {
                            $scope.analizeList.splice(j, 1);
                        });
                        break;
                    }
                }
            }
        });
    }

    function deleteFromSelectedList(id) {
        for (let i = 0; i < $scope.selectedList.length; i++) {
            if ($scope.selectedList[i] == id) {
                $scope.selectedList.splice(i, 1);
                return;
            }
        }
    }

    function addToSelectedList(id) {
        for (let i = 0; i < $scope.selectedList.length; i++) {
            if ($scope.selectedList[i] == id) {
                return;
            }
        }
        $scope.selectedList.push(id);
    }

    $(document).off('change', ".iconInput");
    $(document).on('change', ".iconInput", function() {
        var id = $(this).attr('id').split("-")[1];
        var value = $(this).val();
        $scope.saveIcon(id, value);
    });

    $scope.saveIcon = function(id, value) {
        request.backend('saveVideoIcon', { id, value }, function(data) {});
    }

    $(document).off('click', ".oneIconfToAnalizer");
    $(document).on('click', ".oneIconfToAnalizer", function() {
        var name = $(this).data('analize-name');
        $(".oneIconfToAnalizer").each(function() {
            $(this).removeClass("oneIconfToAnalizerActive");
        });
        $(this).addClass("oneIconfToAnalizerActive");
        $('#fragmentName').val(name);
        $scope.$apply(function() {
            $scope.addFragment();

        });
    });

    $(document).off('change', "#videoToAnalize");
    $(document).on('change', "#videoToAnalize", function() {
        var source = $('#playerVid');
        source.on('loadedmetadata', function() {
            $scope.$apply(function() {
                $scope.showVideoPlayer = true;
            });
            setTimeout(() => {
                start = 0;
                end = parseFloat(this.duration).toFixed(3);
                fullTime = end - start;
                progressBar = $(this).next().next();
                var playStopButton = $(this).next().find("i").first();
                var resetButton = $(this).next().find("i").eq(1);
                player = this;
                var mainInterval;
                player.currentTime = start;
                addArrowPoint($(this), false);
                addArrowPoint($(this), true, true);

                $('#startIconPoint').draggable({
                    axis: "x",
                    opacity: 0.5,
                    stop: function(e, ui) {
                        var element = $('#startIconPoint');
                        var parent = $('#startIconPoint').parent().parent();
                        if (parseFloat(element.css("left")) < 0) {
                            element.css("left", 0);
                        } else if (parseFloat(element.css("left")) > (parent.width())) {
                            element.css("left", (parent.width()));
                        }
                        var maxWidth = parent.width();
                        var position = parseFloat(element.css("left"));
                        cutterStart = (start + ((position / maxWidth) * fullTime)).toFixed(3);
                        player.currentTime = cutterStart
                        updateProgressAndTime(player, progressBar.find('.currentTime').first(), start, fullTime);
                    }
                });
                $('#endIconPoint').draggable({
                    axis: "x",
                    opacity: 0.5,
                    stop: function(e, ui) {
                        var element = $('#endIconPoint');
                        var parent = $('#endIconPoint').parent().parent();
                        if (parseFloat(element.css("left")) < 0) {
                            element.css("left", 0);
                        } else if (parseFloat(element.css("left")) > (parent.width())) {
                            element.css("left", (parent.width()));
                        }
                        var maxWidth = parent.width();
                        var position = parseFloat(element.css("left"));
                        cutterEnd = (start + ((position / maxWidth) * fullTime)).toFixed(3);
                        player.currentTime = cutterEnd;
                        updateProgressAndTime(player, progressBar.find('.currentTime').first(), start, fullTime);
                    }
                });

                progressBar.on('click', function(e) {
                    var offset = $(this).offset();
                    var position = e.pageX - offset.left;
                    var maxWidth = $(this).width();
                    var time = (start + ((position / maxWidth) * fullTime)).toFixed(3);
                    player.currentTime = time;
                    updateProgressAndTime(player, progressBar.find('.currentTime').first(), start, fullTime);
                });

                resetButton.on('click', function(e) {
                    player.currentTime = start;
                    cutterStart = start;
                    cutterEnd = end;
                    updateProgressAndTime(player, progressBar.find('.currentTime').first(), start, fullTime);
                    stopPlayer(player, mainInterval);
                });

                playStopButton.on('click', function() {
                    var isStop = $(this).hasClass("fa-play-circle");
                    if (isStop) {
                        mainInterval = playPlayer(player, end, progressBar, start, fullTime);
                    } else {
                        stopPlayer(player, mainInterval);
                    }
                });
                updateProgressAndTime(player, progressBar.find('.currentTime').first(), start, fullTime);
            }, 300);
        });
        source[0].src = URL.createObjectURL(this.files[0]);
    });

    $scope.saveAnalize = function() {
        if ($('#analizeName').val().length <= 3) {
            notify.localNotify("Walidacja", "Podaj dłuższą nazwę analizy");
            return;
        }
        if ($('#analizeName').val().length > 100) {
            notify.localNotify("Walidacja", "Podaj krótszą nazwę analizy");
            return;
        }
        if ($('#analizeDescription').val().length > 500) {
            notify.localNotify("Walidacja", "Podaj krótszy opis");
            return;
        }
        if ($scope.fragmentList.length <= 0) {
            notify.localNotify("Walidacja", "Nie wyznaczyłeś żadnych fragmentów z danego klipu video. Wyznacz przynajmniej jeden.");
            return;
        }
        $scope.showSendProgressBar = true;

        var countChunk = 0;
        var fileSize = $('#videoToAnalize').prop('files')[0].size;
        var chunkSize = fileSize < 3000000 ? fileSize / 2 : 3000000;
        var maxChunk = Math.ceil((fileSize / chunkSize));
        $('#videoToAnalize').fileupload({
                maxChunkSize: chunkSize,
                files: $('#videoToAnalize').prop('files')[0],
                url: 'backend/saveVideoClip'
            })
            .on('fileuploadchunkdone', function(e, data) {
                countChunk++;
                $('.progresBarSender').find("span").first().html((parseInt((countChunk / maxChunk) * 100)) + "%");
                $('.progresBarSenderPrc').first().css("width", (parseInt((countChunk / maxChunk) * 100)) + "%");
            })

        $('#videoToAnalize').fileupload("send", {
                maxChunkSize: chunkSize,
                files: $('#videoToAnalize').prop('files')[0],
                url: 'backend/saveVideoClip',
                singleFileUploads: true,
                multipart: false,
                acceptFileTypes: /(\.|\/)(gif|jpe?g|png|mp4)$/i
            })
            .error(function(result, textStatus, jqXHR) {
                notify.localNotify("Błąd podczas przesyłania", "Przepraszamy nie możemy teraz obsłużyć tego żadania");
                console.log($('#videoToAnalize').prop('files'));
            })
            .complete(function(result, textStatus, jqXHR) {
                notify.localNotify("Zapis na serwerze", "Twój film został właśnie zapisany na serwerze. Poczekaj jeszcze chwilkę");
                $scope.stillIsSending = false;
                request.backend('saveFragments', { usid: $rootScope.user.id, frName: $('#analizeName').val(), frDescription: $('#analizeDescription').val(), frList: $scope.fragmentList, videoName: $('#videoToAnalize').prop('files')[0].name }, function(data) {
                    $scope.$apply(function() {
                        $location.url("/analizeList");
                    });
                }, "Zapis zakończony");
            });
    }

    $scope.deleteAnalize = function(id) {
        $rootScope.showModalWindow("Nieodwracalne usunięcie analizay video", function() {
            request.backend('deleteAnalize', { id: id }, function(data) {
                $scope.$apply(function() {
                    for (let i = 0; i < $scope.analizeList.length; i++) {
                        if ($scope.analizeList[i].id == id) {
                            $scope.analizeList.splice(i, 1);
                            break;
                        }
                    }
                });
            }, "Pomyślnie usunięto");
        });
    }

    $scope.showAnalize = function(id) {
        $rootScope.analizeId = id;
        $rootScope.showWidget('showAnalize', 'VideoAnalizer');
    }


    $scope.loadAnalize = function() {
        request.backend('getAnalizeList', {}, function(data) {
            $scope.$apply(function() {
                $scope.showContent = true;
                $scope.analizeList = data;
            });
        });
    }

    $scope.addFragment = function() {
        if ($('#fragmentName').val().length <= 3) {
            notify.localNotify("Walidacja", "Podaj dłuższą nazwę fragmentu");
            return;
        }
        if ($('#fragmentName').val().length > 100) {
            notify.localNotify("Walidacja", "Podaj krótszą nazwę fragmentu");
            return;
        }
        fragmentName = $('#fragmentName').val();
        var finded = false;
        for (let i = 0; i < $scope.fragmentList.length; i++) {
            if ($scope.fragmentList[i].name == fragmentName) {
                $scope.fragmentList[i].list.push({
                    start: (parseFloat(cutterStart) / 100).toFixed(3),
                    end: (parseFloat(cutterEnd) / 100).toFixed(3)
                });
                finded = true;
                break;
            }
        }
        if (!finded) {
            $scope.fragmentList.push({
                name: fragmentName,
                list: [{
                    start: (parseFloat(cutterStart) / 100).toFixed(3),
                    end: (parseFloat(cutterEnd) / 100).toFixed(3)
                }]
            });
        }
    }

    $scope.editFragment = function(name, index) {
        var time = null;
        var ins = 0;
        for (let i = 0; i < $scope.fragmentList.length; i++) {
            if ($scope.fragmentList[i].name == name) {
                ins = i;
                time = $scope.fragmentList[i].list[index] ? $scope.fragmentList[i].list[index] : null;
                break;
            }
        }
        if (time) {
            $('#playerVid')[0].currentTime = (time.start * 100).toFixed(3);
            cutterStart = (time.start * 100).toFixed(3);
            cutterEnd = (time.end * 100).toFixed(3);
            updatePointPosition();
            $('#fragmentName').val(name);
            $scope.fragmentList[ins].list.splice(index, 1);
            if ($scope.fragmentList[ins].list.length == 0) {
                $scope.fragmentList.splice(ins, 1);
            }
            playPlayer($('#playerVid')[0], end, progressBar, start, fullTime);
            $(".oneIconfToAnalizer").each(function() {
                $(this).removeClass("oneIconfToAnalizerActive");
                if ($(this).data('analize-name') == name) {
                    $(this).addClass("oneIconfToAnalizerActive");
                }
            });
        }
    }

    $(window).resize(function() {
        updatePointPosition();
    });

    function updatePointPosition() {
        var parent = $("#endIconPoint").parent().parent();
        $("#endIconPoint").css("left", (cutterEnd / end) * parent.width());
        $("#startIconPoint").css("left", (cutterStart / end) * parent.width());
    }

    function addArrowPoint(thisEl, isRed, isEnd = false) {
        var player = thisEl;
        var currTimeElement = player.next().next().find('.currentTime').first();
        var positionForArrow = {
            top: -10,
            left: currTimeElement.width()
        }
        if (isEnd) positionForArrow.left = player.next().next().width();
        var colorClass = isRed ? "arrowRed" : "arrowGreen";
        var id = isRed ? "endIconPoint" : "startIconPoint";
        $("#" + id).remove();
        var element = "<div id='" + id + "' class='arrow-up " + colorClass + "'><i class='fa fa-arrows-v fa-2x' aria-hidden='true'></i></div>";

        if (isRed) {
            cutterEnd = player[0].currentTime;
            if (isEnd) cutterEnd = end;
        } else {
            cutterStart = player[0].currentTime;
        }

        element = currTimeElement.append(element);
        $("#" + id).css("top", positionForArrow.top);
        $("#" + id).css("left", positionForArrow.left);
    }

    function stopPlayer(player, interval) {
        $(player).next().find("i").first().removeClass("fa-pause-circle");
        $(player).next().find("i").first().addClass("fa-play-circle");
        player.pause();
        clearInterval(interval);
    }

    function playPlayer(player, end, progressBar, start, fullTime) {
        $(player).next().find("i").first().removeClass("fa-play-circle");
        $(player).next().find("i").first().addClass("fa-pause-circle");
        player.play();

        if (((player.currentTime) < cutterStart)) {
            player.currentTime = cutterStart;
        }

        if (((player.currentTime) >= end) || (cutterEnd != null && (player.currentTime) >= cutterEnd)) {
            player.currentTime = start;
            if (cutterStart != null) player.currentTime = cutterStart;
        }
        var thisInterval;
        thisInterval = setInterval(function() {
            if (((player.currentTime) >= end) || (cutterEnd != null && (player.currentTime) >= cutterEnd)) {
                stopPlayer(player, thisInterval);
                return;
            }
            updateProgressAndTime(player, progressBar.find('.currentTime').first(), start, fullTime);
        }, 30);
        return thisInterval;
    }

    function updateProgressAndTime(player, progressBar, start, fullTime) {
        var actualTime = (Math.ceil(player.currentTime) - start);
        actualTime = actualTime > fullTime ? fullTime : actualTime;
        var percent = (((player.currentTime - start) / fullTime) * 100);
        actualTime = (actualTime / 100).toFixed(2);
        fullTime = (fullTime / 100).toFixed(2);
        $(player).next().next().next().html(actualTime + "<span>/</span>" + fullTime);
        percent = percent > 100 ? 100 : percent;
        progressBar.css('width', percent + "%");
    }

});
app.controller('loginController', function($scope, auth, request) {
    $scope.isActiveApplayer = false;

    $scope.initLogin = function() {
        if (auth.checkIsLogged()) {
            document.location = "panel";
        }
        var dataToSend = {};
        var urlToPost = "backend/isApplayerActive";
        var toReturn;
        request.sync('POST', urlToPost, dataToSend, function(reqData) {
            if (reqData.success) {
                $scope.isActiveApplayer = reqData.data;
            }
        }, function(jqXHR, textStatus) {
            console.log("Bład podczas komunikacji z serverem: " + textStatus);
            toReturn = false;
        });
    };

    $scope.login = function(email, password) {
        if (email == null || password == null) $(".error").html("<p> Podaj poprawnie dane </p>");
        else {
            var req = auth.logIn(email, password);
            if (req.success) {
                document.location = "panel";
            } else {
                $(".error").html("<p>" + req.error + "</p>");
            }
        }
    };

    $scope.registerNewAccount = function(){
        var firstname = $('#registerFristname').val();
        var lastname = $('#registerLastname').val();
        var email = $('#registerEmail').val();
        if( !firstname || firstname.length < 3 || firstname.length > 30 ){
            $(".errorRegister").html("<p> Podaj poprawnie imię ( min 3 maks 30 znaków ) </p>");
            return;
        }
        if( !lastname || lastname.length < 3 || lastname.length > 30 ){
            $(".errorRegister").html("<p> Podaj poprawnie nazwisko ( min 3 maks 30 znaków ) </p>");
            return;
        }
        if( !email || email.length < 3 ){
            $(".errorRegister").html("<p> Podaj poprawnie adres email </p>");
            return;
        }

        var dataToSend = { firstname: firstname, lastname: lastname,email:email };
        var urlToPost = "backend/registerNewApplayer";
        var toReturn;
        request.sync('POST', urlToPost, dataToSend, function(reqData) {
            if (reqData.success) {
                $(".successRegister").html("<p> Twoje konto zostało utworzone. Wysłaliśmy wiadomość na Twój adres email. Znajduję się w nim hasło, po uzyskaniu go możesz skorzystać z panelu logowania obok. </p>");
            }else{
                $(".errorRegister").html("<p> "+reqData.error+" </p>");
            }
        }, function(jqXHR, textStatus) {
            console.log("Bład podczas komunikacji z serverem: " + textStatus);
            toReturn = false;
        });
    }
});
app.controller('mainController', function($scope, auth, $rootScope, $route, notify, request, $compile, $location) {
    $rootScope.viewPerm = ["TRENER", "ZAWODNIK", "KOORD", "STAFF"];
    $scope.contentLoaded = false;
    $rootScope.newNotify = [];
    $rootScope.allNotify = [];
    $rootScope.lastNotId = 0;
    $rootScope.notifyCount = 0;
    $rootScope.mainSettings = [];
    $scope.showAllNewsNotify = false;
    $rootScope.editConspectWithId = null;
    $rootScope.consepectShowId = null;
    $rootScope.widgetResponse = null;
    $rootScope.teamNameStr = '';
    $rootScope.showAdw = true;
    $rootScope.user = {
        email: "",
        token: "",
        role: "",
        firstname: "",
        lastname: "",
        birthdate: "",
        imgPath: "",
        id: "",
        tmid: "",
        height: "",
        tel: "",
        parentTel: "",
        weight: "",
        mainLeg: "",
        mainPosition: "",
        address: "",
        bodyType: "",
        license_type: ""
    }
    $rootScope.feedType = 'opinia';


    $scope.turnOffAdw = function() {
        $rootScope.showAdw = false;
    }

    $scope.goFeed = function(type) {
        $rootScope.feedType = type;
        $location.url("/feedback");
    }

    $scope.showNotifications = function(isMainClik = true) {
        if (isMainClik) {
            if ($scope.showAllNewsNotify == false) {
                $scope.showAllNewsNotify = true;
            } else {
                $scope.showAllNewsNotify = false;
            }
            notify.setNewOff();
        } else {
            $scope.showAllNewsNotify = false;
        }



    }

    $rootScope.closeWidget = function(response = null) {
        $rootScope.widgetResponse = response;
        $("#widgetContainer").hide("slide", {}, 200);
    }

    $rootScope.dayToDate = function(date) {
        var a = moment();
        var b = moment([date.split('/')[2], date.split('/')[1] - 1, date.split('/')[0]]);

        var diffDays = b.diff(a, 'days');
        var color = diffDays > 30 ? '#30a42e' : diffDays < 14 ? '#a32d1f' : '#eab233';
        $('.licenseEndDay').css("color", color);
        return diffDays;
    }

    $rootScope.showWidget = function(widgetName, moduleName) {
        $.get("modules/" + moduleName + "/assets/widget/" + widgetName + ".html", function(data) {
            data = "<button class='waves-effect waves-light btn widgetClose' style='width:100%' ng-click='closeWidget();' >Zamknij okno</button>" + data;
            var content = $compile(data)($scope);
            $('.widgetContentContainer').html('');
            $('.widgetContentContainer').append(content);
            $("#widgetContainer").show("slide", {}, 200);
        });
    }

    $rootScope.showModalWindow = function(text, agreeFunction, disagreeFunction = null) {
        var data = "<h5 style='padding: 10px 20px;'>Czy jesteś pewny tego działania ?</h5>" +
            "<p style='padding: 0 20px 20px;'>" + text + "</p>" +
            "<button class='waves-effect waves-light btn widgetClose' style='width:calc(50% - 40px); float:left; margin: 0 20px 20px;' id='widgetAgree' >Tak, wykonaj</button>" +
            "<button class='waves-effect waves-light btn widgetClose' style='width:calc(50% - 40px); float:left; margin: 0 20px 20px;' id='widgetDisagree' >Anuluj</button>";

        var content = $compile(data)($scope);
        $('.widgetContentContainer').html('');
        $('.widgetContentContainer').append(content);
        $("#widgetContainer").show("slide", {}, 200);
        $(document).off("click", "#widgetAgree");
        $(document).on("click", "#widgetAgree", function() {
            $rootScope.closeWidget();
            agreeFunction();
        });
        $(document).off("click", "#widgetDisagree");
        $(document).on("click", "#widgetDisagree", function() {
            $rootScope.closeWidget();
            if (disagreeFunction) disagreeFunction();
        });
    }

    $(document).keyup(function(e) {
        if (e.keyCode === 27) $rootScope.closeWidget();
    });

    $scope.mainInit = function() {

        if (!auth.checkIsLogged()) {
            auth.logout();
            return;
        } else {
            var data = auth.getUserData();
            if (data.success) {
                request.backend('getMainPageSettings', {}, function(data) {
                    $rootScope.$apply(function() {
                        $rootScope.mainSettings = data;
                    });
                });

                request.backend('getTeams', {}, function(data) {
                    if (data.length == 0) {
                        notify.localNotify('Uwaga', "Twoje konto będzie ograniczone dopóki nie zostaniesz przypisany do sekcji");
                    } else {
                        $('#teamSelect').html('');
                        $('#teamSelect').append("<option value='' disabled> Wybierz sekcję </option>");
                        for (var i = 0; i < data.length; i++) {
                            $('#teamSelect').append("<option value='" + data[i].tmid + "'" + (i == 0 ? 'selected' : '') + ">" + data[i].name + "</option>");
                        }
                        if (data[0] != null && data[0].tmid != null) {
                            $rootScope.user.tmid = data[0].tmid;
                            $rootScope.teamNameStr = data[0].name;
                        }

                    }
                    setTimeout(function() {
                        $('#loadingContent').hide('slide', {}, 1000);
                        $('#mainContent').show('fade', {}, 1000);
                        document.location.href = "/panel#!/";
                        $route.reload();
                        notify.getNew(true);
                        setInterval(function() {
                            notify.getNew();
                        }, 5000);

                    }, 500);
                    $('select').material_select();
                });

            } else {
                document.location = "login";
                return;
            }
        }
    };

    $(document).on('click', '#printButton', function() {
        $("body").prepend($("#main-content-in"));
        var element = $("body>div").each(function() {
            if ($(this).attr('id') != "main-content-in")
                $(this).addClass('noPrint');
        });
        $(".ng-hide").each(function() {
            $(this).addClass('noPrint');
        });
        window.print();
        $("#main-content").prepend($("#main-content-in"));
        $(".ng-hide").each(function() {
            $(this).removeClass('noPrint');
        });
    });


    function createPDF() {
        var element = document.getElementById('main-content-in');
        html2pdf(element, {
            margin: 2,
            filename: 'myfile.pdf',
            image: { type: 'jpeg', quality: 1 },
            html2canvas: { dpi: 256, letterRendering: true },
            jsPDF: { unit: 'mm', format: 'a4', orientation: 'portrait' }
        });
    } // create canvas object


    $(document).on('change', '#teamSelect', function() {
        $rootScope.user.tmid = $("option:selected", this).val();
        $rootScope.teamNameStr = $("option:selected", this).text();
        document.location.href = "/panel#!/";
        $route.reload();
    });

    $('.closeVideoPlayer i').off("click")
    $('.closeVideoPlayer i').on("click", function() {
        $('#videoPlayerContMain video')[0].pause();
        $('#videoPlayerContMain').hide();
    });

    $rootScope.toggleCardOptions = function(id) {
        $('.cardOptions').each(function() {
            var tId = $(this).attr('id');
            if (!tId || (tId && tId != id))
                $(this).stop().hide('slide', { direction: 'up' });
        });

        if ($("#" + id)) {
            $("#" + id).first().stop().toggle('slide', { direction: 'up' });
        }
    }

});
app.config(function($routeProvider) {
    var urlToPost = "backend/getModulesFrontRoutes";
    $.ajax({
        url: urlToPost,
        type: "POST",
        data: [],
        async: true,
        success: function(msg) {
            if (msg.success) {
                for (var x = 0; x < msg.data.length; x++) {
                    if (msg.data[x].url == 'badPerm') {
                        $routeProvider.otherwise({
                            templateUrl: msg.data[x].templateSrc
                        });
                    } else {
                        $routeProvider.when((msg.data[x].url == "/" ? "/" : "/" + msg.data[x].url), {
                            templateUrl: msg.data[x].templateSrc,
                            controller: msg.data[x].controllerName
                        });
                    }
                }
            } else {
                if (msg.error)
                    $.gritter.add({
                        title: 'Bład',
                        text: msg.error,
                        image: '',
                        sticky: true,
                        time: 3,
                        class_name: 'my-sticky-class'
                    });
            }
        },
        error: function(jqXHR, textStatus) {
            $.gritter.add({
                title: 'Bład',
                text: "Blad podczas laczenia z serverem: " + textStatus,
                image: '',
                sticky: true,
                time: 3,
                class_name: 'my-sticky-class'
            });
        }
    });

});